---
title: 算法篇 - 回溯
date: 2021-04-10 22:41
tags: 
- 数据结构
- 算法
- 面试
categories: 算法
excerpt: 39-组合总和
---

# 回溯
[回溯算法入门级详解](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)
**回溯法:** 采用试错思想, 尝试分步解决一个问题; 在分步解决问题的过程中, 当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候, 它将取消上一步甚至是上几步的计算, 再通过其它的可能的分步解答再次尝试寻找问题的答案; 回溯法通常用最简单的递归方法来实现, 在反复重复上述的步骤后可能出现两种情况:
* 找到一个可能存在的正确的答案；
* 在尝试了所有可能的分步方法后宣告该问题没有答案; 

**深度优先搜索算法(DFS):** 一种用于遍历或搜索树或图的算法; 该算法会尽可能深的搜索树的分支; 当结点 v 的所在边都己被探寻过, 搜索将**回溯**到发现结点 v 的那条边的起始结点; 这一过程一直进行到已发现从源结点可达的所有结点为止; 如果还存在未被发现的结点, 则选择其中一个作为源结点并重复以上过程, 整个进程反复进行直到所有结点都被访问为止; 

回溯法是**基于深度优先搜索思想**, 通过**遍历**实现; 因此, 回溯法也是一种暴力解法, 我们可以通过**剪枝**, 在遍历过程中将绝对不符合条件的分支即时剪去, 避免无意义的遍历, 从而降低回溯的成本;

**回溯与动态规划的区别**
***共同点***
用于求解多阶段决策问题; 多阶段决策问题即:
* 求解一个问题分为很多步骤（阶段）;
* 每一个步骤（阶段）可以有多种选择; 

***不同点***
* 动态规划用于求解问题的最优解;
* 回溯算法可以搜索得到所有的方案(包括最优解), 但是本质上它是一种遍历算法, 时间复杂度很高; 

# 回溯的状态栈管理
* 每一个节点表示了求解排列组合问题的不同的阶段, 称之为「状态」;
* 「状态重置」: 将"状态变量"设置成为和先前一样, 在回到上一层节点的过程中, 需要撤销上一次的选择;
* 借助栈空间, 保存所需要的状态变量: 遍历往下深入时, 状态变量在状态栈尾部追加, 回退时, 撤销上一次的选择，即从栈尾部弹出状态变量; 全局只需维护一个状态栈;


# 回溯代码实现思路
画树形图 (明确递归结构, 递归出口, 以及剪枝部分)
```
function xxx(arr) {
  数组与处理 (数组长度, 数组排序...)

  声明变量存储组合结果

  function backTrack(状态栈) {
    if (递归出口条件) {
      存储结果(注意引用类型要克隆)
      递归结束
    }

    for (... 循环遍历当前节点下所有组合 ...) {
      // 回溯操作的关键: 维护一个状态栈, 每次遍历时入栈, 在下一次遍历前出栈, 回溯到同一层节点;
      栈入
      backTrack(...)
      栈出
    }
  }

}
```


## 39 - 组合总和
[LeetCode题目地址](https://leetcode-cn.com/problems/combination-sum/submissions/)
![](/img/posts_img/算法篇-回溯-39组合总和-1.png)
**题解**
树形图:
![](/img/posts_img/算法篇-回溯-39组合总和-2.png)
```
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
  // 数组排序
  candidates = candidates.sort((a,b)=>a-b);
  // 结果数组
  let res = [];

  // 递归函数
  // curSum: 当前总和
  // combList: 当前组合列表
  // start: 遍历的节点(去重)
  function backTrack (curSum, combList, start) {
    // 递归出口
    if (curSum >= target) {
      // 若符合条件, 添加当前组合至结果数组
      // (注意此处为克隆, combList 既存储当前组合又是一个状态栈)
      // (直接存储只保留其引用地址, 最终结果会是 [], 因为状态栈最终会回溯到根节点)
      curSum === target && res.push(combList.slice())
      return;
    }
    // 遍历当前层节点
    for (let i=start; i<candidates.length; i++) {
      // 状态栈入栈
      combList.push(candidates[i]);
      // 递归(进入下一层, 下层遍历基于上层节点开始遍历, 达到去重的目的)
      backTrack(curSum + candidates[i], combList, i)
      //状态栈出栈(状态重置到当前层, 遍历当前层其他节点)
      combList.pop();
    }
  }

  backTrack(0, [], 0);

  return res;
};
```

**上述代码实现了回溯的一个基本操作, 即通过递归和遍历实现对每一层节点的判断, 同时维护一个状态栈, 实现回溯算法最关键的状态重置; (回溯是由递归 + 遍历 + 状态栈共同实现的, 本质是递归, 遍历是搜索各节点的手段, 状态栈是状态重置的关键)**
***本题剪枝思想体现在递归出口处, 当求和结果大于目标值时, 直接终止递归达到剪枝的目的***