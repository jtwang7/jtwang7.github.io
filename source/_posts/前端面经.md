---
title: 前端面经
date: 2021-04-02 15:31
tags: JavaScript
categories: JavaScript
excerpt: 前端知识点大汇总, 站在巨人的肩膀上看问题 --- 一篇基于各前端面经所做的知识点梳理。
---


# 前端知识点
[参考的面经地址](https://www.nowcoder.com/discuss/258810)
## JavaScript
#### 原始值和引用值类型及区别
**参考文章**
[你真的掌握变量和类型了吗](https://juejin.cn/post/6844903854882947080)
**题解**
前置知识(内存空间):
JS中任何变量都需要内存开辟一个空间存储.
内存空间: 栈内存 & 堆内存.
栈内存:

1. 存储空间大小固定 (意味着存储的值不可改变)
2. 空间较小
3. 可直接操作保存的变量,运行效率高
4. 由系统自动分配存储空间

堆内存:

1. 存储大小不固定,可动态调整
2. 空间较大, 运行效率低
3. 无法直接操作内部存储, 通过引用地址访问
4. 通过代码分配内存空间

**从内存理解原始值与引用值的区别:**
原始值(Null, Undefined, Boolean, Number, String, Symbol): 
存储于栈内存, 值本身不可被改变. (变量定义时,栈已经完成内存空间分配,且栈内存空间大小固定)
`str += 6` 等操作不违背原始值 "不可变性" 的特点. 该操作实际是在栈中新开辟了内存空间存储新值, 并将原变量`str`指向该内存空间, 原数据内存空间若不存在引用则后续会被JS垃圾回收机制释放.

引用值(Object, Array, Function, Date,...):
值本身存储于堆内存, 在栈内存中存储了一个指向该值的定长地址. 引用值可被改变, 例如数组等,存在许多可改变其自身的方法(pop; push; ...)

**从操作角度对比原始值与引用值的区别:**
1. 复制: 
原始值复制, 栈内存中开辟新的空间存储拷贝的变量值, 由于开辟了新的空间, 因此拷贝值与被拷贝值虽然值相同, 但指向的内存空间互不相同, 两者的任何操作都是独立的, 互不影响.
引用值复制, 复制的是其栈内存中的地址, 栈内存新开辟一个空间存储拷贝的地址. 拷贝值与被拷贝值的地址均指向堆内存中同一对象, 因此两者操作的实际上是同一对象, 互相影响.

2. 比较:
两个原始值之间比较, 直接比较它们值是否相等, 若相等则返回 `true`;
两个引用值之间比较, 比较它们存储在栈内存中的地址, 由于两者地址不同, 即使它们在堆内存中的存储对象具有相同属性值, 比较值仍返回 `false`;

3. 值传递: **JS所有函数的参数都是按值传递!**
原始值与引用值作为函数参数传递, 本质上传递的是变量拷贝的副本, 在函数内操作的是拷贝值而非变量背身. 两者区别在于:
原始值与其复制的局部变量, 两者内存空间不同, 修改局部变量不影响外部原值;
引用值复制的是指向堆内存的地址, 函数内修改局部变量会对外部变量造成影响;

#### 判断数据类型的方式 typeof; instanceof; Object.prototype.toString.call(); constructor
**参考文章**
[你真的掌握变量和类型了吗](https://juejin.cn/post/6844903854882947080)
**题解**
typeof:
使用场景: 可准确判断变量的原始类型, 例如 `typeof 123 === 'number'`; 还可以判断函数类型, 例如 `typeof function(){} === 'function'`
不适用于判断引用类型, 例如 `typeof [] === 'object'`; `typeof {} === 'object'`; `typeof new Date() === 'object'`

instanceof:
使用场景: 判断引用类型对象的具体类型, 例如 `[] instanceof Array === true`
本质: 通过原型链判断, 上例中主要判断 Array.prototype(原型) 是否在 [] 的原型链上, 若是则返回 `true`
缺点:
1. 由于 instanceof 是通过原型链判断的, 而 Obejct.property 是所有原型链的终点, 因此 `[] instanceof Object === true` 等总是成立, 导致在检测数据类型时不会很准确. (另一种解释是被检测目标可能更改过原型指向,导致检测不准确)
2. instanceof 不能检测基本数据类型

Object.prototype.toString.call():
基本可以解决所有内置对象类型的判断问题.
所有引用类型均有 `toString()` 方法, `toString()` 方法默认被所有 Object 对象继承, 其包括了 Array; Date 等常见引用类型, 也包括了 String, Number 等特殊引用的包装类型. **`toString()` 方法若继承后没有被覆盖(重写), 则返回 `"[object type]"`, 其中 `type` 就是被检测对象的类型**
但是,该场景需要在`toString`方法未被重写的条件下实现, 而大多引用类型, 例如 Array; Date 等, 都对`toString`方法进行了重写. 因此, 我们在用`toString`进行类型判断时, 需直接调用 `Object.property` 原型的 `toString` 方法, 并用 `call` 改变 `this` 指向被检测目标.
缺点: 无法用于自定义的构造函数

constructor:
`xxx.constructor === Animal`
利用了对象的constructor指向构造函数的原理; 但constructor属性会被随意修改, 且容易混淆指向, 不推荐.

#### 类数组与数组的区别与转换
**参考文章**
[类数组与数组](https://blog.csdn.net/thunderevil35/article/details/80617907)
[JS 原生面经从初级到高级 -- 3.8节](https://juejin.cn/post/6844903976081555470)
[JavaScript 类数组对象与 arguments](https://juejin.cn/post/6844903711022514184)
**题解**
类数组对象定义: 拥有 length 属性且可通过索引属性访问元素的对象
```
const arrLike = {
  0: 'aaa',
  1: 'bbb',
  length: 2,
}
```
类数组对象与数组的相同点: 访问/赋值/获取长度等操作与数组一致
区别: 类数组对象不能直接使用数组方法. 因此类数组对象比数组局限性大, 通常需要将类数组转化为数组.
区分类数组与数组的方法:
1. instanceof
2. constructor
3. toString()
4. ES提供的 isArray()

类数组到数组的转化:
call/apply实现: 改变Array原型slice方法的this指向, 将arguments复制为新的数组; (splice方法也可以,但splice方法是在原类数组基础上做的改变,不是创建新数组)
Array.from: 可根据类数组或可迭代对象创建出新数组
... Spread语法: 将类数组扩展为字符串后,再重新定义为数组
1. `Array.prototype.slice.call(arguments)`
2. `Array.prototype.slice.apply(arguments)`
3. `Array.from(arguments)`
4. `[...arguments]`

除了转化外, 类数组对象还可以通过**方法借用**调用数组方法, 例如 `Array.prototype.push.call(arguments, 'xxx')` 等

#### 数组的常见API
**参考文章**
[js 数组详细操作方法及解析合集](https://juejin.cn/post/6844903614918459406)
**题解**
数组原型提供了许多方法(API), 可大致分为三类: 改变原数组; 不改变原数组; 数组遍历
API的具体参数及作用不在本文详述, 具体可通过参考文章了解.
改变原数组的API(9):
1. `array.splice(index, num, item1,...)`
2. `array.sort(func(a,b){...})`
3. `array.pop()`
4. `array.push(item1,...)`
5. `array.shift()`
6. `array.unshift(item1,...)`
7. `array.reverse()`
8. `array.copyWithin(target, start, end)`
9. `array.fill(num, start, end)`

不改变原数组的API(8):
1. `array.slice(begin, end)`
2. `array.join(str)`
3. `array.toLocalString()`
4. `array.toString()`
5. `array.concat(array1,...)`
6. `array.indexOf(searchElement, fromIndex)`
7. `array.lastIndexOf(searchElement, fromIndex)`
8. `array.includes(searchElement, fromIndex)`

遍历数组(12):
遵循原则: 尽量不要在遍历的时候，修改后面要遍历的值; 尽量不要在遍历的时候修改数组的长度（删除/添加）
1. `array.forEach(function(currentValue, index, arr), thisValue)`
2. `array.every(function(currentValue, index, arr), thisValue)`
3. `array.some(function(currentValue, index, arr), thisValue)`
4. `array.filter(function(currentValue, index, arr), thisValue)`
5. `array.map(function(currentValue, index, arr), thisValue)`
6. `array.reduce(function(total, currentValue, currentIndex, arr), initialValue)`
7. `array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)`
8. `array.find(function(currentValue, index, arr), thisArg)`
9. `array.findIndex(function(currentValue, index, arr), thisArg)`
10. `array.keys()`
11. `array.values()`
12. `array.entries()`

#### bind、call、apply的区别
**参考文章**
[细说 call、apply 以及 bind 的区别和用法](https://juejin.cn/post/6844903768132157447)
[装饰器模式和转发，call/apply](https://zh.javascript.info/call-apply-decorators)
[函数绑定](https://zh.javascript.info/bind)
**题解**
call / apply 区别:
主要体现在参数: call 第二参数接收任何可迭代对象; apply 第二参数接收数组或类数组对象

bind / (call; apply) 区别:
bind 方法返回新的函数, 该函数 this 指向提供的第一参数;
bind 方法不会立即执行, 需要手动调用; call/apply 方法立即执行

bind / call / apply 共同点:
作用对象必须是一个函数, 即 `Function.apply()` 等;
目的是改变函数执行时的上下文;