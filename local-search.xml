<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法篇 - 二分查找</title>
    <link href="/2021/05/04/%E7%AE%97%E6%B3%95%E7%AF%87%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/05/04/%E7%AE%97%E6%B3%95%E7%AF%87%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>最佳题解(位于 leetcode 35-搜索插入位置):<br><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">写对二分查找不能靠模板,要理解加练习</a></p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="把待搜索区间分成两个部分-核心思想"><a href="#把待搜索区间分成两个部分-核心思想" class="headerlink" title="把待搜索区间分成两个部分(核心思想)"></a>把待搜索区间分成两个部分(核心思想)</h2><p>二分查找能实现时间复杂度 <code>nlogn</code> 的关键在于: 其利用单调性(绝大多数二分查找问题利用的是单调性, 也有一些例外)或者题目本身蕴含的可以逐渐缩小问题规模的特性解决问题;<br>通常做法是将问题转化成解空间表达, 然后取中间值与目标进行比较判断, 进而收缩解空间大小, 缩小问题规模;</p><p>因此, 二分查找的关键就在于 mid:<br><code>nums[mid]</code> 可以将待搜索区间分为两个部分:</p><ul><li>一定不存在目标元素的区间: 下一轮搜索的时候, 不用考虑它;</li><li>可能存在目标元素的区间: 下一轮搜索的时候, 需要考虑它;</li></ul><p>而上述情况中, 又根据 <code>nums[mid]</code> 被划分到哪个区间分为:<br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%9F%BA%E7%A1%80.png"></p><ul><li>如果 mid 分到左边区间, 即区间分成 <code>[left..mid]</code> 与 <code>[mid + 1..right]</code>, 此时分别设置 <code>right = mid</code> 与 <code>left = mid + 1</code>;</li><li>如果 mid 分到右边区间, 即区间分成 <code>[left..mid - 1]</code> 与 <code>[mid..right]</code>, 此时分别设置 <code>right = mid - 1</code> 与 <code>left = mid</code>;</li></ul><h2 id="循环条件-while-left-lt-right"><a href="#循环条件-while-left-lt-right" class="headerlink" title="循环条件 [while (left &lt; right)]"></a>循环条件 [while (left &lt; right)]</h2><p>此外, 我们把循环条件写成 <code>while (left &lt; right)</code>; 这样写的好处在于, 在上面把待搜索区间分成两个部分的情况下, 退出循环以后一定会有 <code>left == right</code> 成立, 因此在退出循环以后, 不需要考虑到底返回 left 还是返回 right;</p><h2 id="组织逻辑的「重要的经验」"><a href="#组织逻辑的「重要的经验」" class="headerlink" title="组织逻辑的「重要的经验」"></a>组织逻辑的「重要的经验」</h2><p>在写 if 语句的时候, 通常把容易想到的, 不容易出错的逻辑写在 if 的里面;<br>这样写的依据是: 由于 mid 只划分两个空间, 最终解要么在左区间, 要么在右区间, 我们将不会出错的逻辑写在 if 内, 那么复杂的、容易出错的情况就不用我们去考虑了, 因为它们统统都被包括在了 else 的部分, 这样编写代码不容易出错;</p><blockquote><p>什么情况是容易想到的, 不容易出错的呢?<br>经验: 题目要我们找符合条件 a 的元素, 我们就对条件 a 取反面, 这样分析不容易出错; 例如题目让我们寻找大于等于 target 的值, 那我们就将小于 target 的值的情况写在 if 内, 因为该情况必然不是正确解, 因此可以收缩解空间范围;</p></blockquote><h2 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h2><p>在二分查找中, 我们实质上始终是在 <code>[left...right]</code> 中搜索解, 通过 mid 将解空间划分成两个区间, 抛弃必不可能存在正解的区间以达到查找目标的结果;<br><strong>注意: 我们说的是 左闭右闭区间;</strong><br>为什么不是「左闭右开」呢？<br>「左闭右开」当然可以, 这是因为任意一个「左闭右开 [left..right) 」区间一定唯一对应一个「左闭右闭 [left..right - 1]」区间, 所以到底是开区间还是闭区间, 前后保持一致就可以;<br>但是我们<strong>不想把精力花在思考「右边界是不是可以取到」这件事情上</strong>, 根据 mid 位置是不是目标元素, 进而判断 mid 的左边是否存在目标元素, mid 的右边是否存在目标元素, 只把搜索区间分为两个部分, 然后设置 left 和 right, 在设置 left 和 right 的时候, <strong>左闭右闭区间的形式是最直观的</strong>, 这是因为如果是开区间, 还需要在脑子里反应一下, 右端点不包括;</p><h2 id="mid-取整方式"><a href="#mid-取整方式" class="headerlink" title="mid 取整方式"></a>mid 取整方式</h2><p>在二分查找中, mid 取值通常有以下两种写法:</p><ul><li><code>let mid = Math.floor(left + (right - left) / 2);</code></li><li><code>let mid = Math.ceil(left + (right - left) / 2);</code></li></ul><p>第一种写法向下取整, 第二种写法向上取整; </p><p><strong>为什么有两种取整方式, 该怎么选择?</strong><br>是否需要上取整, 只和区间划分的逻辑有关; 如果不调整, 会出现死循环;<br>由于我们定义的循环条件为 <code>while (left &lt; right)</code>, 因此最终必然会有搜索区间 <code>[left...right]</code> 只包含两个元素的情况;<br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEmid%E5%8F%96%E6%95%B4.png"></p><p>结论: 当区间只剩下两个元素的时候, <code>left = mid</code> 和 <code>right = mid - 1</code> 这种划分方式, 如果 mid 使用默认下取整的方式, 在数值上 <code>left = mid</code>, 而它对应的其中一个区间是 <code>[mid..right]</code>, 在这种情况下, 下一轮搜索区间还是 <code>[left..right]</code>, 搜索区间没有减少, 会进入死循环; </p><p>提示: 「看到边界设置的代码是 <code>left = mid</code> 时, 需要把 mid 的取法调整为上取整, 以避免死循环」, 「看到边界设置的代码是 <code>right = mid</code> 时, 需要把 mid 的取法调整为下取整, 以避免死循环」;<br>记忆: 当 <code>left = mid</code> 时, 由于我们要避免 mid 落入 left 中, 因此计算时通过向上取整, 让每次 mid 计算都落入 right, 然后通过 <code>right = mid - 1</code> 来跳出循环; <code>right = mid</code> 同理;</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>首先想清楚这道问题为什么可以用二分查找解决(而不应该先纠结二分查找该怎么写), 利用题目中给出的单调性或者可以缩减问题规模的特点：已知某个猜测的答案的结果, 就可以推测出比当前猜测小的时候结果如何, 比当前猜测大的时候结果如何; 常见应用为：有序或者半有序数组中找下标, 确定一个有范围的整数; </li><li>首先确定搜索的范围(解空间), 如果搜索的范围就把正确答案排除在外, 那么是无论如何也搜不出正确结果的；</li><li>可以从「看到的中间元素什么时候不是解」开始思考 if 的语句怎么写, if 的逻辑越简单越好, 这样才能保证不会错, 剩下的复杂的情况留给 else, else 的区间就是剩下的区间；</li><li>只把区间分成两个部分, 代码也写成两个部分, 这样, 在 while (left &lt; right) 的循环体退出以后, left == right 才成立（理解这一点非常重要, 理解的基础是做适当的练习, 进行必要的调试）；</li><li>看到 if 和 else 里有 left = mid 的时候, 需要将 mid 调整为上取整, 原因是当区间里只剩下两个元素的时候, mid 看到右边元素, 这样落入 left = mid 的时候, 区间才会缩减; 如果觉得这一点很难理解的朋友, 打印变量看一下就非常清楚了；</li><li>如果搜索区间里一定存在目标元素, 退出 while (left &lt; right) 以后, 返回 left 或者 left 代表的值就可以, 否则还需要单独做一次判断；</li></ol><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><p><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-704%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.png"><br>题解:</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> <span class="hljs-built_in">search</span> = function (nums, target) &#123;<br>  // 初始化解空间 [<span class="hljs-number">0</span>, nums.length-<span class="hljs-number">1</span>]<br>  let <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>  let <span class="hljs-built_in">right</span> = nums.length - <span class="hljs-number">1</span>;<br><br>  // 二分查找<span class="hljs-symbol">:</span> 当 <span class="hljs-built_in">left</span> === <span class="hljs-built_in">right</span> 时跳出循环;<br>  // <span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span> 优势<span class="hljs-symbol">:</span> 最终得到结果时, 不需要考虑取 <span class="hljs-built_in">left</span> 还是 <span class="hljs-built_in">right</span>;<br>  while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>    // 获取 <span class="hljs-built_in">mid</span> 索引;<br>    // 由于后续 <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>, 因此此处 <span class="hljs-built_in">mid</span> 向上取整, 避免只剩两个元素时 <span class="hljs-built_in">mid</span> 落入 <span class="hljs-built_in">left</span> 后发生死循环(向上取整, 落入 <span class="hljs-built_in">right</span>, <span class="hljs-built_in">right</span> 可以通过 - <span class="hljs-number">1</span> 跳出循环)<br>    let <span class="hljs-built_in">mid</span> = Math.ceil(<span class="hljs-built_in">left</span> + (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &gt; target) &#123;<br>      <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>    &#125; else &#123;<br>      <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>;<br>    &#125;<br>  &#125;<br>  return nums[<span class="hljs-built_in">left</span>] === target ? <span class="hljs-built_in">left</span> <span class="hljs-symbol">:</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><p><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-34%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.png"><br>题解:</p><figure class="highlight swift"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> searchRange = function (nums, target) &#123;<br>  <span class="hljs-comment">// 问题 &lt;=&gt; 寻找左边界和右边界</span><br><br>  <span class="hljs-comment">// 将寻找边界写成一个函数, findLeft 控制寻找左边界或右边界</span><br>  function <span class="hljs-built_in">find</span>(nums, target, findLeft = <span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 初始化解空间 [0, nums.length-1]</span><br>    <span class="hljs-comment">// 解空间建议采用左右闭区间, 这样就不需要考虑左开或右开导致的问题, 更符合人的思维方式;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">left</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">right</span> = nums.length - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 二分查找</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">left</span> &lt; <span class="hljs-keyword">right</span>) &#123;<br>      <span class="hljs-keyword">if</span> (findLeft) &#123;<br>        <span class="hljs-comment">// 寻找左边界</span><br>        <span class="hljs-keyword">let</span> mid = <span class="hljs-type">Math</span>.floor(<span class="hljs-keyword">left</span> + (<span class="hljs-keyword">right</span> - <span class="hljs-keyword">left</span>) / <span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 当 mid 对应值比目标值小时, 说明左侧包括 mid 均不符合;</span><br>        <span class="hljs-comment">// 二分法将整个解空间划分为了两个区间, 我们只需要判断值落在哪个区间, 并舍弃另一区间即可; 下述代码等价于将解空间划分为 [left...(mid)] [(mid + 1)...right];</span><br>        <span class="hljs-comment">// 小技巧: 通常将不容易出错的逻辑写在 if 内, 这样正解必然包含在 else 内, 无需我们判断;</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>          <span class="hljs-keyword">left</span> = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">right</span> = mid<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 与上述思路相同, 寻找右边界, 只不过 mid 要向上取整, 避免 mid 落入 left 中发生死循环;</span><br>        <span class="hljs-keyword">let</span> mid = <span class="hljs-type">Math</span>.ceil(<span class="hljs-keyword">left</span> + (<span class="hljs-keyword">right</span> - <span class="hljs-keyword">left</span>) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>          <span class="hljs-keyword">right</span> = mid - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">left</span> = mid;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-keyword">left</span>] === target ? <span class="hljs-keyword">left</span> : -<span class="hljs-number">1</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> [<span class="hljs-built_in">find</span>(nums, target, <span class="hljs-literal">true</span>), <span class="hljs-built_in">find</span>(nums, target, <span class="hljs-literal">false</span>)]<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h2><p><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-33%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84.png"><br>题解:</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> <span class="hljs-built_in">search</span> = function (nums, target) &#123;<br>  let <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>  let <span class="hljs-built_in">right</span> = nums.length - <span class="hljs-number">1</span>;<br><br>  while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>    let <span class="hljs-built_in">mid</span> = Math.floor(<span class="hljs-built_in">left</span> + (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>);<br>    // 旋转数组首先要通过 <span class="hljs-built_in">mid</span> 判断有序数组;<br>    // 当 <span class="hljs-built_in">mid</span> 对应值 &gt; <span class="hljs-built_in">left</span> 对应值时, 说明 [left...mid] 是有序的; 反之, 说明 [mid...right] 是有序的;<br>    // nums[<span class="hljs-built_in">mid</span>] == nums[<span class="hljs-built_in">left</span>] 处理和 &gt; 一样, 因此写到一起;<br>    <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &gt;= nums[<span class="hljs-built_in">left</span>]) &#123;<br>      // 当解空间 [left...mid] 有序时, 判断 target 和边界, 从而确定 target 是在该有序解空间内还是外, 从而缩小解空间范围;<br>      <span class="hljs-built_in">if</span> (target &gt;= nums[<span class="hljs-built_in">left</span>] &amp;&amp; target &lt;= nums[<span class="hljs-built_in">mid</span>]) &#123;<br>        <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span><br>      &#125; else &#123;<br>        <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span><br>      &#125;<br>    &#125; else &#123;<br>      // 因为 <span class="hljs-built_in">mid</span> 是向下取整的, 所以我们要保证 <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>, 即 <span class="hljs-built_in">mid</span> 每次都要落在 <span class="hljs-built_in">right</span> 上; 所以这里的判断条件是 target 是否在 (<span class="hljs-built_in">mid</span>, <span class="hljs-built_in">right</span>] 内, 这样才能保证 <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">if</span> (target &gt; nums[<span class="hljs-built_in">mid</span>] &amp;&amp; target &lt;= nums[<span class="hljs-built_in">right</span>]) &#123;<br>        <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span><br>      &#125; else &#123;<br>        <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  return nums[<span class="hljs-built_in">left</span>] === target ? <span class="hljs-built_in">left</span> <span class="hljs-symbol">:</span> -<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a>81. 搜索旋转排序数组 II</h2><p><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-81%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%842.png"><br>题解:</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> <span class="hljs-built_in">search</span> = function(nums, target) &#123;<br>  // 旋转数组 - 有重复值版本<br>  let <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>  let <span class="hljs-built_in">right</span> = nums.length - <span class="hljs-number">1</span>;<br>  <br>  while(<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>    let <span class="hljs-built_in">mid</span> = Math.floor(<span class="hljs-built_in">left</span> + (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>);<br><br>    // 只需要在原先旋转数组基础上改进一点即可<br>    // 当 nums[<span class="hljs-built_in">mid</span>] === nums[<span class="hljs-built_in">left</span>] === nums[<span class="hljs-built_in">right</span>] 时, 此时无法判断有序序列, 因此只需要跳过该情况, 两端同时收缩区间即可;<br>    <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">left</span>] === nums[<span class="hljs-built_in">mid</span>] &amp;&amp; nums[<span class="hljs-built_in">mid</span>] === nums[<span class="hljs-built_in">right</span>] &amp;&amp; <span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span> &gt; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">left</span> += <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">right</span> -= <span class="hljs-number">1</span>;<br>      continue;<br>    &#125;<br><br>    // 同 <span class="hljs-number">33</span>.旋转数组<br>    <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &gt;= nums[<span class="hljs-built_in">left</span>]) &#123;<br>      <span class="hljs-built_in">if</span> (target &gt;= nums[<span class="hljs-built_in">left</span>] &amp;&amp; target &lt;= nums[<span class="hljs-built_in">mid</span>]) &#123;<br>        <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span><br>      &#125; else &#123;<br>        <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125; else <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &lt; nums[<span class="hljs-built_in">left</span>]) &#123;<br>      <span class="hljs-built_in">if</span> (target &gt; nums[<span class="hljs-built_in">mid</span>] &amp;&amp; target &lt;= nums[<span class="hljs-built_in">right</span>]) &#123;<br>        <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;<br>      &#125; else &#123;<br>        <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  return nums[<span class="hljs-built_in">left</span>] === target;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h2><p><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-153%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC.png"><br>题解:</p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> findMin = function (nums) &#123;<br>  // 旋转数组可以画一个单调性的图, 通过观察可知, 当 <span class="hljs-built_in">mid</span> 大于右边界时, 说明最小值存在于右侧 [(<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>)...<span class="hljs-built_in">right</span>], 反之最小值存在于左侧区间 [left...mid]<br>  let <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;<br>  let <span class="hljs-built_in">right</span> = nums.length - <span class="hljs-number">1</span>;<br><br>  while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>    let <span class="hljs-built_in">mid</span> = Math.floor(<span class="hljs-built_in">left</span> + (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &gt; nums[<span class="hljs-built_in">right</span>]) &#123;<br>      <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span><br>    &#125; else &#123;<br>      <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span>;<br>    &#125;<br>  &#125;<br><br>  return nums[<span class="hljs-built_in">left</span>];<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a>154. 寻找旋转排序数组中的最小值 II</h2><p><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-154%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC2.png"><br>题解:</p><figure class="highlight swift"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> findMin = function(nums) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">left</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">right</span> = nums.length - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span>(<span class="hljs-keyword">left</span> &lt; <span class="hljs-keyword">right</span>) &#123;<br>    <span class="hljs-keyword">let</span> mid = <span class="hljs-type">Math</span>.floor(<span class="hljs-keyword">left</span> + (<span class="hljs-keyword">right</span> - <span class="hljs-keyword">left</span>) / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 旋转数组重复值就用该方法解决;</span><br>    <span class="hljs-comment">// 当遇到 mid = left = right 值相同时, 此时无法判断有序数组在哪一部分, 两端缩进, 跳过;</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">right</span> - <span class="hljs-keyword">left</span> &gt; <span class="hljs-number">1</span> &amp;&amp; nums[<span class="hljs-keyword">left</span>] === nums[mid] &amp;&amp; nums[mid] === nums[<span class="hljs-keyword">right</span>]) &#123;<br>      <span class="hljs-keyword">left</span> += <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">right</span> -= <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">continue</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后续思路同不重复旋转数组一样; 当作没有重复值的旋转数组来解决;</span><br>    <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[<span class="hljs-keyword">right</span>]) &#123;<br>      <span class="hljs-keyword">left</span> = mid + <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">right</span> = mid;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> nums[<span class="hljs-keyword">left</span>];<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a>69. x 的平方根</h2><p><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-69x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.png"><br>题解:</p><figure class="highlight vbscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vbscript">var mySqrt = <span class="hljs-keyword">function</span>(x) &#123;<br>  <span class="hljs-keyword">if</span> (x === <span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (x === <span class="hljs-number">1</span>) return <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> <span class="hljs-built_in">right</span> = Math.ceil(x/<span class="hljs-number">2</span>);<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-built_in">mid</span> = Math.ceil((<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">mid</span>**<span class="hljs-number">2</span> &gt; x) &#123;<br>      <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span>;<br>    &#125;<br>  &#125;<br>  return <span class="hljs-built_in">left</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层协议(TCP / UDP) &amp; TCP 握手机制</title>
    <link href="/2021/05/01/%E4%BC%A0%E8%BE%93%E5%B1%82-TCP%E4%B8%8EUDP/"/>
    <url>/2021/05/01/%E4%BC%A0%E8%BE%93%E5%B1%82-TCP%E4%B8%8EUDP/</url>
    
    <content type="html"><![CDATA[<p>参考文章: </p><ul><li><a href="https://zhuanlan.zhihu.com/p/147370653">太厉害了, 终于有人能把TCP/IP 协议讲的明明白白了</a></li><li><a href="https://zhuanlan.zhihu.com/p/84316213">计算机网络太难？了解这一篇就够了</a></li></ul><h1 id="TCP-amp-UDP"><a href="#TCP-amp-UDP" class="headerlink" title="TCP &amp; UDP"></a>TCP &amp; UDP</h1><p>TCP/IP 传输层中有两个代表性的协议: 1. <strong>TCP</strong>;  2. <strong>UDP</strong>; </p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP :面向无连接的数据报协议;<br>UDP 工作机制: 在接收到应用程序发来数据的那一刻, 就立即按照原样发送到网络上; (充当了一个不具备加工功能的中转站) </p><p>由于 UDP 不提供复杂的控制机制, 因此它也不具备 TCP 顺序控制, 重发控制等一系列操作; 这就导致 UDP 虽然可以确保发送消息的大小, 却不能保证消息一定会到达, 即使是出现网络拥堵的情况, UDP 也无法进行流量控制等避免网络拥塞的行为, 此外, 传输途中出现丢包, UDP 也不负责重发, 甚至当包的到达顺序出现乱序时也没有纠正的功能; 因此, 对于网络传输中的特殊情况, 需要应用进程自己实现对数据的处理; </p><h3 id="UDP-特点总结"><a href="#UDP-特点总结" class="headerlink" title="UDP 特点总结"></a>UDP 特点总结</h3><ol><li>UDP 是无连接的; </li><li>UDP 不保证可靠交付, 主机不需要维持复杂的链接状态; </li><li>UDP 是面向报文的; </li><li>UDP 没有拥塞控制, 因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用, 如直播, 实时视频会议等); </li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信(广播通信); </li><li>UDP 的首部开销小, 只有 8 个字节, 比 TCP 的 20 个字节的首部要短; </li></ol><h3 id="UDP-对应的应用层协议"><a href="#UDP-对应的应用层协议" class="headerlink" title="UDP 对应的应用层协议"></a>UDP 对应的应用层协议</h3><ol><li>DNS: 域名解析服务, 将域名地址转换为 IP 地址; 使用 53 号端口; </li><li>SNMP: 简单网络管理协议, 使用 161 号端口, 用于管理网络设备; 由于网络设备很多, 无连接的服务就体现出其优势; </li><li>TFTP(Trival File Transfer Protocal): 简单文件传输协议, 可在端口 69 上使用 UDP 服务; </li></ol><h3 id="UDP-应用场景"><a href="#UDP-应用场景" class="headerlink" title="UDP 应用场景"></a>UDP 应用场景</h3><ol><li><strong>包总量较少的通信</strong>(DNS、SNMP等)</li><li>视频、音频等<strong>多媒体通信(即时通信)</strong></li><li>限定于 LAN 等特定网络中的应用通信</li><li><strong>广播通信</strong>(广播、多播)</li></ol><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP :<strong>面向连接的流协议</strong>;<br>面向连接: 在数据通信开始前, 先建立两端的连接关系, 再进行数据传输;<br>流: 指不间断的数据结构;<br>当应用程序采用 TCP 发送消息时, 能将没有任何间隔的数据流按照一定的顺序发送给接收端;<br>TCP 控制机制: (一切控制机制的设计都是为了提供可靠性传输)</p><ol><li>顺序控制;</li><li>重发控制; </li><li>流控制(流量控制)</li><li>拥塞控制</li><li>窗口控制</li><li>… </li></ol><h3 id="TCP-协议是如何保证可靠传输的？"><a href="#TCP-协议是如何保证可靠传输的？" class="headerlink" title="TCP 协议是如何保证可靠传输的？"></a>TCP 协议是如何保证可靠传输的？</h3><ol><li>数据包校验: 检测数据在传输过程中的任何变化, 若校验出包有错, 则丢弃报文段并且不给出响应, TCP 发送端接收不到确认响应, 将会超时并重发数据; </li><li>对失序数据包重排序: 应用报文被分割成多个 TCP 报文段传输, TCP 报文段到达接收端可能会失序; TCP 对失序数据进行重新排序后再交给应用层; </li><li>丢弃重复数据: 通过序列号判断并丢弃重复数据; </li><li>应答机制: 当 TCP 收到发自 TCP 连接另一端的数据, 它将发送一个确认; 这个确认不是立即发送, 通常将推迟几分之一秒; </li><li>超时重发: 当 TCP 发出一个段后, 它启动一个定时器, 等待目的端确认收到这个报文段; 如果不能及时收到一个确认, 将重发这个报文段; </li><li>流量控制: TCP 连接的每一方都有固定大小的缓冲空间; TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据, 这可以防止较快主机致使较慢主机的缓冲区溢出; TCP 使用的流量控制协议是可变大小的滑动窗口协议; </li></ol><h3 id="TCP-特点总结"><a href="#TCP-特点总结" class="headerlink" title="TCP 特点总结"></a>TCP 特点总结</h3><ol><li>TCP 是面向连接的 (只有当两端都同意连接后才能传输数据);</li><li>每一条 TCP 连接只能有两个端点, 每一条 TCP 连接只能是点对点的（一对一）; </li><li>TCP 提供可靠交付的服务; 通过 TCP 连接传送的数据, 无差错、不丢失、不重复、并且按序到达; </li><li>TCP 提供全双工通信; TCP 允许通信双方的应用进程在任何时候都能发送数据; TCP 连接的两端都设有发送缓存和接收缓存(与滑动窗口有关), 用来临时存放双方通信的数据; </li><li>面向字节流; TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列; “面向字节流”的含义是: 虽然应用程序和 TCP 的交互是一次一个数据块（大小不等）, 但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流; </li></ol><h3 id="TCP-对应的应用层协议"><a href="#TCP-对应的应用层协议" class="headerlink" title="TCP 对应的应用层协议"></a>TCP 对应的应用层协议</h3><ol><li>FTP: 文件传输协议, 使用 21 端口; 下载文件, 上传主页, 都要用到 FTP 服务; </li><li>Telnet: 远程登陆协议, 用户可以以自己的身份远程连接到计算机上; </li><li>SMTP: 简单邮件传送协议, 现在很多邮件服务器都用的是这个协议, 用于发送邮件; 服务器开放的是 25 号端口; </li><li>POP3: 与 SMTP 对应, 用于接收邮件;  POP3 协议默认使用 110 端口; </li><li>HTTP: 超文本传输协议, 从 Web 服务器传输超文本到本地浏览器的传送协议; </li></ol><h2 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h2><p>与 UDP 不同, TCP 充分地实现了数据传输时各种控制功能, 可以进行丢包时的重发控制, 还可以对次序乱掉的分包进行顺序控制;<br>此外, TCP 作为一种面向连接的协议, 只有在确认通信对端存在时才会发送数据, 从而可以控制通信流量的浪费;<br>根据 TCP 的这些机制, 在 IP 这种无连接的网络上也能够实现高可靠性的通信 (主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现); </p><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ol><li>TCP 面向连接, 通信可靠, 其在传送数据之前必须先建立连接, 数据传送结束后要释放连接; UDP 面向无连接,在传送数据之前不需要先建立连接, 远地主机在收到 UDP 报文后, 不需要给出任何确认;</li><li>TCP 属于流协议, 传输的数据是连续不间断的; UDP 属于数据报协议, 传输数据是分割的;</li><li>TCP 具有一系列完备的控制机制, 能对传输的数据进行操作, 提高通信的可靠性, 但与此同时也增大了开销, 占用了 CPU 资源; UDP 没有复杂的控制机制, 因此对数据的处理需要由应用进程自己实现, 但其优势在于首部开销小, 常用于即时通信;</li></ol><p>TCP 和 UDP 的优缺点无法简单地, 绝对地去做比较: TCP 用于在传输层有必要实现可靠传输的情况; 而在一方面, UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信; TCP 和 UDP 应该根据应用的目的按需使用; </p><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>在数据链路层中, 定义了 MAC 地址, 用来识别同一链路中不同的计算机, 其中 MAC 地址是固定的, 其在厂商生产网卡时就已经写入并且每个网卡都有属于自己的 MAC 地址;<br>在网络层 IP 协议中, 定义了 IP 地址; 用来识别 TCP/IP 网络中互连的主机和路由器; IP 地址也是主机或路由器所唯一持有的, 但与 MAC 地址不同在于, IP 地址可人为选择并更改;<br>在传输层也有这种类似于地址的概念, 那就是端口号; 端口号用来识别同一台计算机中进行通信的不同应用程序; 因此, 它也被称为程序地址; </p><blockquote><p>个人理解: 应用程序 -&gt; 主机/路由器 -&gt; 网卡 (端口号 -&gt; IP 地址 -&gt; MAC 地址)</p></blockquote><p>尽管端口号可以识别一台计算机上不同的应用程序, 但是只凭端口号识别通信是远远不够的;<br><img src="/img/posts_img/%E9%80%9A%E4%BF%A1%E8%AF%86%E5%88%AB.png"><br>如上图所示: 一次通信可能由同一计算机不同端口号发出, 可能由不同 IP 地址的计算机发出, 甚至由不同的协议发出;<br>因此, 一次通信识别需要通过 IP 地址, 端口号, 协议号共同判断, 这些信息都包含在 IP 协议和 TCP 协议的首部;</p><h2 id="端口号分配"><a href="#端口号分配" class="headerlink" title="端口号分配"></a>端口号分配</h2><ol><li>静态分配: 人为给每个应用程序注册分配的端口号; 一些广泛使用的应用协议(例如 HTTP、FTP、TELNET 等)其端口号是被静态分配的, 即这些端口号已经被专门注册用于表示对应的应用协议, 我们称这些端口号为”知名端口号”, 分布在 0~1023 之间;</li><li>时序分配: 客户端应用程序不自己设置端口号, 而是全权交给操作系统进行分配;</li></ol><h1 id="TCP-三次握手与四次挥手"><a href="#TCP-三次握手与四次挥手" class="headerlink" title="TCP 三次握手与四次挥手"></a>TCP 三次握手与四次挥手</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="/img/posts_img/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"><br>概念: 客户端与服务端通过发送三个包来确认一次 TCP 连接的过程;</p><p>流程:<br>第一次握手: 客户端将标志位 SYN 置为1, 随机产生一个序列号 seq=J, 并将该数据包发送给服务器端, 客户端进入 SYN_SENT 状态, 等待服务器端确认;<br>第二次握手: 服务器端收到数据包后由标志位 SYN=1 知道客户端请求建立连接, 服务器端将标志位 SYN 和 ACK 都置为1, ack=J+1, 随机产生一个序列号 seq=K (后续会提及, 序列号的作用就是告知下一次传输报文段的起始位置, 避免接收重复数据), 并将该数据包发送给客户端以确认连接请求, 服务器端进入 SYN_RCVD 状态;<br>第三次握手: 客户端收到确认后, 检查 ack 是否为 J+1, ACK 是否为 1, 如果正确则将标志位 ACK 置为 1, ack=K+1, 并将该数据包发送给服务器端, 服务器端检查 ack 是否为 K+1, ACK 是否为 1, 如果正确则连接建立成功, 客户端和服务器端进入 ESTABLISHED 状态, 完成三次握手, 随后客户端与服务器端之间可以开始传输数据了; </p><h3 id="为什么不只进行两次握手"><a href="#为什么不只进行两次握手" class="headerlink" title="为什么不只进行两次握手?"></a>为什么不只进行两次握手?</h3><p>防止已经失效的连接请求报文段传送到接收端, 进而产生错误;<br>示例:<br>发送端 A 发出的第一个连接请求报文段并没有丢失, 而是在网路结点长时间滞留了, 以致于延误到连接释放以后的某个时间段才到达接收端 B;<br>本来这是一个早已失效的报文段; 但是 B 收到此失效的链接请求报文段后, 就误认为 A 又发出一次新的连接请求; 于是就向 A 发出确认报文段, 同意建立连接; </p><p>我们已知第二次 TCP 握手时, 接收端 B 一旦接收到报文段就会返回确认响应, 此时若不进行第三次握手, 发送端 A 接收到确认响应后就会建立连接, 此时接收端 B 会并一直等待发送端 A 通过建立的连接通道发来数据, 导致接收端 B 的许多资源白白浪费; 如果采用了三次握手, 由于 A 实际上并没有发出建立连接请求, 所以不会理睬 B 的确认, 也不会向 B 发送数据; B 由于收不到确认, 就知道 A 并没有要求建立连接; </p><h3 id="为什么不需要四次握手"><a href="#为什么不需要四次握手" class="headerlink" title="为什么不需要四次握手?"></a>为什么不需要四次握手?</h3><p>有人可能会说 A 发出第三次握手的信息后在没有接收到 B 的请求就已经进入了连接状态, 那如果 A 的这个确认包丢失或者滞留了怎么办？<br>我们需要明白一点, 完全可靠的通信协议是不存在的; 在经过三次握手之后, 客户端和服务端已经可以确认之前的通信状况, 都收到了确认信息; 所以即便再增加握手次数也不能保证后面的通信完全可靠, 所以是没有必要的;</p><blockquote><p>简单来说, 就是前两次交换连接信息时, 都已经确认双方是可以互相通信的, 后续再增加握手次数也是得到同样的结果(除非后续出了一些意外, 这是小概率事件, 因为我们无法保证通信完全可靠); </p></blockquote><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="/img/posts_img/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"><br>概念: 客户端与服务端通过发送四个包来终止本次 TCP 连接的过程;</p><p>为什么要进行四次挥手才确认本次 TCP 连接终止?<br>这是由于TCP连接是<strong>全双工</strong>的(即两端可同时传输数据), 因此, 每个方向都必须要单独进行关闭;<br>当一方完成数据发送任务后, 发送一个 FIN 来终止这一方向的连接, 但是该连接终止是单向的, 接收端收到一个 FIN 只是意味着这一方向上没有数据流动了, 即不会再收到数据了, 但是将接收端作为发送端仍可以在它的对向 TCP 连接上发送数据, 直到这一方向也发送了 FIN;</p><p>流程:<br>中断连接端可以是客户端, 也可以是服务器端;<br>第一次挥手: 客户端发送一个 FIN=M, 用来关闭客户端到服务器端的数据传送, 客户端进入 FIN_WAIT_1 状态; 意思是说”我客户端没有数据要发给你了”, 但是如果你服务器端还有数据没有发送完成, 则不必急着关闭连接, 可以继续发送数据;<br>第二次挥手: 服务器端收到 FIN 后, 先发送 ack=M+1, 告诉客户端, 你的请求我收到了, 但是我仍有数据没有发送完, 请继续等待; 这个时候客户端就进入 FIN_WAIT_2 状态, 继续等待服务器端的 FIN 报文;<br>第三次挥手: 当服务器端确定数据已发送完成, 则向客户端发送 FIN=N 报文, 告诉客户端我这边数据发完了, 准备好关闭连接了; 服务器端进入 LAST_ACK 状态;<br>第四次挥手: 客户端收到 FIN=N 报文后, 就知道可以关闭连接了, 但是他还是不相信网络, 怕服务器端不知道要关闭, 所以发送 ack=N+1 后进入TIME_WAIT状态, 如果 Server 端没有收到 ACK 则可以重传; 服务器端收到 ACK 后, 就知道可以断开连接了; 客户端等待了 <strong>2MSL</strong> 后依然没有收到回复, 则证明服务器端已正常关闭, 那好, 我客户端也可以关闭连接了; 最终完成了四次握手; </p><blockquote><p>上述流程一方主动关闭, 另一方被动关闭; 实际使用场景中也存在两方同时主动关闭;</p></blockquote><h3 id="为什么-TIME-WAIT-状态必须等待-2MSL-的时间呢？"><a href="#为什么-TIME-WAIT-状态必须等待-2MSL-的时间呢？" class="headerlink" title="为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？"></a>为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？</h3><ol><li>为了保证发送端 A 发送的最后一个 ACK 报文段能够到达接收端 B; 这个 ACK 报文段有可能丢失, 因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认; B 会超时重传这个 FIN+ACK 报文段, 而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段; 接着 A 重传一次确认, 重新启动 2MSL 计时器; 最后, A 和 B 都正常进入到 CLOSED 状态; 如果 A 在 TIME-WAIT 状态不等待一段时间, 而是在发送完 ACK 报文段后立即释放连接, 那么就无法收到 B 重传的 FIN + ACK 报文段, 因而也不会再发送一次确认报文段, 这样, B 就无法按照正常步骤进入 CLOSED 状态; <blockquote><p>简单来说, 若发送端在最后发送 ACK 告诉服务端可以执行关闭通道后, 立马断开发送端, 那么假设 ACK 并没有发送成功, 那么服务端就永远都关闭不上了;</p></blockquote></li><li>防止已失效的连接请求报文段出现在本连接中; A 在发送完最后一个 ACK 报文段后, 再经过时间 2MSL, 就可以使本连接持续的时间内所产生的所有报文段都从网络中消失; 这样就可以使下一个连接中不会出现这种旧的连接请求报文段; </li></ol><h3 id="为什么第二次跟第三次不能合并-第二次和第三次之间的等待是什么"><a href="#为什么第二次跟第三次不能合并-第二次和第三次之间的等待是什么" class="headerlink" title="为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?"></a>为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?</h3><p>当服务器执行第二次挥手之后, 此时就表明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据(可能是客户端上一次请求的资源还没有发送完毕), 所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求; </p><h1 id="TCP-控制机制"><a href="#TCP-控制机制" class="headerlink" title="TCP 控制机制"></a>TCP 控制机制</h1><h2 id="重发机制"><a href="#重发机制" class="headerlink" title="重发机制"></a>重发机制</h2><p>ACK 概念: 接收端成功接收到发送端传输数据后的一个响应信息;<br>重发机制作用: 有效防止了数据在传输过程中发生丢包导致传输失败的问题; 它主要通过 ACK 判断是否丢包, 并在丢包时重发数据, 保证数据能够到达对端, 从而实现可靠传输;</p><p>在 TCP 中, 当发送端的数据到达接收端时, 接收端主机会返回一个已收到消息的通知; 这个消息叫做确认应答（ACK）; 当发送端将数据发出之后会等待对端的确认应答; 如果有确认应答, 说明数据已经成功到达对端; 反之, 则数据丢失的可能性很大; 若发送端在一定时间内没有等待到确认应答, 就会被认定为数据已经丢失, 并进行重发; </p><p>重发机制主要是依靠 ACK 确认应答来判断是否丢包的, 而未收到 ACK 应答信息又主要分为两种情况:</p><ol><li>发送过程中数据丢失;</li><li>接收端数据已接收, 但ACK 确认应答在返回过程中丢失; 这种情况也会导致发送端误以为数据没有到达目的地而重发数据; </li><li>此外, 也有可能因为一些其他原因导致确认应答延迟到达, 在源主机重发数据以后才到达的情况; </li></ol><p>针对接收端收到数据但 ACK 返回失败的问题, TCP 的重发机制会重复发送数据段并被接收端接收, 为了避免目标主机反复收到相同的数据, TCP 引入了<strong>序列号</strong>, 让目标主机具备放弃重复数据段的能力;</p><h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h3><p><img src="/img/posts_img/TCP%E5%BA%8F%E5%88%97%E5%8F%B7.png"><br>序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号; 接收端查询接收数据 TCP 首部中的序列号和数据的长度, 将自己下一步应该接收的序列号作为确认应答返送回去; 通过序列号和确认应答号, TCP 能够识别是否已经接收数据, 又能够判断是否需要接收, 从而实现可靠传输; </p><h3 id="重发超时的判定"><a href="#重发超时的判定" class="headerlink" title="重发超时的判定"></a>重发超时的判定</h3><p>TCP 触发重发机制的依据是重发超时;<br>重发超时: 指在重发数据之前, 人为设定的给予等待 ACK 确认应答的时间阈值, 只要超出这个阈值仍没有接收到确认应答, 将会触发重发机制, 发送端将进行数据重发;<br>重发超时的理想阈值: TCP 在每次发包时都会计算往返时间及其偏差; 重发超时的阈值设定应当略大于”往返时间差 + 时间偏差”;<br>在 BSD 的 Unix 以及 Windows 系统中, 超时都以0.5秒为单位进行控制, 因此重发超时都是0.5秒的整数倍; 不过, 最初其重发超时的默认值一般设置为6秒左右;<br>数据被重发之后若还是收不到确认应答, 则进行再次发送; 此时, 等待确认应答的时间将会以2倍、4倍的指数函数延长; 此外, 数据也不会被无限、反复地重发, 达到一定重发次数之后, 如果仍没有任何确认应答返回, 就会判断为网络或对端主机发生了异常, 强制关闭连接; 并且通知应用通信异常强行终止; </p><h2 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h2><p>传输层的 TCP 协议数据单元为 “段”;<br>客户端与服务端在建立 TCP 连接时, 会确认所发送数据包的单位, 即<strong>最大消息长度(MSS)</strong>; 最理想的情况是, 最大消息长度正好是 IP 中不会被分片处理的最大数据长度;<br>TCP 在传送大量数据时, 是以 MSS 的大小将数据进行分割发送; 进行重发时也是以 MSS 为单位;<br><strong>MSS 在三次握手时, 在两端主机之间被计算得出</strong>; 两端的主机在发出建立连接的请求时, 会<strong>在 TCP 首部中写入 MSS 选项</strong>, 告诉对方自己的接口能够适应的 MSS 的大小; 然后会在两者之间<strong>选择一个较小的值</strong>投入使用; </p><h2 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h2><p><img src="/img/posts_img/TCP%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6.png"><br>TCP 以1个段为单位, 每发送一个段进行一次确认应答的处理; 这就意味着原本完整数据仅需一次传输, 现在需要分成多段逐个传输, 该传输方式就导致包的往返时间越长通信性能就越低;<br>为解决数据分段后往返次数增多导致通信性能降低的问题, TCP 引入了窗口这个概念: 确认应答不再是以每个分段, 而是以更大的单位进行确认; 即发送端发送一个报文段后不需要一直等待本次的确认应答, 而是继续发送; 窗口机制的提出实现了使用缓冲区思想, 通过对多个段同时进行确认应答的功能;<br>窗口大小: 指无需等待确认应答而可以继续发送数据的最大值; (上图窗口大小为 4)</p><h3 id="窗口内的重发机制"><a href="#窗口内的重发机制" class="headerlink" title="窗口内的重发机制"></a>窗口内的重发机制</h3><p>我们已知, 丢包出现的情况一般分为两种:</p><ol><li>接收数据但 ACK 确认应答未能返回; 在这种情况下, 数据已经到达对端, 不需要再进行重发; 因为窗口有统一收集确认应答再一次性发送的机制, 因此即使有少部分确认应答丢失也不会触发重发机制, 因为丢失的确认应答可以通过下一个确认应答进行确认;<br><img src="/img/posts_img/TCP%E7%AA%97%E5%8F%A3%E5%86%85%E9%87%8D%E5%8F%91%E6%9C%BA%E5%88%B61.png"></li><li>发送端传输的报文段数据丢失; 在窗口中, 某个报文段丢失会导致接收端收到一个自己应该接收的序列号以外的数据, 会返回到当前为止所收到数据的确认应答; 因此在窗口机制中出现报文段丢失时, 同一个序列号的确认应答将会被重复不断地返回, 而发送端主机如果连续 3 次收到同一个确认应答, 就会将其对应的数据进行重发; 这种机制比之前提到的超时管理更加高效, 因此也被称为高速重发控制;<br>![](/img/posts_img/TCP 窗口内重发机制2.png)</li></ol><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>作用: 控制发送方发送速率, 保证接收方来得及接收; 接收方发送的<strong>确认报文中的窗口字段</strong>可以用来<strong>控制发送方窗口大小</strong>, 从而<strong>影响发送方的发送速率</strong>; 将窗口字段设置为 0, 则发送方不能发送数据;<br>TCP 利用滑动窗口实现流量控制;</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口是一种流量控制技术;<br>解决的问题: 早期的网络通信中, 通信双方不会考虑网络的拥挤情况直接发送数据; 由于大家不知道网络拥塞状况, 同时发送数据, 导致中间节点阻塞掉包, 谁也发不了数据, 所以就有了滑动窗口机制来解决此问题; </p><p>滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据; 发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据; 当滑动窗口为 0 时, 发送方一般不能再发送数据报, 但有两种情况除外, 一种情况是可以发送紧急数据, 例如, 允许用户终止在远端机上的运行进程; 另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小; </p><p>此外, 滑动窗口还可以用来处理数据传输丢包的情况:<br><img src="/img/posts_img/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png"><br>设置一个滑动窗口包含当前正在发送的数据, 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据; 与此同时, 发送端会对当前滑动窗口内的数据进行缓存, 当数据发出后若如期收到确认应答, 则不再进行重发, 并将该条数据从发送端缓存中清除; 在收到确认应答的情况下, 将窗口滑动到确认应答中的序列号的位置, 顺序发送后续报文段;</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>拥塞: 某段时间内, 对网络中某一资源的需求超过了该资源所能提供的可用部分, 从而导致网络性能变差的现象;</p><blockquote><p>例如, 电脑遭受病毒攻击, 病毒在短时间内对网络中某一资源发起大量请求, 导致服务器端疲于处理该类请求而顾及不到其他正常的请求, 于是用户就会感觉到网络明显变慢;</p></blockquote><p>拥塞控制: 防止过多的数据注入到网络中, 使网络中的路由器或链路不致于过载; 拥塞控制具有全局性特点, 它需要掌控所有主机, 路由器以及与降低网络传输性能有关的所有因素, 从而估算出网络现阶段所能承受的网络负荷; 除此之外, TCP 发送端还需维护一个拥塞窗口 (cwnd) 的状态变量, 根据评估的网络拥塞程度, 动态调整拥塞窗口的大小, 最终取拥塞窗口和接收方的接受窗口中较小的一个作为发送端的发送窗口大小;</p><p>拥塞控制和流量控制不同, 前者是一个全局性的过程, 而后者指点对点通信量的控制;</p><h3 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h3><p>TCP 的拥塞控制采用了四种算法, 即：慢开始、拥塞避免、快重传和快恢复; 在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM）, 以减少网络拥塞的发生; </p><ol><li>慢开始<br>思路: 当主机最开始发送数据时, 由于现在还不知道网络的拥塞情况(第一次发送时还无法评估计算), 若此时立即把大量数据字节注入到网络, 很可能会引起网络阻塞; 因此在第一次发送数据时, 一般会先探测一下, 即由小到大逐渐增大发送窗口, 确保不会因为首轮发送数据过大导致拥塞 (cwnd 初始值为 1, 每经过一个传播轮次, cwnd 加倍); </li><li>拥塞避免<br>思路: 控制拥塞窗口大小缓慢增大, 即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1;</li><li>快重传和快恢复 (fast retransmit and recovery, FRR)<br>作用: 快速恢复丢失的数据包<br>没有 FRR, 如果数据包丢失了, TCP 将会使用定时器来要求传输暂停, 在暂停的这段时间内, 没有新的或复制的数据包被发送;<br>有了 FRR, 如果接收机接收到一个不按顺序的数据段, 它会立即给发送机发送一个重复确认; 如果发送机接收到三个重复确认, 它会假定确认件指出的数据段丢失了, 并立即重传这些丢失的数据段; <blockquote><p>具体实现参考”窗口内的重发机制”;</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP 协议分层管理</title>
    <link href="/2021/04/30/TCPIP%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86/"/>
    <url>/2021/04/30/TCPIP%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>参考文章: </p><ul><li><a href="https://zhuanlan.zhihu.com/p/84316213">计算机网络太难？了解这一篇就够了</a></li><li><a href="https://zhuanlan.zhihu.com/p/147370653">太厉害了，终于有人能把TCP/IP 协议讲的明明白白了</a></li></ul><h1 id="OSI-与-TCP-IP-诞生背景"><a href="#OSI-与-TCP-IP-诞生背景" class="headerlink" title="OSI 与 TCP/IP 诞生背景:"></a>OSI 与 TCP/IP 诞生背景:</h1><p>早期的网络协议没有统一标准化管理, 不同公司都推出属于自己的私有网络协议, 导致不同网络协议间不能相互兼容;<br>为<strong>解决网络通信协议兼容性</strong>问题, 国际标准化组织(<strong>ISO</strong>)制定了一个符合国际标准的<strong>通用网络通信协议族 – OSI协议族</strong>;</p><h2 id="OSI-开放系统互联"><a href="#OSI-开放系统互联" class="headerlink" title="OSI: 开放系统互联"></a>OSI: 开放系统互联</h2><p>OSI 又名”开放系统互联”, 是 ISO 国际标准化组织博览众家之长, 所制订出的包含了”一堆”详细的, 复杂的, 繁琐的, 精确的网络通信协议的集合;<br>如上所述, OSI 是许多网络通信协议的<strong>集合</strong>, 由于其包含的协议过于详细和复杂, 不同协议有着自己不同的功能;<br>因此, 为了方便管理和维护, OSI 协议族根据协议共有的一些特性被分为了 <strong>7 类(层)</strong>, 并规定<strong>不同层代表不同的功能, 同时制定(分配)相应的协议完成指定层的功能</strong>;</p><h2 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h2><p>OSI 国际标准提出后, 需要软件/硬件厂商去实现(OSI 协议族), 但是由于 OSI 协议族过于全面和完善, 实现成本太高, 实现过程复杂, 最终就导致鲜有厂商去按照 OSI 国际标准实现一套 OSI 协议族;<br>正所谓身处高位就容易忽略百姓疾苦, ISO 官方提出的标准过于全面和严格, 完全没有想到我们这些小公司根本没有人力财力去实现一套完备的 OSI; 好在民间不乏有高手存在, 他们实现了另一套通用网络通信协议族 – TCP/IP 协议族; 其同样能完成网络通信, 但实现的难度与 OSI 相比就可小太多了;<br>于是乎, 在长年竞争后, TCP/IP 协议族就完全统治了江山, 现在的因特网就是建立在 TCP/IP 协议族基础之上的;<br>早期的TCP/IP是自由发展, 后期有了属于自己的标准化组织, 叫做 <strong>IETF</strong>, 该组织所写的文档叫做 <strong>RFC</strong>;</p><h2 id="TCP-IP-与-OSI-的关系"><a href="#TCP-IP-与-OSI-的关系" class="headerlink" title="TCP/IP 与 OSI 的关系"></a>TCP/IP 与 OSI 的关系</h2><p>尽管 OSI 协议族内所涵盖的一大堆协议没人去实现和使用了, 不过 ISO 给网络协议做的 7 个分类仍具有科学性和参考价值; 因为 ISO 自己的协议已经不占统治地位了, 只剩网络协议的分类模型硕果仅存, 于是这 7 个分类的地位<strong>由“国际标准”降格为“仅供参考”</strong>, 因此, 现在我们提到 OSI 时通常将其称为<strong>开放系统互联参考模型(OSI 参考模型)</strong>; 而 TCP/IP 协议族正是参考了 OSI 的分层思想而实现的;</p><p>为什么不抛弃 OSI 的七层网络模型, 直接使用 TCP/IP 的四层网络模型呢?</p><ol><li>OSI 是 ISO (国际标准化组织) 制定的国际标准, 是 TCP/IP 协议族分层思想的参考基础(分类更加细致完善);</li><li>OSI 不仅仅针对因特网, 而且网络类型也不只是因特网;</li></ol><blockquote><p>个人理解: OSI 为制定通用网络协议提供了理论基础, 而 TCP/IP 则更像是 OSI 的”工业化产物”, 其更符合业界的使用场景; 因此, 我们在学习网络知识的时候, 一般都参照 OSI 模型进行学习, 但在实际使用时, 实际都是使用TCP/IP 协议族; 现阶段 OSI 参考模型的的每一层, 仅仅说明功能, 而不特指某种协议(ISO 自己指定的协议已经没人用了), 因特网的 4 层模型才具体说明协议;</p></blockquote><h1 id="TCP-IP-分层管理的必要性-优点"><a href="#TCP-IP-分层管理的必要性-优点" class="headerlink" title="TCP/IP 分层管理的必要性(优点):"></a>TCP/IP 分层管理的必要性(优点):</h1><ol><li>把协议集合内不同协议间的复杂功能抽象成不同的层, 使得理解和实现都更加简单;</li><li>方便改动, 只需规划各层的对外接口, 其内部可自由改动;</li><li>分层后各层的职能划分更加清晰, 方便管理;</li></ol><h1 id="网络模型层级结构"><a href="#网络模型层级结构" class="headerlink" title="网络模型层级结构"></a>网络模型层级结构</h1><p><img src="/img/posts_img/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.png"></p><p>学习计算机网络时我们一般采用折中的办法, 中和 OSI(功能详细) 和 TCP/IP(实现简洁) 的优点, 采用一种只有五层协议的体系结构, 这样既简洁又能将概念阐述清楚;</p><h2 id="各层介绍"><a href="#各层介绍" class="headerlink" title="各层介绍"></a>各层介绍</h2><ol><li>应用层</li></ol><ul><li>功能: (<strong>同一主机内</strong>)通过<strong>应用进程</strong>间的交互来完成特定网络应用;</li><li>协议: 应用层协议 – 应用进程(<em>进程: 主机正在运行的程序</em>)间的<strong>通信和交互的规则</strong>; 应用层协议包括<strong>域名系统 DNS / 支持万维网应用的 HTTP 协议 / 支持电子邮件的 SMTP 协议</strong>等, 不同的网络应用需要不同的应用层协议;</li><li>数据单元: 报文;</li></ul><ol start="2"><li>传输层</li></ol><ul><li>功能: 负责为<strong>两台主机进程</strong>之间的通信提供<strong>通用的数据传输服务(传送应用层报文)</strong>; 由于一台主机可同时运行多个进程，因此传输层有<strong>复用</strong>和<strong>分用</strong>的功能; 复用: 指多个应用层进程可同时使用下面运输层的服务; 分用: 指传输层把收到的信息分别交付上面应用层中的相应进程(复用的逆过程);</li><li>协议: TCP 协议, UDP 协议;</li><li>数据单元: TCP 协议对应 <strong>TCP 报文段</strong>; UDP 协议对应<strong>用户数据包</strong>;</li></ul><ol start="3"><li>网络层</li></ol><ul><li>功能: 在计算机网络中进行通信的两个计算机之间可能会经过多个数据链路, 通信子网等所谓的”中转站”, 网络层就是负责<strong>选择合适的网间路由和交换结点(确定数据包的传输路线), 确保数据及时传送</strong>;</li><li>协议: IP 协议;</li><li>数据单元: 网络层在发送数据时, 会把传输层产生的报文段或用户数据包封装成分组和包的形式进行传送(分成小块发送, 接收时合并), 因此最小的数据单元为<strong>数据包</strong>;</li></ul><ol start="4"><li>数据链路层</li></ol><ul><li>功能: 两台主机间的数据传输发生在链路节点上, 数据链路层则是在<strong>两个相邻节点间</strong>传送数据时, 将网络层派发的 IP 数据包组装成<strong>帧</strong>进行传送; 每一帧包括数据和必要的控制信息 (帧内包括: 同步信息, 地址信息, 差错控制等); 数据链路层在接收数据时, 可通过接收帧的控制信息判断帧开始和结束的位置, 并从中提出数据部分继续传递给网络层; 控制信息还使接收端能够检测到所收到的帧中有无差错(复杂的协议还能实现纠错功能), 如果发现差错, 则能在数据链路层就丢弃存在差错的帧, 以避免继续在网络中传送从而浪费网络资源; </li><li>协议: ARP 协议; RARP 协议; 等…</li><li>数据单元: 帧; </li></ul><ol start="5"><li>物理层</li></ol><ul><li>功能: 实现<strong>相邻计算机节点</strong>之间比特流的<strong>透明传送(屏蔽传输介质和物理设备的差异, 使得经实际电路传送后的比特流不发生变化)</strong>;</li><li>数据单元: 比特;</li></ul><h2 id="各层对应的网络协议"><a href="#各层对应的网络协议" class="headerlink" title="各层对应的网络协议"></a>各层对应的网络协议</h2><p><img src="/img/posts_img/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%B1%82%E7%BA%A7%E5%AF%B9%E5%BA%94%E5%8D%8F%E8%AE%AE.png"></p><h1 id="TCP-IP-通信传输流过程"><a href="#TCP-IP-通信传输流过程" class="headerlink" title="TCP/IP 通信传输流过程"></a>TCP/IP 通信传输流过程</h1><h2 id="数据包组成"><a href="#数据包组成" class="headerlink" title="数据包组成"></a>数据包组成</h2><p>网络中传输的数据包由两部分组成: </p><ol><li>该层协议所用到的首部; (首部的结构由协议的具体规范详细定义, 数据包的首部包含了协议相关信息, 如协议内容, 发送目标地址等)</li><li>上一层传过来的数据;</li></ol><p><img src="/img/posts_img/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%B1%82%E9%97%B4%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E9%80%92%E5%9B%BE%E8%A7%A3.png"></p><p>数据包从应用层往下走时, 要不断经历封装的过程, 而从链路层往上走时, 则不断经历解封的过程;<br>在相邻层之间数据传递过程中, 都会对所发送的数据附加一个首部, 在这个首部中包含了该层必要的信息, 如发送的目标地址以及协议相关信息;<br>通常, 为协议提供的信息为包首部, 所要发送的内容为数据; 在下一层的角度看, 从上一层收到的包全部都被认为是本层的数据;</p><h2 id="TCP-IP-数据传输过程"><a href="#TCP-IP-数据传输过程" class="headerlink" title="TCP/IP 数据传输过程"></a>TCP/IP 数据传输过程</h2><p><img src="/img/posts_img/TCPIP%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png"></p><ol><li>应用程序处理<br>首先应用程序会进行编码处理(相当于 OSI 表示层); 编码转化后, 邮件不会立即被发送, 会等待建立通信连接,(相当于 OSI 会话层);</li><li>TCP 模块的处理<br>TCP 根据应用的指示, 负责<strong>建立连接、发送数据以及断开连接</strong>; TCP 提供将应用层发来的数据顺利发送至对端的可靠传输; 为了实现这一功能, 需要<strong>在应用层数据的前端附加一个 TCP 首部</strong>;</li><li>IP 模块的处理<br>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据, 并<strong>在 TCP 首部的前端加上自己的 IP 首部</strong>; IP 包生成后, 选择合适的网间路由和交换节点传送 IP 数据包;</li><li>网络接口(以太网驱动)的处理 (数据链路层 + 物理层)<br>接收 IP 传过来的 IP 包并附加上以太网首部, 从而生成以太网数据包, 通过物理层传输给接收端;</li><li>网络接口(以太网驱动)的处理 (数据链路层 + 物理层)<br>主机收到以太网数据包后, 首先<strong>从以太网包首部找到 MAC 地址</strong>判断是否为发送给自己的包, 若不是则丢弃数据;<br>如果是发送给自己的包, 则从以太网包首部中的类型确定数据类型, 再传给相应的模块, 如 IP、ARP 等;</li><li>IP 模块的处理<br>IP 模块接收到数据后, <strong>从包首部中判断此 IP 地址是否与自己的 IP 地址匹配</strong>, 如果匹配则根据首部的协议类型将数据(去除协议首部后的数据包 / 解封的过程)发送给对应的模块, 如 TCP、UDP; 对于有路由器的情况, 接收端地址往往不是自己的地址, 此时要借助路由控制表获取应该送往的主机或路由器之后再进行转发数据;</li><li>TCP 模块的处理<br>在 TCP 模块中, 首先会<strong>计算一下校验和</strong>, 判断数据是否被破坏, 然后<strong>检查是否在按照序号接收数据</strong>, 根据序号顺序重组数据, 最后检查端口号, 确定具体的应用程序; 数据被完整地接收以后, 会传给由端口号识别的应用程序;</li><li>应用程序的处理<br>接收端应用程序会直接接收发送端发送的数据, 通过解析数据, 展示相应的内容;</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP 协议基础</title>
    <link href="/2021/04/30/TCPIP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/04/30/TCPIP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>参考文章: <a href="https://zhuanlan.zhihu.com/p/147370653">太厉害了，终于有人能把TCP/IP 协议讲的明明白白了</a></p><h1 id="TCP-IP-协议的具体含义"><a href="#TCP-IP-协议的具体含义" class="headerlink" title="TCP/IP 协议的具体含义"></a>TCP/IP 协议的具体含义</h1><h2 id="什么是”协议”"><a href="#什么是”协议”" class="headerlink" title="什么是”协议”?"></a>什么是”协议”?</h2><p>计算机与网络设备间相互通信所遵循的规则;</p><h2 id="什么是-TCP-IP-协议"><a href="#什么是-TCP-IP-协议" class="headerlink" title="什么是 TCP/IP 协议?"></a>什么是 TCP/IP 协议?</h2><p>两种说法:</p><ol><li>与互联网相关联的协议集合的统称;</li><li>在利用 IP 进行通信的过程中所用到的协议族统称;</li></ol><h1 id="数据单位"><a href="#数据单位" class="headerlink" title="数据单位"></a>数据单位</h1><p>TCP/IP 协议中共有 5 种术语来表述数据的单位: </p><ol><li>包: 全能性术语, 表达数据的最基本单位, 其余术语大多是基于此的延伸;</li><li>帧: <strong>数据链路层</strong>中包的单位;</li><li>数据包: IP 和 UDP 等网络层以上的分层中包的单位;</li><li>段: TCP 数据流中的信息;</li><li>消息: 应用协议中数据的单位;</li></ol><h1 id="TCP-IP-协议分层管理"><a href="#TCP-IP-协议分层管理" class="headerlink" title="TCP/IP 协议分层管理"></a>TCP/IP 协议分层管理</h1><p><a href="https://wangjintian.com/2021/04/30/TCPIP%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86/">TCP/IP 协议分层管理</a><br>内容概述:</p><ol><li>OSI 与 TCP/IP 的诞生背景;</li><li>TCP/IP 模型结构及各层介绍;</li><li>TCP/IP 数据传输流程;</li></ol><h1 id="传输层-—-TCP-与-UDP"><a href="#传输层-—-TCP-与-UDP" class="headerlink" title="传输层 — TCP 与 UDP"></a>传输层 — TCP 与 UDP</h1><p><a href="https://wangjintian.com/2021/05/01/%E4%BC%A0%E8%BE%93%E5%B1%82-TCP%E4%B8%8EUDP/">传输层协议(TCP / UDP) &amp; TCP 握手机制</a><br>内容概述:</p><ol><li>TCP &amp; UDP 概念 / 区别;</li><li>TCP 三次握手和四次挥手;</li><li>TCP 控制机制(包括重发机制, 流量控制等);</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6篇 - Module 的加载实现</title>
    <link href="/2021/04/20/ES6%E7%AF%87-Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/20/ES6%E7%AF%87-Module%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>请结合 <a href="https://es6.ruanyifeng.com/#docs/module-loader">Module 的加载实现</a> 一起阅读本文;</p><h1 id="浏览器加载"><a href="#浏览器加载" class="headerlink" title="浏览器加载"></a>浏览器加载</h1><h2 id="浏览器加载-JS-脚本"><a href="#浏览器加载-JS-脚本" class="headerlink" title="浏览器加载 JS 脚本"></a>浏览器加载 JS 脚本</h2><p>浏览器通过 <code>&lt;script type=&quot;application/javascript&quot;&gt;&lt;/script&gt;</code> 标签加载脚本, 由于浏览器脚本的默认语言是 JavaScript, 因此 <code>type=&quot;application/javascript&quot;</code> 可以省略;</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 页面内嵌的脚本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-comment">// module code</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 外部脚本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;path/to/myModule.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 省略 type --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;path/to/myModule.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>默认情况下, 浏览器同步加载脚本;<br>缺点: 容易造成浏览器阻塞, 在脚本执行完成前浏览器整体处于无法响应状态;</p><p>浏览器异步加载脚本的两种方案:<br><code>&lt;script&gt;</code> 标签打开 <strong>defer</strong> 或 <strong>async</strong> 属性, 脚本就会异步加载;</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;path/to/myModule.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;path/to/myModule.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>defer 和 async 区别:</p><ol><li>执行时刻不同: defer 要等到整个页面在内存中正常渲染结束(DOM 结构完全生成，以及其他脚本执行完成), 才会执行; async一旦下载完, 渲染引擎就会中断渲染, 执行这个脚本以后, 再继续渲染; 一句话, defer是“渲染完再执行”, async是“下载完就执行”;</li><li>脚本加载顺序不同: 如果有多个 defer 脚本, 会按照它们在页面出现的顺序加载; 多个 async 脚本是不能保证加载顺序的;</li></ol><h2 id="浏览器加载-ES6-模块"><a href="#浏览器加载-ES6-模块" class="headerlink" title="浏览器加载 ES6 模块"></a>浏览器加载 ES6 模块</h2><p>通过 <code>&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</code> 标签加载模块;<br>浏览器对于带有 <code>type=&quot;module&quot;</code> 的 <code>&lt;script&gt;</code>, 都是异步加载; 即<strong>等到整个页面渲染完, 再执行模块脚本</strong>, 等同于打开了 <code>&lt;script&gt;</code> 标签的 defer 属性; 如果网页有多个 <code>&lt;script type=&quot;module&quot;&gt;</code>, 模块将按照在页面出现的顺序依次执行;</p><blockquote><p>浏览器异步加载 ES6 模块时等价于默认开启 defer 属性, 开发者也可显式开启 async 属性加载模块, 其会覆盖 defer 属性, 在模块加载完成时就中断渲染立即执行, 执行完成后再恢复渲染, 且模块加载时不再保证执行顺序;</p></blockquote><h1 id="Node-js-模块加载"><a href="#Node-js-模块加载" class="headerlink" title="Node.js 模块加载"></a>Node.js 模块加载</h1><p>JavaScript 现在有两种模块: 一种是 ES6 模块, 简称 ESM; 另一种是 CommonJS 模块, 简称 CJS;<br>CommonJS 模块是 Node.js 专用的, 与 ES6 模块不兼容; 它们采用不同的加载方案, 从 Node.js v13.2 版本开始, Node.js 已经默认打开了 ES6 模块支持;</p><p>Node.js 碰到 <code>.mjs</code> 文件总是以 ES6 模块加载，<code>.cjs</code> 文件总是以 CommonJS 模块加载，<code>.js</code> 文件的加载取决于 <code>package.json</code> 里面 type 字段的设置;</p><blockquote><p>type 字段配置 “module” 则已 ES6 模块加载 <code>.js</code> 文件; 若不显式配置或将 type 字段配置 “commonjs”, 则已 CommonJS 模块加载 <code>.js</code> 文件;<br>ES6 模块与 CommonJS 模块尽量不要混用(可以相互实现加载, 但尽量避免), 不能<strong>直接</strong>用 import 命令加载 <code>.cjs</code> 文件, 会报错, 只有 require 命令才可以加载 <code>.cjs</code> 文件; 反过来, <code>.mjs</code> 文件里面也不能<strong>直接</strong>使用 require 命令, 必须使用 import;</p></blockquote><h2 id="package-json-模块加载入口配置"><a href="#package-json-模块加载入口配置" class="headerlink" title="package.json 模块加载入口配置"></a>package.json 模块加载入口配置</h2><p><code>package.json</code> 文件有两个字段可以指定模块的入口文件: main 和 exports;</p><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;module&quot;</span>,<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;./src/index.js&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">import &#123; something &#125; from <span class="hljs-string">&quot;es&quot;</span>;<br><span class="hljs-regexp">//</span> 实际加载: .<span class="hljs-regexp">/node_modules/</span>es<span class="hljs-regexp">/src/i</span>ndex.js<br></code></pre></div></td></tr></table></figure><p>配置 main 字段后, 加载模块时, Node.js 就会选择相应的方式(此处为 ES6 模块)到 <code>./node_modules</code> 目录下面, 寻找指定模块, 然后根据该模块 <code>package.json</code> 的 <code>main</code> 字段去执行入口文件;</p><h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><p>main 字段一般用于简单的模块加载配置;<br>exports 字段的优先级高于 main 字段, 相较于 main 配置项更加细致复杂;<br><strong>1)</strong> <code>package.json</code> 文件的 exports 字段可以指定<strong>脚本或子目录的别名</strong>;<br>脚本别名:</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">&#123;<br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;module&quot;</span>,<br>  <span class="hljs-string">&quot;exports&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;./submodule&quot;</span>: <span class="hljs-string">&quot;./src/submodule.js&quot;</span><br>  &#125;<br>&#125;<br><br>import submodule from <span class="hljs-string">&quot;es/submodule&quot;</span>;<br><span class="hljs-regexp">//</span> 实际加载 .<span class="hljs-regexp">/node_modules/</span>es<span class="hljs-regexp">/src/</span>submodule.js;<br></code></pre></div></td></tr></table></figure><p>子目录别名:</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">&#123;<br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;module&quot;</span>,<br>  <span class="hljs-string">&quot;exports&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;./features/&quot;</span>: <span class="hljs-string">&quot;./src/features/&quot;</span><br>  &#125;<br>&#125;<br><br>import submodule from <span class="hljs-string">&quot;es/features/index.js&quot;</span>;<br><span class="hljs-regexp">//</span> 实际加载 .<span class="hljs-regexp">/node_modules/</span>es<span class="hljs-regexp">/src/</span>features/index.js;<br></code></pre></div></td></tr></table></figure><p><strong>2)</strong> exports 主入口别名<br>exports 字段的别名如果是 <code>.</code>, 就代表模块的主入口, 优先级高于 main 字段, 并且可以直接简写成 exports 字段的值;</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;exports&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;.&quot;</span>: <span class="hljs-string">&quot;./main.js&quot;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 简写</span><br>&#123;<br>  <span class="hljs-attr">&quot;exports&quot;</span>: <span class="hljs-string">&quot;./main.js&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h1><blockquote><p>CommonJS: <code>module.exports = &#123;...&#125;</code>, <code>exports.xxx = yyy</code>; 可以认为 CommonJS 先创建了一个 exports 空对象, 挂载属性和方法的拷贝, 向外抛出该 exports 对象;<br>ES6: <code>export 接口</code>, <code>export default 值</code>; export 抛出对外接口, export default 将值赋予 default 后抛出 default 接口;</p></blockquote><ol><li>CommonJS 模块输出<strong>值的拷贝</strong>, ES6 模块输出<strong>值的引用</strong>;</li><li>CommonJS 模块是<strong>运行时加载</strong>, ES6 模块是<strong>编译时输出接口</strong>;</li><li>CommonJS 模块的 <code>require()</code> 是<strong>同步加载模块</strong>, ES6 模块的 import 命令是<strong>异步加载</strong>, 有一个独立的模块依赖的解析阶段;</li></ol><h2 id="差异一"><a href="#差异一" class="headerlink" title="差异一"></a>差异一</h2><p>CommonJS 输出值的拷贝, 模块一旦输出该值, 后续模块内的变化就不会影响到这个输出的值;<br>ES6 模块的运行机制与 CommonJS 不同: JS 引擎<strong>对脚本静态分析</strong>的时候, 遇到模块加载命令 <strong>import</strong>, 就会<strong>生成一个只读引用</strong>。等到脚本<strong>真正执行时</strong>，再根据这个只读引用，到被加载的那个模块里面去<strong>取值</strong>; 每次读取引用时, 都会去相应的输出模块内取值, 因此 ES6 模块是动态引用, 并且不会缓存值, 模块里面的变量绑定其所在的模块;</p><blockquote><p>由于 ES6 输出的是引用, 真实值始终定义在输出模块内, 因此不同脚本读取 export 的对外接口, JS 引擎总会去输出模块内取值, export 输出的实际上是同一个值;</p></blockquote><h2 id="差异二"><a href="#差异二" class="headerlink" title="差异二"></a>差异二</h2><p>产生差异二的主要原因: CommonJS 加载的是一个<strong>对象</strong>(即 module.exports 属性), 该对象只有在<strong>脚本运行</strong>完才会生成; 而 ES6 模块不是对象，它的对外接口只是一种<strong>静态定义</strong>，在代码<strong>静态解析阶段</strong>就会生成;</p><h1 id="CommonJS-模块加载原理"><a href="#CommonJS-模块加载原理" class="headerlink" title="CommonJS 模块加载原理"></a>CommonJS 模块加载原理</h1><p>CommonJS 的一个模块, 就是一个脚本文件; <strong>require 命令第一次加载脚本, 就会执行整个脚本, 然后在内存生成一个对象</strong>:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> Node 内部加载模块后生成的一个对象: 包含 id <span class="hljs-params">(模块名)</span>; exports <span class="hljs-params">(模块输出对象)</span>; loaded <span class="hljs-params">(boolean | 表示模块脚本是否执行完毕)</span>; <span class="hljs-string">...</span><br>&#123;<br>  id: &#x27;<span class="hljs-string">...</span>&#x27;,<br>  exports: &#123; <span class="hljs-string">...</span> &#125;,<br>  loaded: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>以后需要用到这个模块的时候, 就会<strong>到 exports 属性上取值</strong>; 即使再次执行 require 命令, 也不会再次执行该模块, 而是到缓存之中取值;<br>CommonJS 模块无论加载多少次, 都只会在第一次加载时运行一次, 以后再加载, 就返回第一次运行的结果, 除非手动清除系统缓存;</p><h1 id="CommonJS-处理循环加载"><a href="#CommonJS-处理循环加载" class="headerlink" title="CommonJS 处理循环加载"></a>CommonJS 处理循环加载</h1><p>CommonJS 模块的重要特性是加载时执行, 结合 CommonJS 的加载原理可知, 脚本代码在 require 的时候, 就会<strong>全部</strong>执行, 一旦出现某个模块被”循环加载”, 就只输出已经执行的部分, 还未执行的部分不会输出;<br><code>a.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">exports</span>.done = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.done); <span class="hljs-comment">// 8 输出 true</span><br><span class="hljs-built_in">exports</span>.done = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 9</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a.js 执行完毕&#x27;</span>); <span class="hljs-comment">// 10</span><br></code></pre></div></td></tr></table></figure><p><code>b.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">exports</span>.done = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>); <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.done); <span class="hljs-comment">// 5 输出 false</span><br><span class="hljs-built_in">exports</span>.done = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 6</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b.js 执行完毕&#x27;</span>); <span class="hljs-comment">// 7</span><br></code></pre></div></td></tr></table></figure><p><code>main.js</code></p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">let a</span> = require(<span class="hljs-string">&#x27;./a.js&#x27;</span>);<br><span class="hljs-attribute">let b</span> = require(<span class="hljs-string">&#x27;./b.js&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>执行 <code>main.js</code>, 首先整体加载 <code>a.js</code> 脚本; <code>a.js</code> 脚本运行过程中, 碰到 <code>require(&#39;./b.js&#39;)</code> 时, 会去整体加载 <code>b.js</code> 脚本, (此时 a 模块中生成的对象{id:…, exports:{…}, loaded: false}中, exports 属性只有 <code>exports.done = false</code>), 因此执行 <code>b.js</code> 脚本时, 循环加载 a 模块, 会从已生成的对象中取值, 该值就是 a 模块在暂停执行前已执行的部分; 随后将 b 模块执行完毕, 执行权交还给 a 模块(此时 a 模块生成对象的 loaded 为 false), 确保 a 模块执行完毕;</p><blockquote><p>循环加载很好体现了 CommonJS 模块的加载机制: 同步执行; 模块生成对象; 完全执行;</p></blockquote><h1 id="ES6-模块加载原理"><a href="#ES6-模块加载原理" class="headerlink" title="ES6 模块加载原理"></a>ES6 模块加载原理</h1><p>JS 引擎<strong>对脚本静态分析</strong>的时候, 遇到模块加载命令 <strong>import</strong>, 就会<strong>生成一个只读引用</strong>。等到脚本<strong>真正执行时</strong>，再根据这个只读引用，到被加载的那个模块里面去<strong>取值</strong>; 每次读取引用时, 都会去相应的输出模块内取值, 因此 ES6 模块是动态引用, 并且不会缓存值, 模块里面的变量绑定其所在的模块;<br><code>a.mjs</code></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a.mjs&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(bar);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p><code>b.mjs</code></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b.mjs&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(foo);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> bar = <span class="hljs-string">&#x27;bar&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p>执行 <code>a.mjs</code> , 引擎发现它加载了 <code>b.mjs</code>, 因此会优先执行 <code>b.mjs</code>, 然后再执行 <code>a.mjs</code>; 接着, 执行b.mjs的时候, 从 <code>a.mjs</code> 输入了 foo 接口, 这时不会去执行 <code>a.mjs</code>, 而是认为这个接口已经存在了(即生成了一个只读引用), 继续往下执行; 执行到第三行 <code>console.log(foo)</code> 的时候, 才发现这个接口根本没定义(脚本真正执行遇到该只读引用时才会去取值), 因此报错;</p><blockquote><p>个人理解: ES6 模块在编译阶段就已经完成, 其在静态分析脚本时, 生成了 bar 和 foo 两个接口的只读引用; 当脚本真正运行到 foo 引用时, 才回去取值, 发现此时接口对应的模块值并没有生成, 因此报错;</p></blockquote><p>稍微修改一下:<br><code>a.mjs</code></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a.mjs&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(bar());<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span> &#125;<br><span class="hljs-keyword">export</span> &#123;foo&#125;;<br></code></pre></div></td></tr></table></figure><p><code>b.mjs</code></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b.mjs&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(foo());<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;bar&#x27;</span> &#125;<br><span class="hljs-keyword">export</span> &#123;bar&#125;;<br></code></pre></div></td></tr></table></figure><p>将 foo 声明成一个变量, 而非 let 声明的变量, 脚本便可正常运行; 这是因为在执行阶段, 创建变量时, 函数声明会被提升至顶部, 因此在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错;</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6篇 - Module 语法</title>
    <link href="/2021/04/20/ES6%E7%AF%87-Module%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/04/20/ES6%E7%AF%87-Module%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>请结合 <a href="https://es6.ruanyifeng.com/#docs/module">Module 的语法</a> 一起阅读本文;</p><h1 id="Module-概述"><a href="#Module-概述" class="headerlink" title="Module 概述"></a>Module 概述</h1><p>在 ES6 之前, 最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器;<br><strong>ES6 的模块功能</strong>实现, 取代了 CommonJS 和 AMD 规范, 是<strong>浏览器和服务器通用</strong>的模块解决方案;<br>ES6 模块的设计思想: <strong>静态化</strong>; 即在编译阶段就确定模块间的依赖关系, 以及输入和输出的变量;</p><h2 id="CommonJS-运行时加载"><a href="#CommonJS-运行时加载" class="headerlink" title="CommonJS 运行时加载"></a>CommonJS 运行时加载</h2><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// CommonJS模块</span><br><span class="hljs-keyword">let</span> &#123; stat, exists, readfile &#125; = require(&#x27;fs&#x27;);<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> _fs = require(&#x27;fs&#x27;); <span class="hljs-comment">// 加载模块所有方法并生成一个对象</span><br><span class="hljs-keyword">let</span> stat = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_fs</span>.</span></span>stat; <span class="hljs-comment">// 从生成对象中取出方法</span><br><span class="hljs-keyword">let</span> exists = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_fs</span>.</span></span>exists;<br><span class="hljs-keyword">let</span> readfile = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_fs</span>.</span></span>readfile;<br></code></pre></div></td></tr></table></figure><p>本质: 整体加载模块(加载模块的所有方法), 生成一个对象, 然后从该对象上获取属性和方法;<br>缺点: 只能在运行时执行该语句才能得到模块对象, 无法在编译阶段做到”静态优化”;</p><h2 id="ES6-模块静态加载"><a href="#ES6-模块静态加载" class="headerlink" title="ES6 模块静态加载"></a>ES6 模块静态加载</h2><p>本质: 由一个模块输出模块接口, 另一模块接收该接口<br>优点: 在编译阶段就完成模块加载, 效率比 CommonJS 高; 基于编译时加载的特点, 可以进行类型检测等静态分析的功能;<br>缺点: 无法引用 ES6 模块本身</p><h1 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h1><h2 id="export-关键字"><a href="#export-关键字" class="headerlink" title="export 关键字"></a>export 关键字</h2><p>模块是独立的文件, 模块内部的所有变量, 外部无法获取; export 关键字为外部读取模块内部的变量提供了方法;<br>作用: 用于规定模块的<strong>对外接口</strong>;<br>书写位置: 可出现在<strong>模块顶层的任意位置</strong>, 如果出现在块级作用域内则会报错, 因为在块级作用域内无法实现静态优化(块级作用域需要程序运行时访问);</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  写法一: 逐个抛出对外接口(变量/函数/类...)</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> firstName = <span class="hljs-string">&#x27;Siri&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> secondName = <span class="hljs-string">&#x27;John&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> call = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;&#125;;<br><br><span class="hljs-comment">// ==========================</span><br><br><span class="hljs-comment">// 写法二: 用 &#123;&#125; 包裹一组(变量/函数名/类名)抛出</span><br><span class="hljs-keyword">let</span> firstName = <span class="hljs-string">&#x27;Siri&#x27;</span>;<br><span class="hljs-keyword">let</span> secondName = <span class="hljs-string">&#x27;John&#x27;</span>;<br><span class="hljs-keyword">export</span> &#123;firstName, secondName&#125;;<br><br><span class="hljs-comment">// ==========================</span><br><br><span class="hljs-comment">// 错误示例:</span><br><span class="hljs-keyword">let</span> firstName = <span class="hljs-string">&#x27;Siri&#x27;</span>;<br><span class="hljs-keyword">export</span> firstName; <span class="hljs-comment">// 报错, 抛出的实际是 &#x27;Siri&#x27; 值;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>export 向外抛出的是一个接口, 不能抛出一个具体值;<br>ES6 模块抛出值的引用, CommonJS 抛出值的拷贝;</p></blockquote><h2 id="as-关键字"><a href="#as-关键字" class="headerlink" title="as 关键字"></a>as 关键字</h2><p>作用: 重命名</p><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">let</span> firstName = <span class="hljs-string">&#x27;Siri&#x27;</span>;<br><span class="hljs-keyword">let</span> secondName = <span class="hljs-string">&#x27;John&#x27;</span>;<br><span class="hljs-keyword">export</span> &#123;<br>  firstName <span class="hljs-keyword">as</span> fn, <br>  secondName <span class="hljs-keyword">as</span> sn,<br>  secondName <span class="hljs-keyword">as</span> sc,<br>&#125;;<br></code></pre></div></td></tr></table></figure><blockquote><p>对外接口重命名可达到重复抛出的效果;</p></blockquote><h2 id="ES6-export-特点"><a href="#ES6-export-特点" class="headerlink" title="ES6 export 特点"></a>ES6 export 特点</h2><p>export 输出接口, 其与模块内变量一一对应, 外部代码调用该接口时, 可以通过该接口读取到模块内实时的值, 即接口动态绑定了模块内对应变量的值;</p><figure class="highlight swift"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">1</span>;<br>exports.<span class="hljs-built_in">count</span> = <span class="hljs-built_in">count</span>; <span class="hljs-comment">// &lt;=&gt; exports.count = 1;</span><br></code></pre></div></td></tr></table></figure><p>CommonJS exports 输出的是值的缓存, 因此不存在动态更新;</p><blockquote><p>从上例 CommonJS 输出可以看到, CommonJS 相当于创建了一个空 exports 对象, 并将抛出的值拷贝到该对象上, 然后整体抛出 exports 对象;</p></blockquote><h2 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h2><p>使用 export 命令定义了模块的对外接口以后，其他 JS 文件就可以通过 import 命令加载这个模块;</p><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123;firstName, secondName <span class="hljs-keyword">as</span> sn&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile.js&#x27;</span><br></code></pre></div></td></tr></table></figure><p>import 命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同;<br>import from 后接收模块路径(相对路径, 绝对路径, 模块名), 当接收模块名时, 需要在 <code>package.json</code> 中做相应配置告诉 JavaScirpt 引擎默认的模块导入路径;<br>import 可以通过 as 关键字对接收的变量重命名;</p><ul><li>import 接收的变量都是<strong>只读</strong>的, 本质是因为 import 接收的是 export 抛出的接口, ES6 不允许修改模块的接口(地址);<figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123;a&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>;<br>a = &#123;&#125; <span class="hljs-comment">// 报错, a 代表模块接口, 修改它相当于修改了接口地址指向, 导致无法正确读取接口动态绑定的模块变量值;</span><br><br>a.foo = &#123;&#125; <span class="hljs-comment">// 不报错, a.foo 代表从 a 接口调用输出模块内的 foo 变量值, 因此可正常修改, 但建议凡是输入变量均当作只读属性处理, 避免因修改其他模块数据导致的错误;</span><br></code></pre></div></td></tr></table></figure></li><li>import 具有提升效果, 会提升至模块的头部首先执行, 本质是因为 import 命令在编译阶段执行, import 位于模块顶层即可;<figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">foo();<br><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>; <span class="hljs-comment">// 编译阶段执行</span><br>foo(); <span class="hljs-comment">// 运行阶段执行</span><br></code></pre></div></td></tr></table></figure></li><li>import 静态执行, 不能使用<strong>表达式/变量/块级作用域</strong>等运行时才能得到结果的语法结构;<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 下述 import 均报错</span><br><br><span class="hljs-comment">// 表达式</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-string">&#x27;f&#x27;</span>+<span class="hljs-string">&#x27;oo&#x27;</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>;<br><br><span class="hljs-comment">// 变量</span><br><span class="hljs-keyword">let</span> myModule = <span class="hljs-string">&#x27;module&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> myModule;<br><br><span class="hljs-comment">// if 结构</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>多次执行<strong>相同模块路径</strong>的 import 语句, 最终只会<strong>执行一次</strong>, 不会执行多次;<figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>;<br><span class="hljs-comment">// 上述操作被合并, 并只执行一次, 等价于:</span><br><span class="hljs-keyword">import</span> &#123;foo, bar&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>;<br></code></pre></div></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>;<br><span class="hljs-comment">// 重复操作只执行一次, 等价于:</span><br><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>;<br></code></pre></div></td></tr></table></figure></li></ul><h2 id="模块整体加载"><a href="#模块整体加载" class="headerlink" title="模块整体加载"></a>模块整体加载</h2><p>语法: 用 <code>*</code> 指定一个对象, 所有输出值都加载在该对象上;</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-type">circle</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./circle.js&#x27;</span>;<br><br>console.log(<span class="hljs-string">&#x27;圆面积：&#x27;</span> + <span class="hljs-type">circle</span>.area(<span class="hljs-number">4</span>));<br>console.log(<span class="hljs-string">&#x27;圆周长：&#x27;</span> + <span class="hljs-type">circle</span>.circumference(<span class="hljs-number">14</span>));<br></code></pre></div></td></tr></table></figure><p>本质: 用 <code>*</code> 创建一个对象, 重命名为 <code>circle</code>, 将输出模块的<strong>所有接口</strong>都挂载(添加)到该对象上统一管理;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> circle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./circle&#x27;</span>;<br><br><span class="hljs-comment">// 下面两行都是不允许的</span><br>circle.foo = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>circle.area = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意: 对象内存储的还是对外接口, 因此仍为<strong>只读</strong>属性, 调用接口时不能对其进行修改;</p></blockquote><h2 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h2><p>作用: 为模块指定默认输出, 其他模块加载该模块时，import命令可以为输出接口指定任意名字;<br>一个模块只能有一个默认输出，因此export default命令只能使用一次;</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">add</span>(x, y) &#123;<br>  <span class="hljs-keyword">return</span> x * y;<br>&#125;<br>export &#123;<span class="hljs-keyword">add</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;; // 等同于 export <span class="hljs-keyword">default</span> <span class="hljs-keyword">add</span>;<br><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span>; // 等同于 <span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;module&#x27;</span><br></code></pre></div></td></tr></table></figure><p>本质上，export default就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字;</p><h1 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h1><p>静态 import 加载有利于提高编译器效率, 但也导致无法在运行时加载模块;<br>ES2020 提案引入了 <code>import()</code> 函数来支持动态加载模块(运行时执行);</p><ol><li><code>import()</code> 接收模块路径, 返回一个 Promise 对象(证明 import 是异步加载);</li><li><code>import()</code> 可在任何地方使用, 不仅局限于模块, 非模块脚本也可以使用;</li><li><code>import()</code> 类似于 CommonJS 的 <code>require()</code>, 区别在于前者是异步加载, 后者是同步加载;</li><li><code>import()</code> 加载模块成功后, 加载的模块结果会作为一个对象(类似于<code>*</code>, 内部包含多个对外接口), 作为 then 方法的参数传入(可用对象解构获取输出接口); <code>import()</code> 与加载的模块间没有静态连接关系, 但是本质上仍是值的引用, 通过对象内包裹的接口可获取对应模块内最新的值; <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./myModule.js&#x27;</span>)<br>.then(<span class="hljs-function">(<span class="hljs-params">&#123;export1, export2&#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...·</span><br>&#125;);<br></code></pre></div></td></tr></table></figure></li><li><code>import()</code> 的 default 输出接口, 通过 <code>xxx.default</code> 获得;<figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./myModule.js&#x27;</span>)<br>.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">module</span>)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>.<span class="hljs-keyword">default</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure></li><li>用 <code>Promise.all()</code> 同时动态加载多个模块:<figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.all([<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module1.js&#x27;</span>),<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module2.js&#x27;</span>),<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module3.js&#x27;</span>),<br>])<br>.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">([module1, module2, module3])</span> =&gt;</span> &#123;<br>   ···<br>&#125;);<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>按需加载<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">button.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./index.js&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">/* Success handling */</span><br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">/* Error handling */</span><br>  &#125;)<br>&#125;);<br></code></pre></div></td></tr></table></figure></li><li>条件加载<figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso"><span class="hljs-keyword">if</span> (condition) &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moduleA&#x27;</span>).then(<span class="hljs-params">...</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moduleB&#x27;</span>).then(<span class="hljs-params">...</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>动态模块路径<figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./f&#x27;</span> + <span class="hljs-string">&#x27;oo.js&#x27;</span>).then(<span class="hljs-params">...</span>);<br></code></pre></div></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6篇 - class 继承</title>
    <link href="/2021/04/19/ES6%E7%AF%87-class%E7%BB%A7%E6%89%BF/"/>
    <url>/2021/04/19/ES6%E7%AF%87-class%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>请结合 <a href="https://es6.ruanyifeng.com/#docs/class-extends">Class 的继承</a> 一起阅读本文;</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;<br>  constructor(x, y, color) &#123;<br>    <span class="hljs-keyword">super</span>(x, y); <span class="hljs-comment">// 调用父类的constructor(x, y)</span><br>    <span class="hljs-keyword">this</span>.color = color;<br>  &#125;<br><br>  toString() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.color + &#x27; &#x27; + <span class="hljs-keyword">super</span>.toString(); <span class="hljs-comment">// 调用父类的toString()</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Class 类通过 <strong>extends</strong> 关键字实现继承;<br>extends 可看作是构造函数寄生组合式继承的封装; 它能让子类继承父类的所有属性和方法;</p><h1 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h1><p>super 是 class 类继承的一个重点, 它既可以当作<strong>函数</strong>使用，也可以当作<strong>对象</strong>使用; 使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错;</p><h2 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h2><p>当 super 作为函数调用时，代表父类的构造函数;</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  constructor() &#123;<br>    <span class="hljs-keyword">super</span>();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>ES6 规定<strong>在子类 constructor 方法中必须调用 super 方法</strong>, 否则新建实例时会报错; 在子类的构造函数中，只有调用 <code>super()</code> 之后，才可以使用 this 关键字，否则会报错;<br><strong>原因:</strong> 子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 <code>super()</code>，子类就得不到 this 对象;</p><p>与 ES5 继承的<strong>区别</strong>: </p><ul><li>ES5 的继承实质: 先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面 <code>Parent.apply(this)</code>;</li><li>ES6 的继承机制实质: 先将父类实例对象的属性和方法，加到this上面（所以必须先调用 <code>super()</code>），然后再用子类的构造函数修改 this;</li></ul><p><code>super()</code> 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 <code>super</code> 内部的 this 指的是 B 的实例，因此 <code>super()</code> 在这里相当于 <code>A.prototype.constructor.call(this)</code>;</p><blockquote><p>super() &lt;=&gt; A.prototype.constructor.call(this, …args)</p></blockquote><p>作为函数时，<code>super()</code> 只能用在<strong>子类的构造函数</strong>之中，用在其他地方就会报错;</p><h2 id="super-对象"><a href="#super-对象" class="headerlink" title="super 对象"></a>super 对象</h2><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  p() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  constructor() &#123;<br>    <span class="hljs-keyword">super</span>();<br>    console.log(<span class="hljs-keyword">super</span>.p()); <span class="hljs-comment">// super 作为对象使用, 输出 2</span><br>  &#125;<br>&#125;<br><br>let b = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>();<br></code></pre></div></td></tr></table></figure><p>super 作为对象时，在<strong>普通方法</strong>中，指向<strong>父类的原型对象</strong>; 在<strong>静态方法</strong>中，指向<strong>父类</strong>;</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  constructor() &#123;<br>    <span class="hljs-keyword">this</span>.p = <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  get m() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.p;<br>  &#125;<br>&#125;<br><br>let b = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>();<br>b.m <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure><p>注: 定义在父类实例上的方法或属性，是无法通过 super 对象调用的;</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  constructor() &#123;<br>    <span class="hljs-keyword">this</span>.x = <span class="hljs-number">2</span>;<br>  &#125;<br><br>  print() &#123;<br>    console.log(<span class="hljs-keyword">this</span>.x)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  constructor() &#123;<br>    <span class="hljs-keyword">super</span>()<br>    <span class="hljs-keyword">this</span>.x = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">super</span>.print(); <span class="hljs-comment">// 输出 3</span><br>  &#125;<br>&#125;<br><br>let b = <span class="hljs-keyword">new</span> <span class="hljs-type">B</span>();<br></code></pre></div></td></tr></table></figure><p>ES6 规定，在子类普通方法中通过 super 对象调用父类的方法时，父类方法内部的 this 指向当前的子类实例;</p><blockquote><p>super.print() &lt;=&gt; super.print.call(this)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">myMethod</span>(<span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;static&#x27;</span>, msg);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">myMethod</span>(<span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;instance&#x27;</span>, msg);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">myMethod</span>(<span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.myMethod(msg);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">myMethod</span>(<span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.myMethod(msg);<br>  &#125;<br>&#125;<br><br>Child.myMethod(<span class="hljs-number">1</span>); <span class="hljs-comment">// static 1</span><br></code></pre></div></td></tr></table></figure><p>如果 super 作为对象，用在静态方法之中，这时 super 将指向父类，而不是父类的原型对象; 在子类的静态方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例。</p><h1 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和 proto 属性"></a>类的 prototype 属性和 <strong>proto</strong> 属性</h1><p>class 类同时有 <code>prototype</code> 属性和<code> __proto__</code> 属性, 同时存在两条继承链;</p><ol><li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类; <code>B.__proto__ === A</code>;</li><li>子类prototype属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性; <code>B.prototype.__proto__ === A.prototype</code>;</li></ol><p>这两条继承链，可以这样理解：</p><ul><li>作为一个对象，子类的原型（__proto__属性）是父类;</li><li>作为一个构造函数，子类的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例;</li></ul><p>其原因与 ES6 类的继承实现模式有关:</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> A &#123;&#125;<br><span class="hljs-keyword">class</span> B &#123;&#125;<br><br><span class="hljs-comment">// 原型链继承(继承共享方法)</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>set<span class="hljs-constructor">PrototypeOf(B.<span class="hljs-params">prototype</span>, A.<span class="hljs-params">prototype</span>)</span>;<br><span class="hljs-comment">// 静态属性继承(继承静态定义)</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>set<span class="hljs-constructor">PrototypeOf(B, A)</span>;<br></code></pre></div></td></tr></table></figure><p>class 继承时, 实例属性通过 <code>constructor()</code> 创建 this 对象并挂载父类实例属性实现, 共享方法通过原型链继承实现, 静态方法和属性通过类继承实现; </p><blockquote><p>个人认为类之所以有两条继承链, 是因为类既可以被视为对象, 又可以被视为构造函数, 类作为对象时具有了添加静态属性和方法的能力, 类作为构造函数时实现了 ES5 构造函数的功能;</p></blockquote><h1 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 proto 属性"></a>实例的 <strong>proto</strong> 属性</h1><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">var p1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Point(2, 3)</span>;<br>var p2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ColorPoint(2, 3, &#x27;<span class="hljs-params">red</span>&#x27;)</span>;<br><br>p2.__proto__<span class="hljs-operator"> === </span>p1.__proto__ <span class="hljs-comment">// false</span><br>p2.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">__proto__</span>.</span><span class="hljs-module"><span class="hljs-identifier">__proto__</span> </span><span class="hljs-operator">==</span></span>= p1.__proto__ <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性; 即子类实例的原型的原型，是父类实例的原型; </p><blockquote><p>看似很绕口, 其实很好理解: 子类实例的原型实际就是父类实例(参考ES5 构造函数组合式继承)<code>p2.__proto__ === p1</code>;<br>另一种理解: 类实例的原型同于类的原型<code>p1.__proto__ === Point.prototype</code>, 因此上等式又可以写为 <code>ColorPoint.prototype.__proto__ === Point.prototype</code>, 是不是很熟悉, 就是类的其中一条继承链;</p></blockquote><h1 id="原生构造函数继承"><a href="#原生构造函数继承" class="headerlink" title="原生构造函数继承"></a>原生构造函数继承</h1><h2 id="原生构造函数"><a href="#原生构造函数" class="headerlink" title="原生构造函数"></a>原生构造函数</h2><p>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()</p><h2 id="ES5-和-ES6-原生构造函数继承的区别"><a href="#ES5-和-ES6-原生构造函数继承的区别" class="headerlink" title="ES5 和 ES6 原生构造函数继承的区别"></a>ES5 和 ES6 原生构造函数继承的区别</h2><p><strong>ES5 的原生构造函数无法继承;</strong> 这是因为原生构造函数会忽略 apply 等 thisArgs 绑定方法传入的 this, 也就是说, 原生构造函数的 this 无法绑定, 导致拿不到父类的内部属性;<br><strong>ES6 允许继承原生构造函数定义子类</strong><br>产生上述差异的原因: ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数; ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承;<br>因此, <strong>ES6 的 class extends 能够自定义原生数据结构的子类</strong>, 相较于 ES5 有较大的提升;</p><h1 id="Mixin-模式实现"><a href="#Mixin-模式实现" class="headerlink" title="Mixin 模式实现"></a>Mixin 模式实现</h1><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口;</p><blockquote><p>即将多个对象整合到一个对象内, 并提供统一的调用接口;</p></blockquote><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">const</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> &#123;<br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;Siri&#x27;</span>,<br>&#125;<br><br><span class="hljs-string">const</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> &#123;<br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span>,<br>&#125;<br><br><span class="hljs-string">const</span> <span class="hljs-string">c</span> <span class="hljs-string">=</span> &#123;<span class="hljs-string">...a</span>, <span class="hljs-string">...b</span>&#125; <span class="hljs-string">//</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;Siri&#x27;</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">18</span>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="类的-Mixin-模式完整实现"><a href="#类的-Mixin-模式完整实现" class="headerlink" title="类的 Mixin 模式完整实现"></a>类的 Mixin 模式完整实现</h2><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> mix(...MixClasses) &#123;<br>  <span class="hljs-keyword">class</span> Mix &#123;<br>    constructor<span class="hljs-literal">()</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> MixClass <span class="hljs-keyword">of</span> MixClasses) &#123;<br>        copy<span class="hljs-constructor">Properties(<span class="hljs-params">this</span>, <span class="hljs-params">new</span> MixClass()</span>); <span class="hljs-comment">// 克隆实例属性</span><br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> MixClass <span class="hljs-keyword">of</span> MixClasses) &#123;<br>    copy<span class="hljs-constructor">Properties(Mix, MixClass)</span>; <span class="hljs-comment">// 克隆静态属性</span><br>    copy<span class="hljs-constructor">Properties(Mix.<span class="hljs-params">prototype</span>, MixClass.<span class="hljs-params">prototype</span>)</span>; <span class="hljs-comment">// 克隆原型属性</span><br>  &#125;<br><br>  return Mix;<br>&#125;<br><br><span class="hljs-comment">// 私有方法, 将 source 克隆至 target;</span><br><span class="hljs-keyword">function</span> copy<span class="hljs-constructor">Properties(<span class="hljs-params">target</span>, <span class="hljs-params">source</span>)</span> &#123;<br>  <span class="hljs-comment">// 遍历 source 所有属性</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>own<span class="hljs-constructor">Keys(<span class="hljs-params">source</span>)</span>) &#123;<br>    <span class="hljs-keyword">if</span> (key !== &#x27;constructor&#x27;<br><span class="hljs-operator">      &amp;&amp; </span>key !== &#x27;name&#x27;<br><span class="hljs-operator">      &amp;&amp; </span>key !== &#x27;prototype&#x27;<br>    ) &#123;<br>      <span class="hljs-comment">// 克隆属性描述对象</span><br>      <span class="hljs-keyword">let</span> desc = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>get<span class="hljs-constructor">OwnPropertyDescriptor(<span class="hljs-params">source</span>, <span class="hljs-params">key</span>)</span>;<br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>define<span class="hljs-constructor">Property(<span class="hljs-params">target</span>, <span class="hljs-params">key</span>, <span class="hljs-params">desc</span>)</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> A &#123;&#125;<br><span class="hljs-keyword">class</span> B &#123;&#125;<br><span class="hljs-keyword">class</span> SubClass extends mix(A, B) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6篇 - class 基本语法</title>
    <link href="/2021/04/18/ES6%E7%AF%87-class%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/04/18/ES6%E7%AF%87-class%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>请结合 <a href="https://es6.ruanyifeng.com/#docs/class">Class 的基本语法</a> 一起阅读本文;</p><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><h2 id="类的由来"><a href="#类的由来" class="headerlink" title="类的由来"></a>类的由来</h2><p>JavaScript 通过<em>构造函数</em>生成<em>实例对象</em>;<br>ES6 提出的 class 写法只是让对象原型的写法更加清晰、更像<strong>面向对象编程</strong>的语法而已, 可以看作是 ES5 构造函数的<strong>语法糖</strong>; </p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(x, y) &#123;<br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br><br>  toString() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-keyword">this</span>.x + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-keyword">this</span>.y + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>constructor()</code> 是类的默认方法实现, 是该类的<strong>构造函数</strong>; 类中的 <code>this</code> 关键字代表类的<strong>实例对象</strong>; 除构造函数外, 还能在 class 内自定义任意方法, 如 <code>toString()</code> 方法, <strong>方法与方法之间不需要逗号分隔</strong>;</p><blockquote><p>还记得 class 是 ES5 构造函数的语法糖实现吗? 看上例代码可知, 从形式上看 class 无非是对构造函数和自定义方法做了一层包装, 同时规定构造方法名为 constructor;</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">class <span class="hljs-built_in">Point</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>typeof <span class="hljs-built_in">Point</span> <span class="hljs-comment">// &quot;function&quot;</span><br><span class="hljs-built_in">Point</span> === <span class="hljs-built_in">Point</span>.prototype.constructor <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>类的数据类型: <strong>函数</strong>;<br><strong>类</strong>本身就指向<strong>构造函数</strong>;</p><blockquote><p>new Point() 实际上就是 new Point.prototype.constructor(), 因此 ES6 的类，完全可以看作构造函数的另一种写法;<br>类与构造函数的一点<strong>区别</strong>: 类必须通过 new 操作符创建实例;</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> pt = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Point(1, 2)</span>;<br>pt.x <span class="hljs-comment">// 直接从实例对象获取: this.x</span><br>pt.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>; <span class="hljs-comment">// 通过原型链调用: Point.prototype.toString()</span><br></code></pre></div></td></tr></table></figure><p>不得不提的一点是: class 类中有两种对象值得去关注, 1. <strong>this</strong> 实例对象 2. <strong>prototype</strong> 原型对象; <strong>在 class 中定义的属性或方法, 若没有显式定义挂载到 this 对象上, 则都会被添加至类的 prototype 原型对象</strong>;</p><blockquote><p>class 声明类时, 一般将方法添加到原型对象上, 将属性添加至 this 实例对象上; 这也符合 ES5 构造函数添加方法和属性的习惯, 创建的实例拥有独有的属性, 同时共享原型对象的方法;</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">Object</span>.assign(Point.prototype, &#123;<br>  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>  <span class="hljs-function"><span class="hljs-title">toValue</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>类的所有方法都定义在类的 prototype 属性上面, 因此在添加新的方法时, 通过 <code>Object.assign()</code> 方法一次向类添加多个方法;</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Point &#123;<br>  constructor(x, y) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>keys(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Point</span>.</span></span>prototype)<br><span class="hljs-comment">// []</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">OwnPropertyNames(Point.<span class="hljs-params">prototype</span>)</span><br><span class="hljs-comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span><br></code></pre></div></td></tr></table></figure><p>类内部定义的所有方法都是<strong>不可枚举</strong>的; ES5 构造函数通过 <code>xxx.prototype.funcName = function() &#123;...&#125;</code> 添加方法是可枚举的;</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a>constructor()</h2><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Point</span> &#123;&#125;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Point</span> &#123;<br>  constructor() &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>constructor()方法是类的<strong>默认方法</strong>; 一个类必须有 <code>constructor()</code> 方法，如果没有显式定义，一个空的 <code>constructor()</code> 方法会被<strong>默认添加</strong>。</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> pt = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Point()</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> pt = <span class="hljs-keyword">new</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Point</span>.</span></span>prototype.constructor<span class="hljs-literal">()</span><br></code></pre></div></td></tr></table></figure><p>通过 new 命令生成对象实例时，自动调用<code>constructor()</code>。</p><blockquote><p>前面提到: 类本身指向构造函数, 因此 new 实例化类实际上就是调用了类内的 constructor();</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo1</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Siri&#x27;</span>;<br>    <span class="hljs-comment">// return this;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo2</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Siri&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create(&#123;<br>      name: <span class="hljs-string">&#x27;John&#x27;</span>,<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo3</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Siri&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> foo1 = <span class="hljs-keyword">new</span> Foo1();<br><span class="hljs-keyword">let</span> foo2 = <span class="hljs-keyword">new</span> Foo2();<br><span class="hljs-keyword">let</span> foo3 = <span class="hljs-keyword">new</span> Foo3();<br><br><span class="hljs-built_in">console</span>.log(foo1.name); <span class="hljs-comment">// Siri</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.getPrototypeOf(foo1) === Foo1.prototype); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(foo2.name); <span class="hljs-comment">// John</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.getPrototypeOf(foo2) === Foo2.prototype); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(foo3.name); <span class="hljs-comment">// Siri</span><br></code></pre></div></td></tr></table></figure><p>constructor()方法<strong>默认返回实例对象 this</strong>，当然也可以返回自定义对象; constructor 方法会隐式返回类的实例对象, this 对象原型为类(构造函数)的原型(见<code>foo1</code>); 若显式 return 值, 当 return 一对象时, 生成的实例即为该返回值对象, 它不在类的原型链上(见<code>foo2</code>), 当 return 非对象类型的返回值时, 会忽略该返回值(见<code>foo3</code>);</p><blockquote><p>同 new 操作符内部实现一致, 无论是普通构造函数还是类构造函数生成实例对象, 都依赖于 new 的内部实现;</p></blockquote><h2 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h2><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(x, y) &#123;<br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br><br>  toString() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-keyword">this</span>.x + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-keyword">this</span>.y + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>用构造函数实现如下:</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span><span class="hljs-params">(x, y)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>.x = x;<br>  <span class="hljs-keyword">this</span>.y = y;<br>&#125;<br><br>Point.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-keyword">this</span>.x + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-keyword">this</span>.y + <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）;</p><blockquote><p>如上例, 显式定义在 this 对象上的属性(或方法), 最终会挂载在创建的实例对象上, 为该实例对象所<strong>独有</strong>; 其余没有定义在 this 上的属性或方法(如<code>toString()</code>)都被定义在类原型(<code>Point.prototype</code>)上, 被该类的所有实例对象所<strong>共享</strong>(这是因为<strong>类的所有实例共享一个原型对象</strong>, 同 ES5);</p></blockquote><h2 id="取值函数-getter-和存值函数-setter"><a href="#取值函数-getter-和存值函数-setter" class="headerlink" title="取值函数(getter)和存值函数(setter)"></a>取值函数(getter)和存值函数(setter)</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">prop</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">prop</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span>+value);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> inst = <span class="hljs-keyword">new</span> MyClass();<br><br>inst.prop = <span class="hljs-number">123</span>; <span class="hljs-comment">// setter: 123</span><br>inst.prop <span class="hljs-comment">// &#x27;getter</span><br></code></pre></div></td></tr></table></figure><p>类内部可以使用 <strong>get</strong> 和 <strong>set</strong> 关键字，对某个属性设置存值函数和取值函数，<strong>拦截该属性的存取行为</strong>;</p><blockquote><p>关于 getter 和 setter 可参考<a href="https://zh.javascript.info/property-descriptors">数据属性</a>和<a href="https://zh.javascript.info/property-accessors">访问器属性</a></p></blockquote><h2 id="类属性名的表达式表示"><a href="#类属性名的表达式表示" class="headerlink" title="类属性名的表达式表示"></a>类属性名的表达式表示</h2><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">const METHODNAME = &#x27;methodName&#x27;;<br><br>class Square &#123;<br>  constructor(length) &#123;...&#125;<br><br>  [<span class="hljs-string">METHODNAME</span>](<span class="hljs-link"></span>) &#123;<br><span class="hljs-code">    ...</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">&#125;</span><br></code></pre></div></td></tr></table></figure><p>类的属性名，可以采用表达式;</p><h2 id="class-的表达式定义"><a href="#class-的表达式定义" class="headerlink" title="class 的表达式定义"></a>class 的表达式定义</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> MyClass = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Me</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-title">getClassName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> Me.name;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>与函数一样，类也可以使用<strong>表达式定义</strong>(类本身就是函数类型); 上例中 <code>MyClass</code> 是类的外部名称, 用于外部引用, <code>Me</code> 是类内部名称, 只能在 Class 的内部可用, 如果类的内部没用到的话，可以省略类的內部命名;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-class"><span class="hljs-keyword">class</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">sayName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>&#125;(<span class="hljs-string">&#x27;张三&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>应用: 与常规 class 声明相比, 采用 Class 表达式，我们可以写出<strong>立即执行的 Class</strong>;</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式; 因此, <strong>类和模块的内部，默认就是严格模式</strong>。只要你的代码写在类或模块之中，就只有严格模式可用。</p><h3 id="不存在提升"><a href="#不存在提升" class="headerlink" title="不存在提升"></a>不存在提升</h3><p>类不存在变量提升:  ES6 不会把类的声明提升到代码头部;</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala">&#123;<br>  let <span class="hljs-type">Foo</span> = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>&#123;&#125;;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>&#123;&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>原因: 在后续提及的类的继承中, 子类需要调用父类的构造函数来构建自己的实例对象 this, 因此就要保证父类在子类前被定义, 因此 ES6 规定类声明不能发生变量提升, 否则会导致子类在父类前定义的情况;如上例, Bar 子类由 class 声明, 若存在变量提升, 则会被提升到 let 命令(<em>let 不会发生变量提升</em>)之前, 导致 Bar 继承 Foo 时 Foo 还未被定义;</p><h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h3><p>本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> pt = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;&#125;<br><span class="hljs-built_in">console</span>.log(pt.name); <span class="hljs-comment">// Point</span><br></code></pre></div></td></tr></table></figure><p>name 属性总是返回<strong>紧跟在 class 关键字后面的类名(即类內部命名)</strong></p><h3 id="Generator-方法"><a href="#Generator-方法" class="headerlink" title="Generator 方法"></a>Generator 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...args</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.args = args;<br>  &#125;<br><br>  * [<span class="hljs-built_in">Symbol</span>.iterator]() &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> arg <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.args) &#123;<br>      <span class="hljs-keyword">yield</span> arg;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> <span class="hljs-keyword">new</span> Foo(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;<br><span class="hljs-comment">// hello</span><br><span class="hljs-comment">// world</span><br></code></pre></div></td></tr></table></figure><p>类内原型链上的普通方法定义不需要 function 关键字;<br>类内 Generator 方法定义即在普通函数基础上加上 <code>*</code>, 表示该方法是个 Generator 函数;</p><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> logger = <span class="hljs-keyword">new</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">printName</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;there&#x27;</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.print(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params">text</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(text);<br>  &#125;<br>&#125;();<br>logger.printName()<br></code></pre></div></td></tr></table></figure><p><strong>类方法内部 this 默认指向类的实例</strong>(因为通常通过类的实例来调用方法); </p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">const &#123; printName &#125; = logger;<br>printName(); // TypeError: Cannot <span class="hljs-keyword">read</span> <span class="hljs-keyword">property</span><span class="hljs-title"> </span>&#x27;print&#x27; of undefined<br></code></pre></div></td></tr></table></figure><p>但是若单独使用类内方法, this 会指向方法运行的环境(class 严格模式下, this 指向 undefined);</p><blockquote><p>结合 this 指向的知识点进行判断即可;</p></blockquote><p>为防止类内方法因不当调用导致 this 指向出错的问题, 通常有两种方法解决:</p><ol><li>在构造函数<code>constructor()</code>中为方法绑定 this<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.printName = <span class="hljs-built_in">this</span>.printName.bind(<span class="hljs-built_in">this</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">printName</span>(<span class="hljs-params">name = <span class="hljs-string">&#x27;there&#x27;</span></span>)</span> &#123;<br>    <span class="hljs-comment">// 类内方法的 this 代表类实例, 通过 this 调用类方法, 再通过原型链找到 print() 并执行;</span><br>    <span class="hljs-built_in">this</span>.print(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params">text</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(text);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>在构造函数<code>constructor()</code>中使用箭头函数<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.printName = <span class="hljs-function">(<span class="hljs-params">name = <span class="hljs-string">&#x27;there&#x27;</span></span>) =&gt;</span> &#123;<span class="hljs-built_in">this</span>.print(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>)&#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params">text</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(text);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>使用 Proxy 拦截, 获取方法时触发拦截, 并自动绑定 this<figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function">function <span class="hljs-title">selfish</span> (<span class="hljs-params">target</span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> WeakMap();<br>  <span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-comment">// 拦截属性访问</span><br>    <span class="hljs-keyword">get</span> (target, key) &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-keyword">value</span> = Reflect.<span class="hljs-keyword">get</span>(target, key);<br>      <span class="hljs-comment">// 若不是函数则原值返回</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">value</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;<br>      &#125;<br>      <span class="hljs-comment">// 是函数, 绑定实例对象, 并将添加记录到哈希表;</span><br>      <span class="hljs-keyword">if</span> (!cache.has(<span class="hljs-keyword">value</span>)) &#123;<br>        cache.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">value</span>, <span class="hljs-keyword">value</span>.bind(target));<br>      &#125;<br>      <span class="hljs-comment">// 返回绑定后的函数</span><br>      <span class="hljs-keyword">return</span> cache.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">value</span>);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> Proxy(target, handler);<br>  <span class="hljs-comment">// 返回 proxy 包装</span><br>  <span class="hljs-keyword">return</span> proxy;<br>&#125;<br><br><span class="hljs-keyword">const</span> logger = selfish(<span class="hljs-keyword">new</span> Logger())<br></code></pre></div></td></tr></table></figure></li></ol><h1 id="class-静态方法"><a href="#class-静态方法" class="headerlink" title="class 静态方法"></a>class 静态方法</h1><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Foo &#123;<br>  static <span class="hljs-keyword">class</span><span class="hljs-constructor">Method()</span> &#123;<br>    return &#x27;hello&#x27;;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Foo()</span>;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Foo</span>.</span></span><span class="hljs-keyword">class</span><span class="hljs-constructor">Method()</span> <span class="hljs-comment">// &#x27;hello&#x27;</span><br>foo.<span class="hljs-keyword">class</span><span class="hljs-constructor">Method()</span> <span class="hljs-comment">// TypeError: foo.classMethod is not a function</span><br></code></pre></div></td></tr></table></figure><p>类内所有属性和方法都通过类生成的实例调用; 但如果在一个方法前，加上 <strong>static</strong> 关键字, 表示声明了一个<strong>静态方法</strong>，该方法不在实例调用，而是<strong>直接通过类来调用</strong>, 如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法;</p><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>静态方法直接定义在类上, 而不是定义在类的原型上;</li><li><strong>静态方法的 this 关键字指向类</strong>，而不是实例(因为调用时通过 <code>Foo.bar()</code> 调用, 根据 this 隐式调用规则可判断);<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.baz();<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">baz</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">baz</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;world&#x27;</span>);<br>  &#125;<br>&#125;<br><br>Foo.bar() <span class="hljs-comment">// hello</span><br></code></pre></div></td></tr></table></figure></li><li>静态方法可以与非静态方法重名;</li><li>父类的静态方法，可以被子类继承;</li><li>静态方法可从 super 对象上调用(super 对象代表父类的构造函数, 构造函数也就是类);</li></ol><h1 id="实例属性新写法"><a href="#实例属性新写法" class="headerlink" title="实例属性新写法"></a>实例属性新写法</h1><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span> </span>&#123;<br>  bar = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>  baz = <span class="hljs-string">&#x27;world&#x27;</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实例属性除了定义在 <code>constructor()</code> 方法里面的 this 上面，也可以<strong>定义在类的最顶层</strong>;<br>好处: 所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。<br>坏处: 之前提及类中除显式定义在 this 实力上的属性外, 其余都定义在类的原型上; 若省略 this 可能会将其判断到原型上;</p><h1 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h1><p>静态属性指的是 Class 本身的属性，即 <code>Class.propName</code>，而不是定义在实例对象（this）上的属性;<br>目前声明静态属性的方式(ES6 目前规定 Class 内部只有静态方法, 没有静态属性):</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Foo</span> &#123;&#125;<br>Foo.prop = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>类的静态属性提案: 在类内部显式声明, 在实例属性前加上 static 关键字;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> prop = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。<br>缺点: 容易忽略静态属性，也不符合相关代码应该放在一起的代码组织原则。<br>提案是显式声明（declarative），而不是赋值处理，语义更好。</p></blockquote><h1 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h1><p>概念: 只能在类的内部访问的方法和属性，外部不能访问;<br>作用: 有利于代码的封装;<br>ES6 没有提供私有方法和私有属性的显式声明方式, 因此只能通过变通方法进行模拟实现;</p><ol><li><p>命名上区别私有和共有: 私有变量以 <code>_</code> 开头; 这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> </span>&#123;<br>  <span class="hljs-comment">// 公有方法</span><br>  foo (baz) &#123;<br>    <span class="hljs-keyword">this</span>._bar(baz);<br>  &#125;<br><br>  <span class="hljs-comment">// 私有方法</span><br>  _bar(baz) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.snaf = baz;<br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>在类外部定义私有方法;</p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">class</span> Widget &#123;<br>  foo (<span class="hljs-keyword">name</span>) &#123;<br>    <span class="hljs-built_in">print</span><span class="hljs-number">.</span><span class="hljs-keyword">call</span>(this, <span class="hljs-keyword">name</span>);<br>  &#125;<br><br>  // <span class="hljs-number">.</span><span class="hljs-number">.</span><span class="hljs-number">.</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> <span class="hljs-built_in">print</span>(<span class="hljs-keyword">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> this<span class="hljs-number">.</span><span class="hljs-keyword">name</span> = <span class="hljs-keyword">name</span><br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>Widget 实例只能访问到 foo 方法, foo 实际是对 print 方法的封装, 保证了 print 方法的私有性;</p></blockquote></li><li><p>利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值; Symbol 值无法被一般的遍历方式获取, 基本达到了私有的效果, 但是不能排除通过 <code>Reflect.ownKeys()</code> 等方法获取;</p><figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">const bar = Symbol(&#x27;bar&#x27;);<br><br>class MyClass &#123;<br>  // 公有方法<br>  foo(baz) &#123;<br><span class="hljs-code">    this[bar](baz);</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">  // 私有方法</span><br><span class="hljs-code">  [bar]() &#123;</span><br><span class="hljs-code">    // ...</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code"></span><br><span class="hljs-code">&#125;</span><br></code></pre></div></td></tr></table></figure></li></ol><h2 id="私有属性和私有方法的提案"><a href="#私有属性和私有方法的提案" class="headerlink" title="私有属性和私有方法的提案"></a>私有属性和私有方法的提案</h2><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br>  <span class="hljs-comment">#a;</span><br>  <span class="hljs-comment">#b;</span><br>  constructor(a, b) &#123;<br>    <span class="hljs-built_in">this</span>.<span class="hljs-comment">#a = a;</span><br>    <span class="hljs-built_in">this</span>.<span class="hljs-comment">#b = b;</span><br>  &#125;<br>  <span class="hljs-comment">#sum() &#123;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.<span class="hljs-comment">#a + this.#b;</span><br>  <br>&#125;<br><br><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Foo();<br>foo.<span class="hljs-comment">#a // 报错</span><br>foo.<span class="hljs-comment">#a = 42 // 报错</span><br></code></pre></div></td></tr></table></figure><p>在属性名之前, 使用 <code>#</code> 关键字声明私有;<br>上面代码中，<code>#a</code> 就是私有属性, <code>#sum</code> 就是私有方法，<strong>只能在类的内部使用</strong>。如果在类的外部使用，就会报错。</p><h1 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h1><p><code>new.target</code> 返回 new 命令<strong>当前</strong>所作用的构造函数; 如果构造函数不是通过 new 命令或 Reflect.construct() 调用的，<code>new.target</code> 会返回 <code>undefined</code>;<br><strong>在函数外部使用 <code>new.target</code> 会报错</strong>;</p><p><strong>约束构造函数必须经 new 操作符调用</strong></p><figure class="highlight haxe"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haxe"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span></span>(name) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type"></span>.target === Person) &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(<span class="hljs-string">&#x27;必须使用 new 命令生成实例&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Class 类内部使用 <code>new.target</code>, <strong>返回当前 Class</strong>; (因为类本身就是构造函数)</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span>.target === Person);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(); <span class="hljs-comment">// 输出 true</span><br></code></pre></div></td></tr></table></figure><blockquote><p>注意, new.target 返回的是当前的 Class, 当子类继承父类时, 父类内的 <code>new.target</code> 返回的是子类构造函数;</p></blockquote><p><strong>基于 new.target 返回当前构造函数特性, 实现不能独立使用、必须继承后才能使用的类</strong></p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>&#123;<br>  constructor() &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.target === <span class="hljs-type">Shape</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>(&#x27;本类不能实例化&#x27;);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;<br>  constructor(length, width) &#123;<br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上例中, Shape 自身不能实例化, 只能通过继承的子类实例化;</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6篇 - Reflect</title>
    <link href="/2021/04/17/ES6%E7%AF%87-Reflect/"/>
    <url>/2021/04/17/ES6%E7%AF%87-Reflect/</url>
    
    <content type="html"><![CDATA[<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Reflect 对象: ES6 为<strong>操作对象</strong>而提供的新 API, 用于替代 Object 的一些操作方法:</p><ol><li>将Object对象的一些明显属于<strong>语言内部的方法</strong>（比如<code>Object.defineProperty</code>），放到Reflect对象上。<blockquote><p>现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。</p></blockquote></li><li>修改某些Object方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// Object.defineProperty()</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Property(<span class="hljs-params">target</span>, <span class="hljs-params">property</span>, <span class="hljs-params">attributes</span>)</span>;<br>  <span class="hljs-comment">// success</span><br>&#125; catch (err) &#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;<br><br><span class="hljs-comment">// Reflect.defineProperty()</span><br><span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>define<span class="hljs-constructor">Property(<span class="hljs-params">target</span>, <span class="hljs-params">property</span>, <span class="hljs-params">attributes</span>)</span>) &#123;<br>  <span class="hljs-comment">// success</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>统一所有 Object 操作为函数式行为;<blockquote><p>例如: <code>name in obj</code>, <code>delete obj[name]</code> 等 Object 操作是命令式的, 现用 Reflect 将其统一成函数式, <code>Reflect.has(obj, name)</code>, <code>Reflect.deleteProperty(obj, name)</code></p></blockquote><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 命令式 Object 操作<br><span class="hljs-string">&#x27;assign&#x27;</span> <span class="hljs-keyword">in</span> obj;<br><br><span class="hljs-regexp">//</span> 函数式 Object 操作<br>Reflect.has(obj, <span class="hljs-string">&#x27;assign&#x27;</span>);<br></code></pre></div></td></tr></table></figure></li><li>Reflect 对象方法与 Proxy 对象方法一一对应; 使得 Proxy 对象可以方便调用 Reflect 对象方法, 完成默认行为, 作为修改行为的基础; 无论 Proxy 怎么修改该默认行为, 都可以通过 Reflect 获取原生的默认行为;<figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">let<span class="hljs-built_in"> proxy </span>= new Proxy(target, &#123;<br>  <span class="hljs-builtin-name">set</span>(target, name, value, receiver) &#123;<br>    let success = Reflect.<span class="hljs-builtin-name">set</span>(target, name, value, receiver);<br>    return success;<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="Reflect-对象的静态方法"><a href="#Reflect-对象的静态方法" class="headerlink" title="Reflect 对象的静态方法"></a>Reflect 对象的静态方法</h2><blockquote><p>Reflect.get(target, name, receiver)<br>Reflect.set(target, name, value, receiver)<br>Reflect.has(obj, name)<br>Reflect.deleteProperty(obj, name)<br>Reflect.construct(target, args)<br>Reflect.getPrototypeOf(obj)<br>Reflect.setPrototypeOf(obj, newProto)<br>Reflect.apply(target, thisArg, args)<br>Reflect.defineProperty(target, propertyKey, attributes)<br>Reflect.getOwnPropertyDescriptor(target, propertyKey)<br>Reflect.isExtensible(target)<br>Reflect.preventExtensions(target)<br>Reflect.ownKeys(target)</p></blockquote><ol><li>Reflect.get(target, name, receiver)<br>查找并返回 target 对象 name 属性所对应的值, 如果没有该属性, 则返回 undefined;<blockquote><p>target: 目标对象, 若不是对象类型, 报错;<br>name: 对象键名 key;<br>receiver: 当 name 属性部署了 getter 时的 this 指向;</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  name: <span class="hljs-string">&#x27;Siri&#x27;</span>,<br>  age: <span class="hljs-number">18</span>,<br>  action: [<br>    <span class="hljs-string">&#x27;eat&#x27;</span>,<br>    <span class="hljs-string">&#x27;run&#x27;</span>,<br>    <span class="hljs-string">&#x27;sleep&#x27;</span>,<br>  ],<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">dosomething</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myObj = &#123;<br>  name: <span class="hljs-string">&#x27;Wang&#x27;</span>,<br>  age: <span class="hljs-number">20</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> name = <span class="hljs-built_in">Reflect</span>.get(obj, <span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// Siri</span><br><span class="hljs-keyword">let</span> height = <span class="hljs-built_in">Reflect</span>.get(obj, <span class="hljs-string">&#x27;height&#x27;</span>); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">let</span> res = <span class="hljs-built_in">Reflect</span>.get(obj, <span class="hljs-string">&#x27;dosomething&#x27;</span>); <span class="hljs-comment">// Hi Siri</span><br>res = <span class="hljs-built_in">Reflect</span>.get(obj, <span class="hljs-string">&#x27;dosomething&#x27;</span>, myObj); <span class="hljs-comment">// Hi Wang</span><br><span class="hljs-keyword">let</span> err = <span class="hljs-built_in">Reflect</span>.get(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;name&#x27;</span>) <span class="hljs-comment">// TypeError: Reflect.get called on non-object; 第一参数不是对象, 无法读取属性;</span><br></code></pre></div></td></tr></table></figure><ol start="2"><li>Reflect.set(target, name, value, receiver)<br>设置target对象的name属性等于value; 若不存在 name 属性则先创建再赋值, 若存在则覆盖 name 属性值;<blockquote><p>target: 目标对象, 若不是对象类型, 报错;<br>name: 对象键名 key;<br>value: 期望设置的键值 value;<br>receiver: 当 name 属性部署了 setter 时的 this 指向;</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  name: <span class="hljs-string">&#x27;Siri&#x27;</span>,<br>  age: <span class="hljs-number">18</span>,<br>  action: [<br>    <span class="hljs-string">&#x27;eat&#x27;</span>,<br>    <span class="hljs-string">&#x27;run&#x27;</span>,<br>    <span class="hljs-string">&#x27;sleep&#x27;</span>,<br>  ],<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">dosomething</span>() &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hi <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>);<br>  &#125;,<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">setAge</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (value !== <span class="hljs-built_in">this</span>.age) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Can&#x27;t Change Your Age&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myObj = &#123;<br>  name: <span class="hljs-string">&#x27;Wang&#x27;</span>,<br>  age: <span class="hljs-number">20</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> res = <span class="hljs-built_in">Reflect</span>.get(obj, <span class="hljs-string">&#x27;height&#x27;</span>); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">Reflect</span>.set(obj, <span class="hljs-string">&#x27;height&#x27;</span>, <span class="hljs-number">1.6</span>);<br>res = <span class="hljs-built_in">Reflect</span>.get(obj, <span class="hljs-string">&#x27;height&#x27;</span>); <span class="hljs-comment">// 1.6</span><br><span class="hljs-built_in">Reflect</span>.set(obj, <span class="hljs-string">&#x27;height&#x27;</span>, <span class="hljs-number">1.8</span>);<br>res = <span class="hljs-built_in">Reflect</span>.get(obj, <span class="hljs-string">&#x27;height&#x27;</span>); <span class="hljs-comment">// 1.8</span><br><br><span class="hljs-built_in">Reflect</span>.set(obj, <span class="hljs-string">&#x27;setAge&#x27;</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// Can&#x27;t Change Your Age</span><br><span class="hljs-built_in">Reflect</span>.set(obj, <span class="hljs-string">&#x27;setAge&#x27;</span>, <span class="hljs-number">20</span>, myObj); <span class="hljs-comment">// 20</span><br></code></pre></div></td></tr></table></figure><ol start="3"><li>Reflect.has(obj, name)<br>查找 obj 对象内是否存在 name 属性, 若存在返回 true, 不存在返回 false; 等价于 <code>name in obj</code> 的 in 运算符, 是命令行为向函数行为统一的体现;<blockquote><p>obj: 目标对象, 若不是对象类型, 报错;<br>name: 所要查找的属性名</p></blockquote></li></ol><figure class="highlight qml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> myObj = &#123;<br>  <span class="hljs-attribute">name</span>: <span class="hljs-string">&#x27;Wang&#x27;</span>,<br>  <span class="hljs-attribute">age</span>: <span class="hljs-number">20</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-built_in">bool</span> = <span class="hljs-built_in">Reflect</span>.has(myObj, <span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">bool</span> = <span class="hljs-built_in">Reflect</span>.has(myObj, <span class="hljs-string">&#x27;height&#x27;</span>); <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><ol start="4"><li>Reflect.deleteProperty(obj, name)<br>等同于<code>delete obj[name]</code>，用于删除对象的属性; 返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false;<blockquote><p>obj: 目标对象, 若不是对象类型, 报错;<br>name: 所要删除的属性名</p></blockquote></li></ol><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">const myObj = &#123;<br>  name: &#x27;Wang&#x27;,<br>  age: <span class="hljs-number">20</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-built_in">bool</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>delete<span class="hljs-constructor">Property(<span class="hljs-params">myObj</span>, &#x27;<span class="hljs-params">age</span>&#x27;)</span>; <span class="hljs-comment">// true</span><br><span class="hljs-built_in">bool</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>delete<span class="hljs-constructor">Property(<span class="hljs-params">myObj</span>, &#x27;<span class="hljs-params">height</span>&#x27;)</span>; <span class="hljs-comment">// true</span><br>console.log(myObj); <span class="hljs-comment">// &#123; name: &#x27;Wang&#x27; &#125;</span><br></code></pre></div></td></tr></table></figure><ol start="5"><li>Reflect.construct(target, args)<br>等同于<code>new target(...args)</code>，提供了一种不使用 new 来调用构造函数的方法; 返回构造函数实例;<blockquote><p>target: 目标对象, 若不是对象类型, 报错;<br>args: 构造函数初始化参数;</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Reflect</span>.construct(F, [<span class="hljs-string">&#x27;Siri&#x27;</span>, <span class="hljs-number">18</span>]); <span class="hljs-comment">// F &#123; name: &#x27;Siri&#x27;, age: 18 &#125;</span><br></code></pre></div></td></tr></table></figure><ol start="6"><li><p>Reflect.getPrototypeOf(obj)</p><blockquote><p>obj: 目标对象, 若不是对象类型, 报错;<br>读取并返回对象的__proto__属性，对应 <code>Object.getPrototypeOf(obj)</code>; <code>Reflect.getPrototypeOf</code> 和 <code>Object.getPrototypeOf</code> 的一个区别是: 如果参数不是对象，<code>Object.getPrototypeOf</code> 会将这个参数转为对象，然后再运行，而 <code>Reflect.getPrototypeOf</code> 会报错。(体现了开头介绍的 Reflect 特性, 其修改了原先 Object 方法的一些不合理操作);</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">const obj = &#123;<br>  name: &#x27;Siri&#x27;,<br>  age: <span class="hljs-number">18</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> res = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">obj</span>)</span>; <span class="hljs-comment">// Object.prototype</span><br><br><span class="hljs-comment">// 区别</span><br><span class="hljs-keyword">let</span> msg1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(1)</span>; <span class="hljs-comment">// [Number: 0]</span><br><span class="hljs-keyword">let</span> msg2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(1)</span>; <span class="hljs-comment">// TypeError: Reflect.getPrototypeOf called on non-object</span><br></code></pre></div></td></tr></table></figure></li><li><p>Reflect.setPrototypeOf(obj, newProto)<br>设置目标对象的原型（prototype），对应 <code>Object.setPrototypeOf(obj, newProto)</code> 方法。它返回一个布尔值，若成功则返回 true, 设置失败返回 false;<br><code>Reflect.setPrototypeOf</code> 与 <code>Object.setPrototypeOf</code> 区别: 如果第一个参数不是对象，<code>Object.setPrototypeOf</code> 会返回第一个参数本身，而 <code>Reflect.setPrototypeOf</code> 会报错; 如果第一个参数是 undefined 或 null，<code>Object.setPrototypeOf</code> 和 <code>Reflect.setPrototypeOf</code> 都会报错;</p><blockquote><p>obj: 目标对象, 若不是对象类型, 报错;<br>newProto: 期望设置的原型;</p></blockquote></li></ol><figure class="highlight qml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attribute">name</span>: <span class="hljs-string">&#x27;Siri&#x27;</span>,<br>  <span class="hljs-attribute">age</span>: <span class="hljs-number">18</span>,<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(obj.length); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-built_in">bool</span> = <span class="hljs-built_in">Reflect</span>.setPrototypeOf(obj, <span class="hljs-built_in">Array</span>.prototype); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(obj.length);  <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure><ol start="8"><li>Reflect.apply(func, thisArg, args)<br>等同于 <code>Function.prototype.apply.call(func, thisArg, args)</code> ，用于绑定 this 对象后执行回调函数。<br>一般来说，如果要绑定一个函数的this对象，用 <code>fn.apply(obj, args)</code> 即可，但是如果函数定义了自己的 apply 方法，就只能写成 <code>Function.prototype.apply.call(fn, obj, args)</code>，而采用Reflect对象可以简化这种操作。<blockquote><p>func: 绑定 this 对象后触发的回调函数<br>thisArg: 期望绑定的 this 对象<br>args: 传递给 func 的函数参数</p></blockquote></li></ol><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> ages = [<span class="hljs-number">11</span>, <span class="hljs-number">33</span>, <span class="hljs-number">12</span>, <span class="hljs-number">54</span>, <span class="hljs-number">18</span>, <span class="hljs-number">96</span>];<br><br><span class="hljs-comment">// 旧写法</span><br><span class="hljs-keyword">const</span> youngest = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-built_in">Math</span>, ages);<br><span class="hljs-keyword">const</span> oldest = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>, ages);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">type</span> = <span class="hljs-built_in">Object</span>.prototype.toString.call(youngest);<br><br><span class="hljs-comment">// 新写法</span><br><span class="hljs-keyword">const</span> youngest = <span class="hljs-built_in">Reflect</span>.apply(<span class="hljs-built_in">Math</span>.min, <span class="hljs-built_in">Math</span>, ages);<br><span class="hljs-keyword">const</span> oldest = <span class="hljs-built_in">Reflect</span>.apply(<span class="hljs-built_in">Math</span>.max, <span class="hljs-built_in">Math</span>, ages);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">type</span> = <span class="hljs-built_in">Reflect</span>.apply(<span class="hljs-built_in">Object</span>.prototype.toString, youngest, []);<br></code></pre></div></td></tr></table></figure><ol start="9"><li>Reflect.defineProperty(target, propertyKey, attributes)<br>等同于 <code>Object.defineProperty</code>，为对象定义属性, 若属性存在则覆盖原属性值, 返回一个布尔值。未来，后者会被逐渐废除，请从现在开始就使用 <code>Reflect.defineProperty</code> 代替它;<br><code>Reflect.defineProperty()</code> 与 <code>Reflect.set()</code> 使用场景区别: <code>Reflect.defineProperty()</code> 用于赋值和修改对象属性的属性描述(value, get, set, writable等), <code>Reflect.set()</code> 只能用于修改属性值(value);<blockquote><p>target: 目标对象, 若不是对象类型, 报错;<br>propertyKey: 需要赋值的对象属性;<br>attributes: 属性描述对象;</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  name: <span class="hljs-string">&#x27;Siri&#x27;</span>,<br>  age: <span class="hljs-number">20</span>,<br>&#125;<br><br><span class="hljs-built_in">Reflect</span>.defineProperty(obj, <span class="hljs-string">&#x27;age&#x27;</span>, &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`I&#x27;m 18 years old`</span>);<br>  &#125;,<br>&#125;)<br><br>obj.age; <span class="hljs-comment">// I&#x27;m 18 years old</span><br></code></pre></div></td></tr></table></figure><ol start="10"><li>Reflect.getOwnPropertyDescriptor(target, propertyKey)<br>等同于 <code>Object.getOwnPropertyDescriptor</code>，返回指定属性的描述对象，将来会替代掉后者;<br><code>Reflect.getOwnPropertyDescriptor</code> 和 <code>Object.getOwnPropertyDescriptor</code> 的区别: 如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor()</code> 不报错，返回 undefined，而 <code>Reflect.getOwnPropertyDescriptor()</code> 会抛出错误，表示参数非法;<blockquote><p>target: 目标对象, 若不是对象类型, 报错;<br>propertyKey: 属性键名;</p></blockquote></li></ol><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">const</span> <span class="hljs-string">obj</span> <span class="hljs-string">=</span> &#123;<br>  <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;Wang&#x27;</span><br>&#125;<br><br><span class="hljs-string">Reflect.defineProperty(obj,</span> <span class="hljs-string">&#x27;name&#x27;</span><span class="hljs-string">,</span> &#123;<br>  <span class="hljs-attr">value:</span> <span class="hljs-string">&#x27;Siri&#x27;</span>,<br>  <span class="hljs-attr">writable:</span> <span class="hljs-literal">false</span>,<br>&#125;<span class="hljs-string">)</span><br><br><span class="hljs-string">let</span> <span class="hljs-string">objDescriptor</span> <span class="hljs-string">=</span> <span class="hljs-string">Reflect.getOwnPropertyDescriptor(obj,</span> <span class="hljs-string">&#x27;name&#x27;</span><span class="hljs-string">);</span><br><br><span class="hljs-string">/*</span><br>&#123;<br>  <span class="hljs-attr">value:</span> <span class="hljs-string">&#x27;Siri&#x27;</span>,<br>  <span class="hljs-attr">writable:</span> <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">enumerable:</span> <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">configurable:</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-string">*/</span><br><span class="hljs-string">console.log(objDescriptor);</span><br><span class="hljs-string">console.log(obj);</span> <span class="hljs-string">//</span> &#123; <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;Siri&#x27;</span> &#125;<br></code></pre></div></td></tr></table></figure><ol start="11"><li>Reflect.isExtensible(target)<br>对应 <code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展; 与 <code>Object.isExtensible</code> 区别: 如果参数不是对象，<code>Object.isExtensible</code> 会返回 false，因为非对象本来就是不可扩展的，而 <code>Reflect.isExtensible</code> 会报错;<blockquote><p>target: 目标对象, 若不是对象类型, 报错;</p></blockquote></li></ol><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">const myObj = &#123;&#125;;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>is<span class="hljs-constructor">Extensible(<span class="hljs-params">myObj</span>)</span>; <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><ol start="12"><li>Reflect.preventExtensions(target)<br>对应 <code>Object.preventExtensions</code> 方法，用于让一个对象变为不可扩展。返回一个布尔值，表示是否操作成功, 若操作成功则返回 true, 反之返回 false;<br>与 <code>Object.preventExtensions</code> 的区别: 如果参数不是对象，<code>Object.preventExtensions</code> 在 ES5 环境报错，在 ES6 环境返回传入的参数，而 <code>Reflect.preventExtensions</code> 会报错;<blockquote><p>target: 目标对象, 若不是对象类型, 报错;</p></blockquote></li></ol><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">const myObject = &#123;&#125;;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>prevent<span class="hljs-constructor">Extensible(<span class="hljs-params">myObject</span>)</span>; <span class="hljs-comment">// true</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>is<span class="hljs-constructor">Extensible(<span class="hljs-params">myObject</span>)</span>; <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><ol start="13"><li>Reflect.ownKeys(target)<br>返回对象的所有属性(用数组包裹)，基本等同于 <code>Object.getOwnPropertyNames</code> 与 <code>Object.getOwnPropertySymbols</code> 之和;<blockquote><p>target: 目标对象, 若不是对象类型, 报错;</p></blockquote></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">const obj = &#123;<br>  name: <span class="hljs-string">&#x27;Siri&#x27;</span>,<br>  age: <span class="hljs-number">18</span>,<br>  [<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;action&#x27;</span>)]: <span class="hljs-string">&#x27;eat&#x27;</span>,<br>&#125;<br><br>let arr = <span class="hljs-built_in">Reflect</span>.ownKeys(obj); <span class="hljs-regexp">//</span> [ <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-built_in">Symbol</span>(action) ]<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>codeWheels 专栏 - 轮播图</title>
    <link href="/2021/04/17/%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/17/%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>前期资料参考:</p><ul><li><a href="https://segmentfault.com/a/1190000015976690">手把手教你用原生JavaScript造轮子（二）——轮播图</a></li><li><a href="https://segmentfault.com/a/1190000022308884">手把手教你用原生JavaScript造轮子（三）——项目升级&amp;填坑&amp;重写组件</a></li><li><a href="https://github.com/csdoker/csdwheels/blob/master/src/es6/carousel/carousel.js">参考项目github地址</a></li></ul><blockquote><p>注: 将 <code>github.com</code> 改为 <code>github1s.com</code> 有奇效!</p></blockquote><h1 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h1><p><strong>github地址:</strong> <a href="https://github.com/jtwang7/codeWheels/tree/master/Carousel">Carousel</a></p><h2 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h2><h3 id="检查图片是否加载完全"><a href="#检查图片是否加载完全" class="headerlink" title="检查图片是否加载完全"></a>检查图片是否加载完全</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/ 每隔一段时间检查图片是否加载完全<br><span class="hljs-keyword">let</span> checkInterval = <span class="hljs-number">50</span>;<br><span class="hljs-keyword">let</span> checkTimer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 若全部图片加载成功, 则开始构建轮播动画</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isImagesComplete) &#123;<br>    <span class="hljs-comment">// 清除检测定时器</span><br>    <span class="hljs-built_in">clearInterval</span>(checkTimer);<br>    <span class="hljs-comment">// 初始化轮播</span><br>    <span class="hljs-built_in">this</span>.initCarousel();<br>    <span class="hljs-comment">// 初始化圆点</span><br>    <span class="hljs-built_in">this</span>.initDots();<br>    <span class="hljs-comment">// 初识化箭头</span><br>    <span class="hljs-built_in">this</span>.initArrows();<br>  &#125;<br>&#125;, checkInterval)<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">isImagesComplete</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> complete = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// children 属性: &quot;红宝书第四版 P456-457&quot;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.carouselWrap.children.length; i++) &#123;<br>    <span class="hljs-comment">// imgObject.complete 属性: &lt;img&gt; 标签会产生一个 Image 对象, 其 complete 属性返回一个布尔值, 表示浏览器是否已完成对图像的加载</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.carouselWrap.children[i].complete) &#123;<br>      complete++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> complete === <span class="hljs-built_in">this</span>.carouselWrap.children.length;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="轮播列表添加首尾过渡元素"><a href="#轮播列表添加首尾过渡元素" class="headerlink" title="轮播列表添加首尾过渡元素"></a>轮播列表添加首尾过渡元素</h3><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 获取轮播列表</span><br>get<span class="hljs-constructor">CarouselWrap()</span> &#123;<br>  <span class="hljs-comment">// 创建文档片段作为临时仓库</span><br>  <span class="hljs-comment">// DocumentFragment 类型: &quot;红宝书第四版 P424-425&quot;</span><br>  <span class="hljs-keyword">let</span> fragment = document.create<span class="hljs-constructor">DocumentFragment()</span>;<br>  <span class="hljs-comment">// Element 类型 (元素创建及属性设置): &quot;红宝书第四版 P417-419&quot;</span><br>  <span class="hljs-keyword">let</span> imgTemplate = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">img</span>&#x27;)</span>;<br>  this.options.carouselWrapImages.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each((<span class="hljs-params">imgUrl</span>, <span class="hljs-params">idx</span>)</span> =&gt; &#123;<br>    <span class="hljs-keyword">let</span> imgElement = imgTemplate.clone<span class="hljs-constructor">Node(<span class="hljs-params">false</span>)</span>;<br>    imgElement.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">class</span>&#x27;, Carousel.CLASS.CAROUSEL_IMAGE)</span>;<br>    imgElement.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">src</span>&#x27;, <span class="hljs-params">imgUrl</span>)</span>;<br>    imgElement.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">alt</span>&#x27;, <span class="hljs-params">idx</span> + 1)</span>;<br>    fragment.append<span class="hljs-constructor">Child(<span class="hljs-params">imgElement</span>)</span><br>  &#125;)<br>  <span class="hljs-comment">// 轮播列表无缝循环的关键: 首尾过渡元素</span><br>  <span class="hljs-comment">// Element Traversal API: &quot;红宝书第四版 P447&quot;</span><br>  <span class="hljs-keyword">let</span> first = fragment.firstElementChild.clone<span class="hljs-constructor">Node(<span class="hljs-params">true</span>)</span>;<br>  <span class="hljs-keyword">let</span> last = fragment.lastElementChild.clone<span class="hljs-constructor">Node(<span class="hljs-params">true</span>)</span>;<br>  fragment.insert<span class="hljs-constructor">Before(<span class="hljs-params">last</span>, <span class="hljs-params">fragment</span>.<span class="hljs-params">firstElementChild</span>)</span>;<br>  fragment.append<span class="hljs-constructor">Child(<span class="hljs-params">first</span>)</span>;<br><br>  <span class="hljs-comment">// 创建轮播列表元素</span><br>  <span class="hljs-keyword">let</span> carouselWrap = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">div</span>&#x27;)</span>;<br>  carouselWrap.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">class</span>&#x27;, Carousel.CLASS.CAROUSEL_WRAP)</span>;<br>  carouselWrap.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">id</span>&#x27;, Carousel.ID.CAROUSEL_WRAP.<span class="hljs-params">substring</span>(1)</span>);<br><br>  <span class="hljs-comment">// 转移临时文档片段内容至轮播列表</span><br>  carouselWrap.append<span class="hljs-constructor">Child(<span class="hljs-params">fragment</span>)</span>;<br>  this.set<span class="hljs-constructor">Width(<span class="hljs-params">carouselWrap</span>, <span class="hljs-params">carouselWrap</span>.<span class="hljs-params">children</span>.<span class="hljs-params">length</span> <span class="hljs-operator">*</span> <span class="hljs-params">this</span>.<span class="hljs-params">options</span>.<span class="hljs-params">carouselWidth</span>)</span>;<br><br>  return carouselWrap;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="动画效果实现"><a href="#动画效果实现" class="headerlink" title="动画效果实现"></a>动画效果实现</h3><p>主要依靠 <code>style.left</code> 和 <code>requestAnimationFrame()</code> 实现; 此外在完成动画后需要处理过渡元素;</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 动画效果实现</span><br>switch<span class="hljs-constructor">Animation(<span class="hljs-params">targetLeft</span>, <span class="hljs-params">offset</span>)</span> &#123;<br>  <span class="hljs-comment">// 标记当前处于动画状态</span><br>  this.isAnimationShow = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">let</span> currentLeft = this.get<span class="hljs-constructor">Left(<span class="hljs-params">this</span>.<span class="hljs-params">carouselWrap</span>)</span>;<br>  <span class="hljs-comment">// requesetAnimationFrame() &quot;红宝书第四版 P550-551&quot;</span><br>  this.animationTimer = request<span class="hljs-constructor">AnimationFrame(()</span> =&gt; &#123;<br>    <span class="hljs-keyword">if</span> ((offset &lt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>currentLeft &gt; targetLeft)<span class="hljs-operator"> || </span>(offset &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>currentLeft &lt; targetLeft)) &#123;<br>      <span class="hljs-comment">// 动画</span><br>      this.frame<span class="hljs-constructor">Animation(<span class="hljs-params">targetLeft</span>, <span class="hljs-params">offset</span>)</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 动画完成, 清除动画计时器, 并依据情况重置轮播列表</span><br>      clear<span class="hljs-constructor">Interval(<span class="hljs-params">this</span>.<span class="hljs-params">animationTimer</span>)</span>;<br>      this.reset<span class="hljs-constructor">CarouselWrap(<span class="hljs-params">targetLeft</span>, <span class="hljs-params">offset</span>)</span><br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 帧动画(每帧)</span><br>frame<span class="hljs-constructor">Animation(<span class="hljs-params">targetLeft</span>, <span class="hljs-params">offset</span>)</span> &#123;<br>  <span class="hljs-comment">// 图片偏移</span><br>  this.set<span class="hljs-constructor">Left(<span class="hljs-params">this</span>.<span class="hljs-params">carouselWrap</span>, <span class="hljs-params">this</span>.<span class="hljs-params">getLeft</span>(<span class="hljs-params">this</span>.<span class="hljs-params">carouselWrap</span>)</span> + offset);<br>  <span class="hljs-comment">// 动画递归</span><br>  this.switch<span class="hljs-constructor">Animation(<span class="hljs-params">targetLeft</span>, <span class="hljs-params">offset</span>)</span>;<br>&#125;<br><br>reset<span class="hljs-constructor">CarouselWrap(<span class="hljs-params">targetLeft</span>, <span class="hljs-params">offset</span>)</span> &#123;<br>  <span class="hljs-comment">// 处理过渡轮播片段</span><br>  <span class="hljs-keyword">if</span> (this.isDotClick) &#123;<br>    this.reset<span class="hljs-constructor">DotCarouselWrap(<span class="hljs-params">offset</span>)</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    this.reset<span class="hljs-constructor">MoveCarouselWrap(<span class="hljs-params">targetLeft</span>)</span>;<br>  &#125;<br>  <span class="hljs-comment">// 重置标记状态</span><br>  this.isDotClick = <span class="hljs-literal">false</span>;<br>  this.isAnimationShow = <span class="hljs-literal">false</span>;<br>&#125;<br><br>reset<span class="hljs-constructor">DotCarouselWrap(<span class="hljs-params">offset</span>)</span> &#123;<br>  <span class="hljs-comment">// 涉及了浏览器回流知识点</span><br>  <span class="hljs-comment">// 下述操作在浏览器中统一执行, 只渲染一次</span><br>  this.set<span class="hljs-constructor">Left(<span class="hljs-params">this</span>.<span class="hljs-params">carouselWrap</span>, -<span class="hljs-params">this</span>.<span class="hljs-params">options</span>.<span class="hljs-params">carouselWidth</span> <span class="hljs-operator">*</span> <span class="hljs-params">this</span>.<span class="hljs-params">dotIndex</span>)</span><br>  <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>    this.carouselWrap.remove<span class="hljs-constructor">Child(<span class="hljs-params">this</span>.<span class="hljs-params">currentNode</span>.<span class="hljs-params">nextElementSibling</span>)</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (offset &gt; <span class="hljs-number">0</span>) &#123;<br>    this.carouselWrap.remove<span class="hljs-constructor">Child(<span class="hljs-params">this</span>.<span class="hljs-params">currentNode</span>.<span class="hljs-params">previousElementSibling</span>)</span>;<br>  &#125;<br>&#125;<br><br>reset<span class="hljs-constructor">MoveCarouselWrap(<span class="hljs-params">targetLeft</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (targetLeft &lt; -this.carouselCount<span class="hljs-operator"> * </span>this.options.carouselWidth) &#123;<br>    <span class="hljs-comment">// 表明当前轮播处在最后一张过渡图片上, 需重置回第二张图片</span><br>    this.set<span class="hljs-constructor">Left(<span class="hljs-params">this</span>.<span class="hljs-params">carouselWrap</span>, -<span class="hljs-params">this</span>.<span class="hljs-params">options</span>.<span class="hljs-params">carouselWidth</span>)</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (targetLeft &gt; -this.options.carouselWidth) &#123;<br>    <span class="hljs-comment">// 表明当前轮播处在第一张过渡图片上, 需重置回倒数第二张图片</span><br>    this.set<span class="hljs-constructor">Left(<span class="hljs-params">this</span>.<span class="hljs-params">carouselWrap</span>, -<span class="hljs-params">this</span>.<span class="hljs-params">carouselCount</span> <span class="hljs-operator">*</span> <span class="hljs-params">this</span>.<span class="hljs-params">options</span>.<span class="hljs-params">carouselWidth</span>)</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="通过轮播圆点执行的动画"><a href="#通过轮播圆点执行的动画" class="headerlink" title="通过轮播圆点执行的动画"></a>通过轮播圆点执行的动画</h3><p>在轮播片段一侧插入目标副本, 实现动画后再重置到真正的目标, 并删除副本</p><figure class="highlight kotlin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs kotlin">dotChangeCarousel() &#123;<br>  <span class="hljs-keyword">this</span>.currentNode = <span class="hljs-keyword">this</span>.carouselWrap.children[<span class="hljs-keyword">this</span>.carouselIndex];<br>  <span class="hljs-keyword">this</span>.targetNode = <span class="hljs-keyword">this</span>.carouselWrap.children[<span class="hljs-keyword">this</span>.dotIndex];<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dotIndex &gt; <span class="hljs-keyword">this</span>.carouselIndex) &#123;<br>    <span class="hljs-comment">// 在当前轮播片段右侧插入目标轮播片段的副本, 用于过渡</span><br>    <span class="hljs-keyword">this</span>.carouselWrap.insertBefore(<span class="hljs-keyword">this</span>.targetNode.cloneNode(<span class="hljs-literal">true</span>), <span class="hljs-keyword">this</span>.currentNode.nextElementSibling);<br>    <span class="hljs-keyword">this</span>.switchAnimation(<br>      <span class="hljs-keyword">this</span>.getLeft(<span class="hljs-keyword">this</span>.carouselWrap) - <span class="hljs-keyword">this</span>.options.carouselWidth,<br>      -<span class="hljs-keyword">this</span>.animationOffset<br>    )<br>  &#125; <br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dotIndex &lt; <span class="hljs-keyword">this</span>.carouselIndex) &#123;<br>    <span class="hljs-keyword">this</span>.carouselWrap.insertBefore(<span class="hljs-keyword">this</span>.targetNode.cloneNode(<span class="hljs-literal">true</span>), <span class="hljs-keyword">this</span>.currentNode);<br>    <span class="hljs-keyword">this</span>.setLeft(<span class="hljs-keyword">this</span>.carouselWrap, -<span class="hljs-keyword">this</span>.options.carouselWidth * (<span class="hljs-keyword">this</span>.carouselIndex + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">this</span>.switchAnimation(<br>      <span class="hljs-keyword">this</span>.getLeft(<span class="hljs-keyword">this</span>.carouselWrap) + <span class="hljs-keyword">this</span>.options.carouselWidth,<br>      <span class="hljs-keyword">this</span>.animationOffset<br>    )<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ol><li>频繁的 DOM 操作, 性能低</li><li>动画算法不利于维护与功能拓展</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>实现轮播的动画效果, 不需要去计算每个子元素的序号以及对应的顺序变化, 因为不管哪个方向, 自始至终我们看到的都是两个子元素的移动效果, 所以只需要给这两个移动中的元素添加对应的样式即可;<br>具体实现思路: 使用 CSS3 的 transform 属性来控制子元素的位置变化, 配合transition添加过渡动画, 在 JS 代码中只需要在合适的时机添加对应的类名, 然后移出对应的类名;</p><h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><blockquote><p>出现的页码对应”JavaScript 高级程序设计(第四版)”</p></blockquote><ol><li>跨浏览器事件处理程序: “红宝书第四版 P498”</li><li>node.appendChild(): “红宝书第四版 P405-406”</li><li>document.querySelector(CSSDescription): “红宝书第四版 P445-446”</li><li>HTMLElement.style 属性及其设置方式(3种): 1. elem.style.width = value + ‘px’; 2. elem.setAttribute(‘style’, value + ‘px’); 3. elem.style.cssText = `width: ${value}px`;</li><li>parseInt(): “红宝书第四版 P37”</li><li>DocumentFragment 类型: “红宝书第四版 P424-425”</li><li>Element 类型 (元素创建及属性设置): “红宝书第四版 P417-419”</li><li>Element Traversal API: “红宝书第四版 P447”</li><li>children 属性: “红宝书第四版 P456-457”</li><li>检测标签页是否活跃</li></ol><ul><li>visibilitychange 事件类型: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilitychange_event">https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilitychange_event</a></li><li>标签页活跃性判断方法:</li><li>document.hidden : <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/hidden">https://developer.mozilla.org/zh-CN/docs/Web/API/Document/hidden</a></li><li>document.visibilityState : <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilityState">https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilityState</a></li></ul><ol start="11"><li>定时器 setInterval: “红宝书第四版 P368-369”</li><li>requesetAnimationFrame() “红宝书第四版 P550-551”</li><li>element.innerHTML 属性: P452-453</li><li>转义字符 <code>&#39;&amp;lt;&#39;</code> 与 <code>&#39;&amp;gt;&#39;</code>: 表示 ‘&lt;’ 和 ‘&gt;’</li><li>浏览器回流</li></ol>]]></content>
    
    
    <categories>
      
      <category>codeWheels</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
      <tag>codeWheels</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端工程化 - webpack 概念</title>
    <link href="/2021/04/17/webpack%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/04/17/webpack%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack-官方文档"><a href="#webpack-官方文档" class="headerlink" title="webpack 官方文档"></a>webpack 官方文档</h1><p><a href="https://www.webpackjs.com/concepts/">webpack概念</a></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>本质: webpack 是一个<strong>高度可配置</strong>的现代 <strong>JavaScript</strong> 应用程序**静态模块打包器(module bundler)**。<br>打包流程: webpack **递归构建一个依赖关系图(dependency graph)**，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。<br>核心概念: entry, output, loader, plugin;</p><h2 id="entry-入口"><a href="#entry-入口" class="headerlink" title="entry(入口)"></a>entry(入口)</h2><p>概念: webpack 构建内部依赖图的<strong>起始模块</strong>。webpack 会基于 entry 寻找与入口起点<strong>直接或间接依赖的模块和库</strong>。</p><blockquote><p>个人理解: 将 webpack 递归构建依赖关系图看作遍历树, 则 entry 本质上就是 webpack 的递归起点(树的根节点), webpack 寻找各依赖模块和库的过程, 就是遍历搜索节点间关联关系的过程;</p></blockquote><h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p><code>webpack.config.js</code> 配置: 通过配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 <code>./src</code>。</p><h4 id="单入口语法"><a href="#单入口语法" class="headerlink" title="单入口语法"></a>单入口语法</h4><p>用法：<code>entry: string|Array&lt;string&gt;</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;<br>  entry: &#123;<br>    main: <span class="hljs-string">&#x27;./src/app.js&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>简写版:</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;<br>  entry: <span class="hljs-string">&#x27;./src/app.js&#x27;</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure><p>若向 entry 属性传入「文件路径(file path)数组」, 将创建“<strong>多个同名入口</strong>”, 使得<strong>多个依赖文件</strong>一起注入，并且将它们的依赖导向(graph)到<strong>一个“chunk”</strong>。</p><blockquote><p>个人理解: 一个入口对应生成一个 chunk 打包代码块, 若传入数组, 则是将该数组内所有路径的依赖文件注入到一个 chunk 中, 执行时将它们以相同的入口名分别创建, 但注入目标都是同一个 chunk;</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;<br>  entry: [<span class="hljs-string">&#x27;./src/app.js&#x27;</span>, <span class="hljs-string">&#x27;./src/print.js&#x27;</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h4><p>用法：<code>entry: &#123;[entryChunkName: string]: string|Array&lt;string&gt;&#125;</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;<br>  entry: &#123;<br>    app: <span class="hljs-string">&#x27;./src/app.js&#x27;</span>,<br>    vendors: <span class="hljs-string">&#x27;./src/vendors.js&#x27;</span>,<br>    actions: [<span class="hljs-string">&#x27;./src/eat.js&#x27;</span>, <span class="hljs-string">&#x27;./src/move.js&#x27;</span>]<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;<br>  entry: &#123;<br>    pageOne: <span class="hljs-string">&#x27;./src/pageone.js&#x27;</span>,<br>    pageTwo: <span class="hljs-string">&#x27;./src/pagetwo.js&#x27;</span>,<br>    pageThree: <span class="hljs-string">&#x27;./src/pagethree.js&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>单入口语法其实是对象语法键名为 main 的简写;<br>webpack <strong>不同入口创建的依赖关系图彼此完全分离, 互相独立</strong>, 最终会打包成多个 bundle, 每个 bundle 中都对应一个 webpack 引导(bootstrap);</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>entry 单入口语法比较方便, 常用于单页面应用配置;<br>entry 对象语法则更具扩展性, 它可用于:</p><ol><li>应用程序入口和第三方库入口的分离(如上例 app 与 vendors(第三方库) 分离);</li><li>多页面应用;</li></ol><h2 id="output-出口"><a href="#output-出口" class="headerlink" title="output(出口)"></a>output(出口)</h2><p>概念: 整个应用程序结构被编译打包后的指定<strong>输出路径</strong>。你可以通过在配置中指定一个 output 字段，来配置这些处理过程; </p><h3 id="webpack-config-js-1"><a href="#webpack-config-js-1" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p><code>webpack.config.js</code> 配置: 通过配置 output 属性，指定 webpack 输出打包的 bundles 文件的位置, 以及如何命名这些文件, 默认值为 <code>./dist</code>。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>output 属性值接收一个对象，包括以下两点：</p><ul><li>filename: 用于输出文件的文件名</li><li>path: 目标输出目录的<strong>绝对路径</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">const <span class="hljs-built_in">path</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">output</span>: &#123;<br>    filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>将编译打包后的文件以 ‘bundle.js’ 文件名输出到 ‘./dist’ 路径;<br>path 是 Node.js 核心模块之一, 用于操作文件路径; <code>path.resolve()</code> 拼接参数并生成绝对路径, 拼接方式从右到左直到生成绝对路径为止; <code>__dirname</code> 表示当前绝对路径;</p></blockquote><h4 id="多入口起点的-output-配置"><a href="#多入口起点的-output-配置" class="headerlink" title="多入口起点的 output 配置"></a>多入口起点的 output 配置</h4><p><code>webpack.config.js</code> 中只允许指定一个 output 配置, 因此当遇到多个入口起点时, 需要通过<a href="https://www.webpackjs.com/configuration/output/#output-filename">占位符</a>实现对应 output 配置;</p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua"><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: &#123;<br>    pageOne: <span class="hljs-string">&#x27;./src/pageone.js&#x27;</span>,<br>    pageTwo: <span class="hljs-string">&#x27;./src/pagetwo.js&#x27;</span>,<br>    pageThree: <span class="hljs-string">&#x27;./src/pagethree.js&#x27;</span><br>  &#125;,<br>  <span class="hljs-built_in">output</span>: &#123;<br>    filename: <span class="hljs-string">&#x27;[name].js&#x27;</span>,<br>    <span class="hljs-built_in">path</span>: <span class="hljs-built_in">path</span>.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>占位符在 webpack 中有明文规定, 不是随意取名的, 可以将它理解为一个变量, 用 <code>[]</code> 引用; <code>[name]</code> 占位符表示入口模块的名称;</p></blockquote><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>我们已知 webpack 是 JavaScript 应用程序的静态模块打包工具, 因此 <strong>webpack 自身实际上只能理解并处理 JavaScript</strong>;<br>loader 则为 webpack 提供了<strong>处理非 JavaScript 文件</strong>的能力; 其可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后利用 webpack 的打包能力，对它们进行处理。<br>本质上，webpack loader 将所有类型的文件，<strong>转换为</strong>应用程序的依赖图（和最终的 bundle）<strong>可直接引用的模块</strong>。</p><blockquote><p>webpack loader 使代码能够通过 import 导入任何类型的模块(例如 <code>import color from &#39;style.css&#39;</code>), 即上述代码实现是需要通过 webpack loader 支持的, 只有文件被 webpack 打包后, 该行代码才能被正确识别并处理(此时非 JS 文件已经被转换为 bundle 可直接引用的模块了);</p></blockquote><h3 id="webpack-config-js-2"><a href="#webpack-config-js-2" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p>loader 在 module 属性对象的 rules 属性值内部定义，包括以下两点：</p><ul><li>test: 被 use 指定 loader 所转换的文件标志符(后缀名), 常用正则表达式作为属性值;</li><li>use: 用于转换 test 指定文件的 loader;</li></ul><figure class="highlight q"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs q">npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> css-loader<br>npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> ts-loader<br></code></pre></div></td></tr></table></figure><blockquote><p>首先通过 npm 安装对应的 loader, 常用 loader 有: style-loader, css-loader, ts-loader, file-loader 等;</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs groovy">module.exports = &#123;<br>  <span class="hljs-symbol">module:</span> &#123;<br>    <span class="hljs-symbol">rules:</span> [<br>      &#123;<span class="hljs-attr">test:</span> <span class="hljs-regexp">/\.txt$/</span>, <span class="hljs-attr">use:</span> <span class="hljs-string">&#x27;css-loader&#x27;</span>&#125;,<br>      &#123;<span class="hljs-attr">test:</span> <span class="hljs-regexp">/\.ts$/</span>, <span class="hljs-attr">use:</span> <span class="hljs-string">&#x27;ts-loader&#x27;</span>&#125;,<br>      &#123;<span class="hljs-attr">test:</span> <span class="hljs-regexp">/\.(png|jpg|gif|svg)$/</span>, <span class="hljs-attr">use:</span> <span class="hljs-string">&#x27;file-loader&#x27;</span>&#125;,<br>    ]<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>一个 loader 对应一个对象类型的配置项, 定义在 module 对象的 rules 属性值数组中;<br>正则表达式中: <code>\</code>表示转义, <code>$</code>表示末尾匹配;</p></blockquote><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>插件用于拓展 webpack 功能; webpack 插件是具有 apply 属性的 JavaScript 对象, 其 apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。</p><h3 id="webpack-config-js-3"><a href="#webpack-config-js-3" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p>想要使用一个插件，你需要先通过 npm 安装, 在 <code>webpack.config.js</code> 开头 <code>require()</code> 它，然后把它添加到 plugins 数组中。<br>插件可以携带参数/选项，在 webpack 中配置插件，需要向 plugins 属性传入 <strong>new 实例</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>); <span class="hljs-comment">// npm 安装</span><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>); <span class="hljs-comment">// webpack 内置插件</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  plugins: [<br>    <span class="hljs-keyword">new</span> webpack.optimize.UglifyJsPlugin(),<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      template: <span class="hljs-string">&#x27;./src/index.html&#x27;</span><br>    &#125;)<br>  ]<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>plugins 属性接收数组, 数组内接收插件实例;<br>插件实例可以初始化传入参数;</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>面试</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6篇 - Set &amp; Map</title>
    <link href="/2021/04/16/ES6%E7%AF%87-Set&amp;Map/"/>
    <url>/2021/04/16/ES6%E7%AF%87-Set&amp;Map/</url>
    
    <content type="html"><![CDATA[<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>成员值唯一的数据结构; 通过 Set() 构造函数生成实例;<br>Set() 构造函数可接收一个**数组(或具有 iterator 接口的其他数据结构)**作为参数进行初始化;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <span class="hljs-comment">// Set &#123; 1, 2, 3 &#125;</span><br><br><span class="hljs-keyword">const</span> arr = &#123;<br>  <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-string">&#x27;length&#x27;</span>: <span class="hljs-number">4</span>,<br>  [<span class="hljs-built_in">Symbol</span>.iterator]() &#123;<br>    <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> idx &lt; ctx.length ?<br>          &#123; <span class="hljs-attr">value</span>: ctx[idx++] &#125; :<br>          &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr); <span class="hljs-comment">// Set &#123; 1, 2, 3 &#125;</span><br></code></pre></div></td></tr></table></figure><p>Set() 内部判断两个值是否相同, 使用 <strong>“Same-value-zero equality”</strong> 算法, 其类似于严格运算符, 与 “===” 主要区别在于, <strong>“Same-value-zero equality” 算法认为 NAN 等于自身</strong>, “===” 则认为 NAN 不等于自身;</p><h2 id="Set-实例的属性"><a href="#Set-实例的属性" class="headerlink" title="Set 实例的属性"></a>Set 实例的属性</h2><ol><li><code>Set.prototype.constructor</code>: 构造函数属性, 指向 Set();</li><li><code>Set.prototype.size</code>: 返回 Set 实例的成员总数;</li></ol><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf">const <span class="hljs-built_in">set</span> = new <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>])<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Set</span>.prototype.constructor === <span class="hljs-built_in">Set</span>); <span class="hljs-comment">// true</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">set</span>.<span class="hljs-built_in">size</span>); <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure><h2 id="Set-实例的方法"><a href="#Set-实例的方法" class="headerlink" title="Set 实例的方法"></a>Set 实例的方法</h2><h3 id="Set-实例的操作方法"><a href="#Set-实例的操作方法" class="headerlink" title="Set 实例的操作方法"></a>Set 实例的操作方法</h3><ol><li><code>Set.prototype.add(value)</code>: <strong>添加</strong>某个值, <strong>返回 Set 结构本身(可链式调用)</strong>;</li><li><code>Set.prototype.delete(value)</code>: <strong>删除</strong>某个值, <strong>返回一个布尔值</strong>, 表示删除是否成功;</li><li><code>Set.prototype.has(value)</code>: <strong>返回一个布尔值</strong>, 表示该值是否为Set的成员;</li><li><code>Set.prototype.clear()</code>: <strong>清除</strong>所有成员, 没有返回值;</li></ol><figure class="highlight processing"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-built_in">set</span> = <span class="hljs-keyword">new</span> Set();<br><br><span class="hljs-built_in">set</span>.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>).<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>).<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>).<span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>);<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">set</span>.<span class="hljs-built_in">add</span>(<span class="hljs-number">6</span>)); <span class="hljs-comment">// Set &#123;1, 3, 5, 6&#125;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">set</span>.delete(<span class="hljs-number">6</span>)); <span class="hljs-comment">// true</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">set</span>.has(<span class="hljs-number">6</span>)); <span class="hljs-comment">// false</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">set</span>.<span class="hljs-built_in">clear</span>()); <span class="hljs-comment">// undefined</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">set</span>); <span class="hljs-comment">// Set &#123;&#125;</span><br></code></pre></div></td></tr></table></figure><h3 id="Set-实例的遍历方法"><a href="#Set-实例的遍历方法" class="headerlink" title="Set 实例的遍历方法"></a>Set 实例的遍历方法</h3><ol><li><code>Set.prototype.keys()</code>: 返回键名的<strong>遍历器</strong></li><li><code>Set.prototype.values()</code>: 返回键值的遍历器</li><li><code>Set.prototype.entries()</code>: 返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>: 使用回调函数遍历每个成员</li></ol><p><strong>Set 实例的遍历顺序 = 成员添加顺序</strong>, 我们可以使用 Set 作为保存回调函数的列表, 利用该特性可以保证回调函数按照添加的顺序调用;<br><strong>Set 结构键名和键值是同一个值</strong><br>Set 实例默认可被遍历, 是因为 Set 实例的 <code>[Symbol.iterator]</code> 为 values 遍历器生成函数; 这意味着可以省略 values 方法, 直接遍历 Set 实例; <code>console.log(Set.prototype[Symbol.iterator]) // [Function: values]</code></p><h2 id="Set-应用"><a href="#Set-应用" class="headerlink" title="Set 应用"></a>Set 应用</h2><ul><li>数组去重 (Set 实例 iterator 接口为 values(), 可被遍历)<figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> unique = [...new Set(arr)] <span class="hljs-comment">// ... 内部机制为 for...of</span><br><span class="hljs-keyword">const</span> unique2 = Array.<span class="hljs-keyword">from</span>(new Set(arr))<br></code></pre></div></td></tr></table></figure></li><li>并集; 交集; 差集<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-comment">// 并集</span><br><span class="hljs-keyword">const</span> union = [...new <span class="hljs-built_in">Set</span>([...arr1, ...arr2])]<br><span class="hljs-built_in">console</span>.log(union);<br><br><span class="hljs-comment">// 交集</span><br><span class="hljs-keyword">const</span> intersect = [...new <span class="hljs-built_in">Set</span>(arr1.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> arr2.includes(item)))]<br><span class="hljs-built_in">console</span>.log(intersect);<br><br><span class="hljs-comment">// 差集</span><br><span class="hljs-keyword">const</span> difference = [...new <span class="hljs-built_in">Set</span>(arr1.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !arr2.includes(item)))]<br><span class="hljs-built_in">console</span>.log(difference);<br></code></pre></div></td></tr></table></figure></li></ul><h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><p>WeakSet 与 Set 类似, 是不重复值的集合, 存在两点区别:</p><ol><li>WeakSet <strong>成员只能是对象</strong>, 不能是其他类型的值;</li><li>WeakSet 中的对象都是<strong>弱引用</strong>, 即垃圾回收机制不考虑 WeakSet 对该对象的引用; 如果其他对象都不再引用该对象, 那么垃圾回收机制会自动回收该对象所占用的内存, 不考虑该对象还存在于 WeakSet 之中;</li></ol><p>语法:<br>接收一个数组(任何具有 Iterator 接口的对象)作为参数, WeakSet() 会遍历该参数对象, 并将其所有成员作为 WeakSet 实例的成员</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> ws = new WeakSet([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]); <span class="hljs-comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span><br></code></pre></div></td></tr></table></figure><p><strong><em>注意: WeakSet 成员只能是对象类型;</em></strong></p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> ws = new WeakSet([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]) <span class="hljs-comment">// Uncaught TypeError: Invalid value used in weak set(…)</span><br></code></pre></div></td></tr></table></figure><h2 id="WeakSet-属性和方法"><a href="#WeakSet-属性和方法" class="headerlink" title="WeakSet 属性和方法"></a>WeakSet 属性和方法</h2><ol><li>WeakSet 没有 size 属性;</li><li>WeakSet 没有遍历方法;<br>原因: WeakSet 成员都是弱引用, 随时可能消失, 遍历机制无法保证成员的存在; WeakSet 的成员是不适合引用的, WeakSet 内部有多少个成员, 取决于垃圾回收机制有没有运行, 运行前后很可能成员个数是不一样的, 而垃圾回收机制何时运行是不可预测的, ES6 规定 WeakSet 不可被遍历;</li><li>WeakSet 没有 clear() 方法, 即无法清空;</li></ol><h2 id="WeakSet-应用场景"><a href="#WeakSet-应用场景" class="headerlink" title="WeakSet 应用场景"></a>WeakSet 应用场景</h2><p>临时存放一组对象, 常用于存储 DOM 节点, 不用担心节点在文档中被移除时, 引发的内存泄漏问题; (用 Set 结构存储, DOM 节点移除后, Set 仍对 DOM 保持引用, 因此会引发内存泄漏)</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>传统 Object 对象只能用字符串作为键名; ES6 为解决这一限制, 提供了 Map 数据结构, 其本质上也是键值对集合(Hash 结构), 但 Map 键的范围不局限于字符串, 可以是任何原始类型的值, 是一种更加完善的 Hash 结构实现;<br>Map 实例通过 Map() 构造函数创建, 其接受一个数组(任何具有 Iterator 接口, 且每个成员都是一个双元素的数组的数据结构, 例如 Set 实例)作为参数, 该数组成员是一个个表示键值对的数组;</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">const</span> <span class="hljs-string">map</span> <span class="hljs-string">=</span> <span class="hljs-string">new</span> <span class="hljs-string">Map([</span><br>  [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;wang&#x27;</span>]<span class="hljs-string">,</span><br>  [<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">18</span>]<span class="hljs-string">,</span><br>  [&#123;<br>    <span class="hljs-attr">&#x27;eat&#x27;:</span> <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&#x27;sleep&#x27;:</span> <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">&#x27;play&#x27;:</span> <span class="hljs-literal">false</span>,<br>  &#125;, <span class="hljs-literal">true</span>]<span class="hljs-string">,</span><br><span class="hljs-string">])</span><br><br><span class="hljs-string">/*</span><br><span class="hljs-string">Map</span> &#123;<br>  <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-string">=&gt;</span> <span class="hljs-string">&#x27;wang&#x27;</span>,<br>  <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-string">=&gt;</span> <span class="hljs-number">18</span>,<br>  &#123; <span class="hljs-attr">eat:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">sleep:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">play:</span> <span class="hljs-literal">false</span> &#125; <span class="hljs-string">=&gt;</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-string">*/</span><br></code></pre></div></td></tr></table></figure><h2 id="Map-实例的属性和方法"><a href="#Map-实例的属性和方法" class="headerlink" title="Map 实例的属性和方法"></a>Map 实例的属性和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li><code>Map.prototype.constructor</code>: 构造函数属性, 指向 Map();</li><li><code>Map.prototype.size</code>: 返回 Map 实例的成员总数;</li></ol><h3 id="Map-实例的操作方法"><a href="#Map-实例的操作方法" class="headerlink" title="Map 实例的操作方法"></a>Map 实例的操作方法</h3><ol><li><code>Map.prototype.set(key, value)</code>: 设置键名 key 对应的键值为 value, 然后<strong>返回整个 Map 结构(链式)</strong>; 如果key已经有值, 则键值会被更新, 否则就新生成该键(通过 “Same-value-zero equality” 算法判断是否存在相同的 key 值, Map 实例的 key 若为引用类型, 则保存的是引用地址, 若数据内容相同但地址不同, 则仍被视为不同的 key);</li><li><code>Map.prototype.get(key)</code>: 读取 key 对应的键值, 如果找不到 key, 返回 undefined;</li><li><code>Map.prototype.has(key)</code>: <strong>返回一个布尔值</strong>, 表示某个键是否在当前 Map 对象之中;</li><li><code>Map.prototype.delete(key)</code>: 删除某个键, 返回true; 如果删除失败, 返回false;</li><li><code>Map.prototype.clear()</code>: <strong>清除</strong>所有成员, 没有返回值;</li></ol><h3 id="Map-实例的遍历方法"><a href="#Map-实例的遍历方法" class="headerlink" title="Map 实例的遍历方法"></a>Map 实例的遍历方法</h3><ol><li><code>Map.prototype.keys()</code>: 返回键名的<strong>遍历器</strong></li><li><code>Map.prototype.values()</code>: 返回键值的遍历器</li><li><code>Map.prototype.entries()</code>: 返回键值对的遍历器</li><li><code>Map.prototype.forEach()</code>: 使用回调函数遍历每个成员</li></ol><p><strong>同 Set 一样, Map 的遍历顺序与成员添加顺序相同;</strong><br>Map 结构的 iterator 接口(<code>Symbol.iterator</code>)默认为 entires() 遍历器生成方法;</p><h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>有时我们想在某个对象上面存放一些数据, 但是这会形成对于这个对象的引用, WeakMap 对键名对象的引用都是弱引用, 当该键名对象在外界没有再被引用时, 垃圾回收机制会自动释放该键名对象所占用的内存(即键名对象和对应的键值会被自动清除);<br><strong>WeakMap 弱引用的只是键名而不是键值, 即键名对象不再被外界引用时, 才会被清除;</strong></p><figure class="highlight processing"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> WeakMap();<br>let <span class="hljs-built_in">key</span> = &#123;&#125;;<br>let obj = &#123;foo: <span class="hljs-number">1</span>&#125;;<br>wm.<span class="hljs-built_in">set</span>(<span class="hljs-built_in">key</span>, obj);<br><br>obj = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 删除对键值的引用</span><br>wm.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>); <span class="hljs-comment">// Object &#123;foo: 1&#125; 没有被垃圾回收机制清除</span><br></code></pre></div></td></tr></table></figure><ul><li>WeakMap 只接受对象作为键名 (null 除外), 不接受其它类型的值作为键名;</li><li>同理, WeakMap 没有 size 属性, 遍历方法以及 clear();</li></ul><h2 id="WeakMap-应用场景"><a href="#WeakMap-应用场景" class="headerlink" title="WeakMap 应用场景"></a>WeakMap 应用场景</h2><ol><li>存储 DOM 节点作为键名, 存储其状态作为键值;</li><li>部署私有属性;</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6篇 - Symbol</title>
    <link href="/2021/04/15/ES6%E7%AF%87-Symbol/"/>
    <url>/2021/04/15/ES6%E7%AF%87-Symbol/</url>
    
    <content type="html"><![CDATA[<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>ES6 新增的一种<strong>原始数据类型</strong>;<br>Symbol 值是<strong>独一无二</strong>的, 基于此特性, Symbol 值通常作为对象的属性名使用, 从根本上<strong>防止属性名的冲突</strong>;<br>Symbol 值不能与其他类型的值进行运算, 它可以显式转为字符串(<code>.toString()</code>), 也可转为布尔值, 但不能转为数值, 因此<strong>不能做运算操作</strong>;</p><h2 id="Symbol-创建"><a href="#Symbol-创建" class="headerlink" title="Symbol 创建"></a>Symbol 创建</h2><p>Symbol 值<strong>通过 Symbol() 函数生成</strong>;<br>Symbol() 函数<strong>不能使用 new 命令</strong>, 因为生成的 Symbol 是一个原始类型的值, 不是对象, 其不能添加属性;<br>Symbol() 函数<strong>可接受一个字符串作为参数</strong>, 该字符串用于表示 Symbol 实例的描述, 便于 Symbol 值的区分; </p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>();<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>();<br><span class="hljs-keyword">let</span> s3 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><br>s1 <span class="hljs-comment">// Symbol()</span><br>s2 <span class="hljs-comment">// Symbol(), 虽然与 s1 两者不相同, 但在显示台不能区分;</span><br>s3 <span class="hljs-comment">// Symbol(foo)</span><br></code></pre></div></td></tr></table></figure><p>Symbol 实例的描述可以通过显示转为字符串或通过 ES2019 提供的实例属性 <code>Symbol.prototype.description</code> 获得, <code>sym.description</code> 可以直接返回 Symbol 的描述;</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">const sym = Symbol(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><br>String(sym) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Symbol(foo)&quot;</span><br>sym.toString() <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Symbol(foo)&quot;</span><br>sym.description <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;foo&quot;</span>, 可以发现与显式转为字符串还是有区别的;<br></code></pre></div></td></tr></table></figure><h2 id="Symbol-用作对象属性名"><a href="#Symbol-用作对象属性名" class="headerlink" title="Symbol 用作对象属性名"></a>Symbol 用作对象属性名</h2><p>好处: 保证对象不会出现同名属性, 避免属性被改写或覆盖;<br>将 Symbol 值用于属性定义或属性调用时, Symbol 值必须放在<strong>方括号</strong>中; <strong>(Symbol 值本身被存储在变量中, 因此要符合变量调用的方式)</strong></p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> mySymbol = Symbol();<br><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  [<span class="hljs-meta">mySymbol</span>] = <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>&#125;<br><span class="hljs-comment">// 写法二</span><br>obj[mySymbol] = <span class="hljs-string">&#x27;World&#x27;</span>;<br><span class="hljs-comment">// 写法三</span><br>Object.defineProperty(obj, mySymbol, &#123; <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;Hello&#x27;</span> &#125;)<br></code></pre></div></td></tr></table></figure><p>Symbol 值作为属性名时, 属性是公开的而不是私有的:</p><ul><li>Symbol 属性名不会被 for…in, for…of 遍历, 也不会被 Object.keys(), Object.getOwnPropertyNames(), JSON.stringify() 查找; </li><li>Symbol 属性名只能被 Obeject.getOwnPropertySymbols() 和 Reflect.ownKeys() 查找, 因此它不是私有属性;</li></ul><p>基于 Symbol 值的特性(不会被常规方法遍历访问), 我们可以用 Symbol 为对象定义一些<strong>非私有的, 但只用于内部</strong>的属性;</p><figure class="highlight qml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> age = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;age&#x27;</span>);<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attribute">firstName</span>: <span class="hljs-string">&#x27;Siri&#x27;</span>,<br>  <span class="hljs-attribute">lastName</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  [age]: <span class="hljs-number">18</span>,<br>&#125;<br><br><span class="hljs-comment">// 一般的遍历无法访问到 Symbol 属性名</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;<br>  <span class="hljs-built_in">console</span>.log(key);<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * firstName</span><br><span class="hljs-comment">   * lastName</span><br><span class="hljs-comment">   */</span><br>&#125;<br><br><span class="hljs-comment">// Object.getOwnPropertySymbols() 获取指定对象的所有 Symbol 属性名并返回一个数组, 成员是当前对象的所有用作属性名的 Symbol 值</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(obj));<br><span class="hljs-comment">// [ Symbol(age) ]</span><br><br><span class="hljs-comment">// Reflect.ownKeys()方法可以返回所有类型的键名, 包括常规键名和 Symbol 键名</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.ownKeys(obj));<br><span class="hljs-comment">// [ &#x27;firstName&#x27;, &#x27;lastName&#x27;, Symbol(age) ]</span><br></code></pre></div></td></tr></table></figure><h2 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h2><p><code>Symbol.for()</code> 接收一个字符串作为参数, 它会<strong>在全局环境中搜索</strong>是否存在该参数名的 Symbol 值, 若<strong>存在</strong>, 则<strong>返回</strong>该 Symbol 值, 若<strong>不存在</strong>, 则<strong>新建</strong>一个以该字符串为名称的 Symbol 值, 并<strong>注册到全局</strong>;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;desc&#x27;</span>)<br><span class="hljs-keyword">const</span> foo1 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-keyword">const</span> foo2 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&#x27;foo&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(foo === foo1); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(foo2 === foo1); <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p><em>注: 通过 Symbol() 创建的 Symbol 值不会被登记在全局环境中, 因此不能被 Symbol.for() 搜索, 所以 <code>foo === foo1</code> 结果为 false; 通过 Symbol.for() 创建的 Symbol 值会被登记在全局环境中, <code>foo1</code> 通过 <code>Symbol.for(&#39;foo&#39;)</code> 创建后, 全局环境中被登记了一个名为 foo 的 Symbol 值, 因此 <code>foo2</code> 接收的就是该 Symbol 值, 所以两者相等;</em></p><h3 id="Symbol-for-与-Symbol"><a href="#Symbol-for-与-Symbol" class="headerlink" title="Symbol.for() 与 Symbol()"></a>Symbol.for() 与 Symbol()</h3><p>共同点: 都用于生成 Symbol 值;<br>区别: 前者会被登记在全局环境中供搜索, 后者不会;<br>Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值, 而是会先检查给定的key是否已经存在, 如果不存在才会新建一个值;<br>由于Symbol()写法没有登记机制, 所以每次调用都会返回一个不同的值</p><h2 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h2><p>返回一个已登记的 Symbol 类型值的 key;</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">const foo = <span class="hljs-constructor">Symbol(&#x27;<span class="hljs-params">desc</span>&#x27;)</span><br>const foo1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Symbol</span>.</span></span><span class="hljs-keyword">for</span>(&#x27;foo&#x27;)<br><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Symbol</span>.</span></span>key<span class="hljs-constructor">For(<span class="hljs-params">foo</span>)</span>); <span class="hljs-comment">// undefined</span><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Symbol</span>.</span></span>key<span class="hljs-constructor">For(<span class="hljs-params">foo1</span>)</span>); <span class="hljs-comment">// foo</span><br></code></pre></div></td></tr></table></figure><h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><ol><li>Symbol.hasInstance</li><li>Symbol.isConcatSpreadable</li><li>Symbol.species</li><li>Symbol.match</li><li>Symbol.replace</li><li>Symbol.search</li><li>Symbol.split</li><li>Symbol.iterator</li><li>Symbol.toPrimitive</li><li>Symbol.toStringTag</li><li>Symbol.unscopables</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6篇 - Iterator</title>
    <link href="/2021/04/15/ES6%E7%AF%87-Iterator/"/>
    <url>/2021/04/15/ES6%E7%AF%87-Iterator/</url>
    
    <content type="html"><![CDATA[<h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>参考文章: <a href="https://es6.ruanyifeng.com/#docs/iterator">ES6阮一峰 - Iterator 和 for…of 循环</a></p><h2 id="Iterator-概念"><a href="#Iterator-概念" class="headerlink" title="Iterator 概念"></a>Iterator 概念</h2><p>Iterator (遍历器<strong>对象</strong>) 是为各种数据结构(Array, Object, Map, Set, …)提供的一个统一简便的<strong>访问接口</strong>;<br>Iterator 接口主要供 ES6 的<strong>遍历</strong>命令 for…of <strong>消费</strong>, 任何部署了 Iterator 接口的数据结构都可以完成遍历操作(程序可依次处理该数据结构的所有成员);<br>Iterator 能够将数据结构的成员按照某种次序进行<strong>排序</strong>;</p><p><strong><em>Iterator 为程序遍历各种数据结构提供了统一的方法, ES6 的 for…of 通过访问和消耗 Iterator 接口, 实现对数据结构内所有成员的遍历操作</em></strong></p><p>遍历 Iterator 的过程:</p><ol><li>创建一个<strong>指针对象</strong>, 指向当前数据结构的<strong>起始位置</strong>;</li><li>调用指针对象的 <strong>next</strong> 方法, 将指针<strong>指向</strong>数据结构的第一个<strong>成员</strong>, <strong>返回成员信息</strong>; 每次调用 next 方法都会移动指针, 指向下一个成员, 并返回成员信息;</li><li>不断调用指针对象的 next 方法, 直到<strong>指向</strong>数据结构<strong>结束位置, 停止遍历</strong>;</li></ol><p><strong>注意:</strong><br><strong><em>Iterator 开始遍历时创建的指针对象, 其指向的起始位置不是数据结构的第一个成员;</em></strong><br><strong><em>Iterator 每一次调用 next 方法, 都会返回当前指向的数据结构成员的成员信息(一个包含 value 和 done 属性的对象: <code>&#123;value: any, done: boolean&#125;</code>)</em></strong><br><strong><em>Iterator 结束位置不是数据结构的最后一个成员, Iterator 遍历结束的信号是当 <code>done === true</code> 时;</em></strong></p><p><strong>Code</strong><br>要实现一个 Iterator 遍历器对象, 则主要实现三个要求:</p><ul><li>返回一个对象</li><li>对象内包含 next 方法; <strong>next() {…} 是一个无参函数</strong></li><li>next 方法返回一个 <code>&#123;value: any, done: boolean&#125;</code> 对象</li></ul><p><strong><em>Iterator 实现用到了闭包的思想, 当前遍历的索引变量被保留在了内存中, 没有随着 makeIterator 函数执行结束后上下文销毁而消失;</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeIterator</span>(<span class="hljs-params">arrayLike</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> lens = arrayLike.length;<br>  <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-comment">// done: false 和 value: undefined 可以被省略;</span><br>      <span class="hljs-keyword">return</span> idx &lt; lens ? &#123;<br>        value: arrayLike[idx++], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> <br>      &#125; : &#123;<br>        value: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Iterator 遍历操作实现:</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">const</span> <span class="hljs-string">arrayLike</span> <span class="hljs-string">=</span> &#123;<br>  <span class="hljs-attr">&#x27;0&#x27;:</span> <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>  <span class="hljs-attr">&#x27;1&#x27;:</span> <span class="hljs-string">&#x27;World&#x27;</span>,<br>  <span class="hljs-attr">&#x27;length&#x27;:</span> <span class="hljs-number">2</span>,<br>&#125;<br><span class="hljs-string">const</span> <span class="hljs-string">iterator</span> <span class="hljs-string">=</span> <span class="hljs-string">makeIterator(arrayLike);</span><br><span class="hljs-string">console.log(iterator.next());</span><br><span class="hljs-string">console.log(iterator.next());</span><br><span class="hljs-string">console.log(iterator.next());</span><br><span class="hljs-string">//</span> <span class="hljs-string">done</span> <span class="hljs-string">===</span> <span class="hljs-literal">true</span> <span class="hljs-string">后仍可以手动调用</span> <span class="hljs-string">next()</span> <span class="hljs-string">移动指针,</span> <span class="hljs-string">后续返回对象均为</span> &#123; <span class="hljs-attr">value:</span> <span class="hljs-string">undefined</span>, <span class="hljs-attr">done:</span> <span class="hljs-literal">true</span> &#125;<br><span class="hljs-string">console.log(iterator.next());</span><br><span class="hljs-string">/**</span><br> <span class="hljs-string">*</span> &#123; <span class="hljs-attr">value:</span> <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> &#125;<br> <span class="hljs-string">*</span> &#123; <span class="hljs-attr">value:</span> <span class="hljs-string">&#x27;World&#x27;</span>, <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> &#125;<br> <span class="hljs-string">*</span> &#123; <span class="hljs-attr">value:</span> <span class="hljs-string">undefined</span>, <span class="hljs-attr">done:</span> <span class="hljs-literal">true</span> &#125;<br> <span class="hljs-string">*</span> &#123; <span class="hljs-attr">value:</span> <span class="hljs-string">undefined</span>, <span class="hljs-attr">done:</span> <span class="hljs-literal">true</span> &#125;<br> <span class="hljs-string">*/</span><br></code></pre></div></td></tr></table></figure><h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>上述我们实现了手动调用 Iterator 遍历器对象的 next 方法, 模拟对数据结构所有成员的遍历过程, ES6 通过 for…of 遍历数据结构时, 会<strong>自动寻找 Iterator 接口</strong>, 我们称<strong>部署了 Iterator 接口的数据结构</strong>为”可遍历对象(Iterable)”<br><strong>注: Iterator 遍历器对象是不可以被 for…of 遍历的, 因为它只是一个指针对象, 只有部署了它的数据结构才是 for…of 遍历的目标;</strong><br>ES6 规定, 默认的 Iterator 接口要部署在数据结构的 <code>Symbol.iterator</code> 属性上; <code>Symbol.iterator</code> 属性是当前数据结构默认的<strong>遍历器生成函数</strong>; <code>Symbol.iterator</code> 是一个表达式, 返回 Symbol 对象的 iterator 属性, 作为属性名时用方括号引用;</p><p><strong><em>for…of 只能遍历实现了 Symbol.iterator 属性部署的数据结构 (若目标原型链上具有 Symbol.iterator 属性也可被遍历); for…of 每次循环调用 next 方法后, 都会检查返回值 done 属性, 若遍历未结束 done === false, 则继续调用 next 方法循环, 若检查到 done === true, 则结束遍历, 且不会将 value 赋值给临时变量;</em></strong></p><p><strong>Code</strong><br>实现一个可迭代对象(可被遍历的数据结构), 需满足以下几点:</p><ol><li>数据结构内包含 <code>Symbol.iterator</code> 属性;</li><li><code>Symbol.iterator</code> 属性值是一个<strong>函数</strong>, 返回一个<strong>遍历器对象</strong>(上述已实现)<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arrayLike = &#123;<br>  <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>  <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;World&#x27;</span>,<br>  <span class="hljs-string">&#x27;length&#x27;</span>: <span class="hljs-number">2</span>,<br>  [<span class="hljs-built_in">Symbol</span>.iterator]() &#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> idx &lt; ctx.length ?<br>          &#123; <span class="hljs-attr">value</span>: ctx[idx++], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125; :<br>          &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><p>ES6 原生具备 Iterator 接口的数据结构:</p><ol><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>arguments</li><li>NodeList</li></ol><p><strong><em>普通对象没有原生 Iterator 接口部署, 需要自己在 Symbol.iterator 属性上部署, 才能被 for…of 循环遍历; (对象 Object 之所以没有默认部署 Iterator 接口, 是因为对象属性遍历的顺序是不确定的, 需要开发者手动指定)</em></strong></p><h2 id="遍历-Iterator-接口的场景"><a href="#遍历-Iterator-接口的场景" class="headerlink" title="遍历 Iterator 接口的场景"></a>遍历 Iterator 接口的场景</h2><p>除了 for…of 循环外, 还有几个操作也要求数据结构部署 Iterator 接口;</p><ol><li>解构赋值</li><li>扩展运算符</li><li><code>yield*</code></li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()</li><li>Promise.all()</li><li>Promise.race()</li></ol><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p>ES6 遍历所有数据结构的统一方法;<br>前提: 数据结构具有 <code>Symbol.iterator</code> 属性, 即具有 iterator 接口;<br>本质: for…of 循环内部调用数据结构的 <code>Symbol.iterator</code> 方法, 其返回一个迭代器对象, 并执行 next 方法, next 方法会返回 <code>&#123;value: any, done: boolean&#125;</code> 对象, 检查是否 <code>done === true</code>, 若不是则将 value 值赋值给 for…of 临时变量, 若是则终止迭代, 且不执行赋值操作;</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法篇 - 回溯</title>
    <link href="/2021/04/10/%E7%AE%97%E6%B3%95%E7%AF%87%20-%20%E5%9B%9E%E6%BA%AF/"/>
    <url>/2021/04/10/%E7%AE%97%E6%B3%95%E7%AF%87%20-%20%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">回溯算法入门级详解</a><br><strong>回溯法:</strong> 采用试错思想, 尝试分步解决一个问题; 在分步解决问题的过程中, 当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候, 它将取消上一步甚至是上几步的计算, 再通过其它的可能的分步解答再次尝试寻找问题的答案; 回溯法通常用最简单的递归方法来实现, 在反复重复上述的步骤后可能出现两种情况:</p><ul><li>找到一个可能存在的正确的答案；</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案; </li></ul><p><strong>深度优先搜索算法(DFS):</strong> 一种用于遍历或搜索树或图的算法; 该算法会尽可能深的搜索树的分支; 当结点 v 的所在边都己被探寻过, 搜索将<strong>回溯</strong>到发现结点 v 的那条边的起始结点; 这一过程一直进行到已发现从源结点可达的所有结点为止; 如果还存在未被发现的结点, 则选择其中一个作为源结点并重复以上过程, 整个进程反复进行直到所有结点都被访问为止; </p><p>回溯法是<strong>基于深度优先搜索思想</strong>, 通过<strong>遍历</strong>实现; 因此, 回溯法也是一种暴力解法, 我们可以通过<strong>剪枝</strong>, 在遍历过程中将绝对不符合条件的分支即时剪去, 避免无意义的遍历, 从而降低回溯的成本;</p><p><strong>回溯与动态规划的区别</strong><br><strong><em>共同点</em></strong><br>用于求解多阶段决策问题; 多阶段决策问题即:</p><ul><li>求解一个问题分为很多步骤（阶段）;</li><li>每一个步骤（阶段）可以有多种选择; </li></ul><p><strong><em>不同点</em></strong></p><ul><li>动态规划用于求解问题的最优解;</li><li>回溯算法可以搜索得到所有的方案(包括最优解), 但是本质上它是一种遍历算法, 时间复杂度很高; </li></ul><h1 id="回溯的状态栈管理"><a href="#回溯的状态栈管理" class="headerlink" title="回溯的状态栈管理"></a>回溯的状态栈管理</h1><ul><li>每一个节点表示了求解排列组合问题的不同的阶段, 称之为「状态」;</li><li>「状态重置」: 将”状态变量”设置成为和先前一样, 在回到上一层节点的过程中, 需要撤销上一次的选择;</li><li>借助栈空间, 保存所需要的状态变量: 遍历往下深入时, 状态变量在状态栈尾部追加, 回退时, 撤销上一次的选择，即从栈尾部弹出状态变量; 全局只需维护一个状态栈;</li><li>一般来说, 我们仅需要维护一个保存节点的状态栈即可, 但在明确不准重复遍历已遍历节点的场景, 我们可以用一个布尔数组 used 标记已遍历的节点, 详细使用见<a href="https://leetcode-cn.com/problems/permutations-ii/solution/">全排列Ⅱ</a>;</li></ul><h1 id="回溯代码实现思路"><a href="#回溯代码实现思路" class="headerlink" title="回溯代码实现思路"></a>回溯代码实现思路</h1><p>画树形图 (明确递归结构, 递归出口, 以及剪枝部分)</p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xxx</span><span class="hljs-params">(arr)</span> </span>&#123;<br>  数组与处理 (数组长度, 数组排序...)<br><br>  声明变量存储组合结果<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backTrack</span><span class="hljs-params">(状态栈)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (递归出口条件) &#123;<br>      存储结果(注意引用类型要克隆)<br>      递归结束<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (... 循环遍历当前节点下所有组合 ...) &#123;<br>      <span class="hljs-comment">// 回溯操作的关键: 维护一个状态栈, 每次遍历时入栈, 在下一次遍历前出栈, 回溯到同一层节点;</span><br>      栈入<br>      backTrack(...)<br>      栈出<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39 - 组合总和"></a>39 - 组合总和</h2><p><a href="https://leetcode-cn.com/problems/combination-sum/submissions/">LeetCode题目地址</a><br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1.png"><br><strong>题解</strong><br>树形图:<br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-2.png"></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">/**<br> * @param &#123;number[]&#125; candidates<br> * @param &#123;number&#125; target<br> * @return &#123;number[][]&#125;<br> */<br>var combinationSum = <span class="hljs-keyword">function</span> (candidates, target) &#123;<br>  <span class="hljs-regexp">//</span> 数组排序<br>  candidates = candidates.sort((a,b)=&gt;a-b);<br>  <span class="hljs-regexp">//</span> 结果数组<br>  let res = [];<br><br>  <span class="hljs-regexp">//</span> 递归函数<br>  <span class="hljs-regexp">//</span> curSum: 当前总和<br>  <span class="hljs-regexp">//</span> combList: 当前组合列表<br>  <span class="hljs-regexp">//</span> start: 遍历的节点(去重)<br>  <span class="hljs-keyword">function</span> backTrack (curSum, combList, start) &#123;<br>    <span class="hljs-regexp">//</span> 递归出口<br>    <span class="hljs-keyword">if</span> (curSum &gt;= target) &#123;<br>      <span class="hljs-regexp">//</span> 若符合条件, 添加当前组合至结果数组<br>      <span class="hljs-regexp">//</span> (注意此处为克隆, combList 既存储当前组合又是一个状态栈)<br>      <span class="hljs-regexp">//</span> (直接存储只保留其引用地址, 最终结果会是 [], 因为状态栈最终会回溯到根节点)<br>      curSum === target &amp;&amp; res.push(combList.slice())<br>      return;<br>    &#125;<br>    <span class="hljs-regexp">//</span> 遍历当前层节点<br>    <span class="hljs-keyword">for</span> (let i=start; i&lt;candidates.length; i++) &#123;<br>      <span class="hljs-regexp">//</span> 状态栈入栈<br>      combList.push(candidates[i]);<br>      <span class="hljs-regexp">//</span> 递归(进入下一层, 下层遍历基于上层节点开始遍历, 达到去重的目的)<br>      backTrack(curSum + candidates[i], combList, i)<br>      <span class="hljs-regexp">//</span>状态栈出栈(状态重置到当前层, 遍历当前层其他节点)<br>      combList.pop();<br>    &#125;<br>  &#125;<br><br>  backTrack(<span class="hljs-number">0</span>, [], <span class="hljs-number">0</span>);<br><br>  return res;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>上述代码实现了回溯的一个基本操作, 即通过递归和遍历实现对每一层节点的判断, 同时维护一个状态栈, 实现回溯算法最关键的状态重置; (回溯是由递归 + 遍历 + 状态栈共同实现的, 本质是递归, 遍历是搜索各节点的手段, 状态栈是状态重置的关键)</strong><br><strong><em>本题剪枝思想体现在递归出口处, 当求和结果大于目标值时, 直接终止递归达到剪枝的目的</em></strong></p><h2 id="40-组合总和-Ⅱ"><a href="#40-组合总和-Ⅱ" class="headerlink" title="40 - 组合总和 Ⅱ"></a>40 - 组合总和 Ⅱ</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">LeetCode题目地址</a><br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-40%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1-1.png"><br><strong>题解</strong><br>与”39-组合总和”不同点在于去重;<br>树形图<br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-40%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1-2.png"><br><strong>解法一</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param &#123;number[]&#125; candidates</span><br><span class="hljs-comment"> * @param &#123;number&#125; target</span><br><span class="hljs-comment"> * @return &#123;number[][]&#125;</span><br><span class="hljs-comment"> */</span><br>var combinationSum2 = <span class="hljs-keyword">function</span> (candidates, target) &#123;<br>  candidates = candidates.sort((a, b) =&gt; a - b);<br>  const lens = candidates.length;<br>  const res = <span class="hljs-literal">[]</span>;<br><br>  <span class="hljs-comment">// curCandidates: 该层所遍历的数组</span><br>  <span class="hljs-keyword">function</span> back<span class="hljs-constructor">Track(<span class="hljs-params">curSum</span>, <span class="hljs-params">combList</span>, <span class="hljs-params">curCandidates</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (curSum &gt;= target) &#123;<br>      curSum<span class="hljs-operator"> === </span>target<span class="hljs-operator"> &amp;&amp; </span>res.push(combList.slice<span class="hljs-literal">()</span>);<br>      return;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; curCandidates.length; i++) &#123;<br>      <span class="hljs-comment">// 若当前节点与前一个节点相同, 会重复, 跳过该节点;</span><br>      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (curCandidates<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> === </span>curCandidates<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span>) i++;<br>      &#125;<br>      <span class="hljs-comment">// 维护状态入栈</span><br>      combList.push(curCandidates<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);<br>      <span class="hljs-comment">// 下一层遍历的数组不包含当前层已遍历的节点, 因此传入子序列作为新的遍历数组;</span><br>      back<span class="hljs-constructor">Track(<span class="hljs-params">curSum</span> + <span class="hljs-params">curCandidates</span>[<span class="hljs-params">i</span>], <span class="hljs-params">combList</span>, <span class="hljs-params">curCandidates</span>.<span class="hljs-params">slice</span>(<span class="hljs-params">i</span> + 1)</span>);<br>      <span class="hljs-comment">// 出栈</span><br>      combList.pop<span class="hljs-literal">()</span>;<br>    &#125;<br>  &#125;<br><br>  back<span class="hljs-constructor">Track(0, [], <span class="hljs-params">candidates</span>.<span class="hljs-params">slice</span>()</span>)<br><br>  return res;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>解法二</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">candidates</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">target</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> combinationSum2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">candidates, target</span>) </span>&#123;<br>  candidates = candidates.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">const</span> lens = candidates.length;<br>  <span class="hljs-keyword">let</span> res = [];<br><br>  <span class="hljs-comment">// start: 当前层开始遍历的节点索引</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backTrack</span>(<span class="hljs-params">start, curSum, combList</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (curSum &gt;= target) &#123;<br>      curSum === target &amp;&amp; res.push([...combList]);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从树形图可知, 每层递归遍历, 是从上一个节点后一节点开始的, 因此我们递归遍历下层时, 传入开始索引的位置 (start + 1)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; lens; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; candidates[i] === candidates[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>      combList.push(candidates[i]);<br>      backTrack(i + <span class="hljs-number">1</span>, curSum + candidates[i], combList);<br>      combList.pop();<br>    &#125;<br>  &#125;<br><br>  backTrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, []);<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46 - 全排列"></a>46 - 全排列</h2><p><a href="https://leetcode-cn.com/problems/permutations/">LeetCode题目地址</a><br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-46%E5%85%A8%E6%8E%92%E5%88%97-1.png"><br><strong>题解</strong><br>树形图<br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-46%E5%85%A8%E6%8E%92%E5%88%97-2.png"><br><strong>解法一</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> permute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>  nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">const</span> lens = nums.length;<br>  <span class="hljs-keyword">let</span> res = [];<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backTrack</span>(<span class="hljs-params">depth, combList</span>) </span>&#123;<br>    <span class="hljs-comment">// 递归出口</span><br>    <span class="hljs-keyword">if</span> (depth === lens) &#123;<br>      res.push(combList.slice());<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>      <span class="hljs-comment">// 所有被访问过的节点跳过;</span><br>      <span class="hljs-keyword">if</span> (combList.includes(num)) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-comment">// 入栈</span><br>      combList.push(num);<br>      <span class="hljs-comment">// 遍历下一层, 同时传入当前状态栈(状态栈同时还起到标记已访问节点的作用);</span><br>      backTrack(depth + <span class="hljs-number">1</span>, combList);<br>      <span class="hljs-comment">// 出栈</span><br>      combList.pop()<br>    &#125;<br>  &#125;<br><br>  backTrack(<span class="hljs-number">0</span>, []);<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>解法二</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> permute = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-keyword">const</span> lens = nums.length;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backTrack</span>(<span class="hljs-params">combList, used = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(lens).fill(<span class="hljs-literal">false</span>)</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (combList.length === lens) &#123;<br>      res.push([...combList]);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lens; i++) &#123;<br>      <span class="hljs-comment">// 维护一个标记栈, 若节点被访问过则将标记栈对应位置置为 true 且每层遍历判断;</span><br>      <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>      <br>      combList.push(nums[i]);<br>      <span class="hljs-comment">// 标记入栈</span><br>      used[i] = <span class="hljs-literal">true</span>;<br>      backTrack(combList, used);<br>      combList.pop();<br>      <span class="hljs-comment">// 标记出栈</span><br>      used[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  backTrack([]);<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="47-全排列Ⅱ-布尔数组标记去重"><a href="#47-全排列Ⅱ-布尔数组标记去重" class="headerlink" title="47 - 全排列Ⅱ(布尔数组标记去重)"></a>47 - 全排列Ⅱ(布尔数组标记去重)</h2><p><a href="https://leetcode-cn.com/problems/permutations-ii/">LeetCode题目地址</a><br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-47%E5%85%A8%E6%8E%92%E5%88%97%E2%85%A1-1.png"><br><strong>题解</strong><br>树形图<br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-47%E5%85%A8%E6%8E%92%E5%88%97%E2%85%A1-2.png"></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> permuteUnique = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-comment">// 维护一个布尔数组, 标记已遍历的节点</span><br>  <span class="hljs-keyword">let</span> used = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(nums.length).fill(<span class="hljs-literal">false</span>);<br>  nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backTrack</span>(<span class="hljs-params">depth, combList</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (depth === nums.length) &#123;<br>      res.push(combList.slice());<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-comment">// 注意此处 !used[i-1], 重复项剪枝在被选项剪枝之后, 因此若被选项已被剪枝, 即时该节点重复仍然可以遍历;</span><br>      <span class="hljs-keyword">if</span> ((i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) &amp;&amp; !used[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>      combList.push(nums[i]);<br>      <span class="hljs-comment">// 标记该节点</span><br>      used[i] = <span class="hljs-literal">true</span>;<br>      backTrack(depth + <span class="hljs-number">1</span>, combList);<br>      combList.pop()<br>      <span class="hljs-comment">// 回退该节点标记, 进行同层下一个节点遍历</span><br>      used[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  backTrack(<span class="hljs-number">0</span>, []);<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="78-子集-遍历索引去重"><a href="#78-子集-遍历索引去重" class="headerlink" title="78 - 子集 (遍历索引去重)"></a>78 - 子集 (遍历索引去重)</h2><p><a href="https://leetcode-cn.com/problems/subsets/">LeetCode题目地址</a><br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-78%E5%AD%90%E9%9B%86-1.png"><br><strong>题解</strong><br>树形图<br>从树形图中, 我们可以看出, 子集组合需要在每次遍历时就添加进结果数组, 每次向下遍历时, 遍历节点均不包括上一节点之前的所有节点, 因此控制索引去重;<br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-78%E5%AD%90%E9%9B%86-2.png"></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> subsets = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br>  <span class="hljs-keyword">const</span> lens = nums.length;<br>  <span class="hljs-keyword">let</span> res = [[]];<br><br>  <span class="hljs-comment">// start: 每次遍历开始位置</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backTrack</span>(<span class="hljs-params">start, combList</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (combList.length === lens) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; lens; i++) &#123;<br>      combList.push(nums[i]);<br>      <span class="hljs-comment">// 在遍历时添加每次遍历的结果</span><br>      res.push([...combList]);<br>      <span class="hljs-comment">// 从树形图可知, 每次遍历不能包含遍历过的节点, 因此记录每次遍历的索引, 下层遍历从这之后遍历;</span><br>      backTrack(i+<span class="hljs-number">1</span>, combList);<br>      combList.pop();<br>    &#125;<br>  &#125;<br><br>  backTrack(<span class="hljs-number">0</span>, []);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="90-子集Ⅱ-遍历索引去重"><a href="#90-子集Ⅱ-遍历索引去重" class="headerlink" title="90 - 子集Ⅱ (遍历索引去重)"></a>90 - 子集Ⅱ (遍历索引去重)</h2><p><a href="https://leetcode-cn.com/problems/subsets-ii/">LeetCode题目地址</a><br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-90%E5%AD%90%E9%9B%86%E2%85%A1-1.png"><br><strong>题解</strong><br>树形图<br>与 <a href="https://leetcode-cn.com/problems/subsets/">78-子集</a> 区别在于: 子集Ⅱ需要进一步去重重复的元素, 即后一个遍历节点不能与前一个节点相同 (若前一个节点没有被剪枝的化);<br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-90%E5%AD%90%E9%9B%86%E2%85%A1-2.png"></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> subsetsWithDup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> lens = nums.length;<br>  <span class="hljs-keyword">let</span> res = [[],];<br>  nums = nums.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backTrack</span>(<span class="hljs-params">start, combList</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (combList.length === lens) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 与78子集相比, 多了一个后续重复节点的判断</span><br>    <span class="hljs-comment">// 请认真研究基于 start 索引去重和基于 used 标记栈去重的区别;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; lens; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>      combList.push(nums[i]);<br>      res.push([...combList]);<br>      backTrack(i + <span class="hljs-number">1</span>, combList);<br>      combList.pop();<br>    &#125;<br>  &#125;<br><br>  backTrack(<span class="hljs-number">0</span>, []);<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>start 索引去重 &amp; used 标记栈去重:</strong> 索引去重会删除上一节点之前(具体细节可调整)的所有节点, 删除部分相对于遍历数组是连续的; 标记栈去重则是删除当前遍历分支上之前的节点, 删除部分相对于遍历数组不是连续的;<br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95.png"></p><h2 id="113-路径总和Ⅱ"><a href="#113-路径总和Ⅱ" class="headerlink" title="113 - 路径总和Ⅱ"></a>113 - 路径总和Ⅱ</h2><p><a href="https://leetcode-cn.com/problems/path-sum-ii/">LeetCode题目地址</a><br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A1-1.png"><br><strong>题解</strong><br>树形图见示例</p><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * function TreeNode(val, <span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>) &#123;<br> *     this.val = (val===undefined ? <span class="hljs-number">0</span> : val)<br> *     this.<span class="hljs-built_in">left</span> = (<span class="hljs-built_in">left</span>===undefined ? null : <span class="hljs-built_in">left</span>)<br> *     this.<span class="hljs-built_in">right</span> = (<span class="hljs-built_in">right</span>===undefined ? null : <span class="hljs-built_in">right</span>)<br> * &#125;<br> */<br>/**<br> * @param &#123;TreeNode&#125; root<br> * @param &#123;number&#125; targetSum<br> * @<span class="hljs-keyword">return</span> &#123;number[][]&#125;<br> */<br>var pathSum = function (root, targetSum) &#123;<br>  <span class="hljs-keyword">let</span> res = [];<br>  // 边界条件<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<br><br>  function backTrack(curSum, combList, curNode) &#123;<br>    curSum += curNode.val;<br>    combList.push(curNode.val);<br>    <span class="hljs-keyword">if</span> (curNode.<span class="hljs-built_in">left</span> |<span class="hljs-type">| curNode</span>.<span class="hljs-built_in">right</span>) &#123;<br>      curNode.<span class="hljs-built_in">left</span> &amp;&amp; backTrack(curSum, combList, curNode.<span class="hljs-built_in">left</span>);<br>      // curSum 值还是这层递归的值(原始类型), combList 是引用类型, 被上行递归改变了, 因此需要末尾回溯, 使得上行递归结束后重置到本层递归的 combList;<br>      curNode.<span class="hljs-built_in">right</span> &amp;&amp; backTrack(curSum, combList, curNode.<span class="hljs-built_in">right</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      // 递归出口: 当左子节点和右子节点都为 null 时, 该节点为叶子节点;<br>      curSum === targetSum &amp;&amp; res.push([...combList]);<br>    &#125;<br>    // 不需要回溯 curSum<br>    combList.pop();<br>  &#125;<br><br>  backTrack(<span class="hljs-number">0</span>, [], root);<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="131-分割回文串-涉及回溯和回文串动态规划"><a href="#131-分割回文串-涉及回溯和回文串动态规划" class="headerlink" title="131 - 分割回文串 (涉及回溯和回文串动态规划)"></a>131 - 分割回文串 (涉及回溯和回文串动态规划)</h2><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">LeetCode题目地址</a><br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-131%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-1.png"><br><strong>题解</strong><br>树形图<br><img src="/img/posts_img/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%9B%9E%E6%BA%AF-131%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-2.png"></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> partition = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> lens = s.length<br>  <span class="hljs-keyword">let</span> res = []<br>  <span class="hljs-keyword">let</span> d = <span class="hljs-built_in">Array</span>.from(&#123; <span class="hljs-attr">length</span>: lens &#125;, <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(lens).fill(<span class="hljs-literal">false</span>))<br><br>  <span class="hljs-comment">// 首先标记回文串, 相当于建立了回文串哈希表, 便于查找;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = lens - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; lens; j++) &#123;<br>      d[i][j] = s[i] === s[j] &amp;&amp; (j - i &lt; <span class="hljs-number">2</span> || d[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>])<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">backTrack</span>(<span class="hljs-params">start, combList</span>) </span>&#123;<br>    <span class="hljs-comment">// 递归出口: 遍历完字符串则退出递归</span><br>    <span class="hljs-keyword">if</span> (start === lens) &#123;<br>      res.push([...combList])<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt; lens; i++) &#123;<br>      <span class="hljs-comment">// 判断组合是否为回文串</span><br>      <span class="hljs-keyword">if</span> (!d[start][i]) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-comment">// 是回文串则添加至栈</span><br>      combList.push(s.substring(start, i + <span class="hljs-number">1</span>))<br>      backTrack(i + <span class="hljs-number">1</span>, combList);<br>      combList.pop();<br>    &#125;<br>  &#125;<br><br>  backTrack(<span class="hljs-number">0</span>, [])<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>难点:<br>回文串哈希表建立: 判断一个字符串是否为回文串, 可判断其两端字符是否相等, 再判断其去除两端后的子字符串是否为回文串, 动态规划公式建立如下:<br><code>d[i][j] = s[i] === s[j] &amp;&amp; d[i+1][j-1]</code>, 因为 i+1 &lt;= j-1, 因此边界条件为 j - i &gt;= 2;<br><code>d[i][j] = s[i] === s[j] &amp;&amp; j-i &lt; 2</code>;<br>实现动态规划时, 我们用于二维数组存放结果, 若为 true 表示该二维数组对应下标的字符串是回文串;<br>二维数组创建方法: <code>Array.from(&#123;length: lens&#125;, ()=&gt;new Array(lens))</code>, 即将一个类数组转为数组, 并对类数组内所有元素执行第二参数;<br>动态规划遍历时, 我们需要先解决最小子问题, 即我们在计算 <code>d[i][j]</code> 之前需要知道 <code>d[i+1][j-1]</code> 的值; 因此我们从后向前遍历, 每次起始遍历时, j === i, 然后逐步扩展;</p><p>回溯中, 我们将组合是否为回文串作为剪枝条件, 每次递归判断剩余字符的有序组合(例如 ‘aab’ 的有序组合为 ‘a’, ‘aa’, ‘aab’);</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面经</title>
    <link href="/2021/04/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/"/>
    <url>/2021/04/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="前端知识点"><a href="#前端知识点" class="headerlink" title="前端知识点"></a>前端知识点</h1><p><a href="https://www.nowcoder.com/discuss/258810">参考的面经地址</a></p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="原始值和引用值类型及区别"><a href="#原始值和引用值类型及区别" class="headerlink" title="原始值和引用值类型及区别"></a>原始值和引用值类型及区别</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903854882947080">你真的掌握变量和类型了吗</a><br><strong>题解</strong><br>前置知识(内存空间):<br>JS中任何变量都需要内存开辟一个空间存储.<br>内存空间: 栈内存 &amp; 堆内存.<br>栈内存:</p><ol><li>存储空间大小固定 (意味着存储的值不可改变)</li><li>空间较小</li><li>可直接操作保存的变量,运行效率高</li><li>由系统自动分配存储空间</li></ol><p>堆内存:</p><ol><li>存储大小不固定,可动态调整</li><li>空间较大, 运行效率低</li><li>无法直接操作内部存储, 通过引用地址访问</li><li>通过代码分配内存空间</li></ol><p><strong>从内存理解原始值与引用值的区别:</strong><br>原始值(Null, Undefined, Boolean, Number, String, Symbol):<br>存储于栈内存, 值本身不可被改变. (变量定义时,栈已经完成内存空间分配,且栈内存空间大小固定)<br><code>str += 6</code> 等操作不违背原始值 “不可变性” 的特点. 该操作实际是在栈中新开辟了内存空间存储新值, 并将原变量<code>str</code>指向该内存空间, 原数据内存空间若不存在引用则后续会被JS垃圾回收机制释放.</p><p>引用值(Object, Array, Function, Date,…):<br>值本身存储于堆内存, 在栈内存中存储了一个指向该值的定长地址. 引用值可被改变, 例如数组等,存在许多可改变其自身的方法(pop; push; …)</p><p><strong>从操作角度对比原始值与引用值的区别:</strong></p><ol><li><p>复制:<br>原始值复制, 栈内存中开辟新的空间存储拷贝的变量值, 由于开辟了新的空间, 因此拷贝值与被拷贝值虽然值相同, 但指向的内存空间互不相同, 两者的任何操作都是独立的, 互不影响.<br>引用值复制, 复制的是其栈内存中的地址, 栈内存新开辟一个空间存储拷贝的地址. 拷贝值与被拷贝值的地址均指向堆内存中同一对象, 因此两者操作的实际上是同一对象, 互相影响.</p></li><li><p>比较:<br>两个原始值之间比较, 直接比较它们值是否相等, 若相等则返回 <code>true</code>;<br>两个引用值之间比较, 比较它们存储在栈内存中的地址, 由于两者地址不同, 即使它们在堆内存中的存储对象具有相同属性值, 比较值仍返回 <code>false</code>;</p></li><li><p>值传递: <strong>JS所有函数的参数都是按值传递!</strong><br>原始值与引用值作为函数参数传递, 本质上传递的是变量拷贝的副本, 在函数内操作的是拷贝值而非变量背身. 两者区别在于:<br>原始值与其复制的局部变量, 两者内存空间不同, 修改局部变量不影响外部原值;<br>引用值复制的是指向堆内存的地址, 函数内修改局部变量会对外部变量造成影响;</p></li></ol><h3 id="判断数据类型的方式-typeof-instanceof-Object-prototype-toString-call-constructor"><a href="#判断数据类型的方式-typeof-instanceof-Object-prototype-toString-call-constructor" class="headerlink" title="判断数据类型的方式 typeof; instanceof; Object.prototype.toString.call(); constructor"></a>判断数据类型的方式 typeof; instanceof; Object.prototype.toString.call(); constructor</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903854882947080">你真的掌握变量和类型了吗</a><br><strong>题解</strong><br>typeof:<br>使用场景: 可准确判断变量的原始类型, 例如 <code>typeof 123 === &#39;number&#39;</code>; 还可以判断函数类型, 例如 <code>typeof function()&#123;&#125; === &#39;function&#39;</code><br>不适用于判断引用类型, 例如 <code>typeof [] === &#39;object&#39;</code>; <code>typeof &#123;&#125; === &#39;object&#39;</code>; <code>typeof new Date() === &#39;object&#39;</code></p><p>instanceof:<br>使用场景: 判断引用类型对象的具体类型, 例如 <code>[] instanceof Array === true</code><br>本质: 通过原型链判断, 上例中主要判断 Array.prototype(原型) 是否在 [] 的原型链上, 若是则返回 <code>true</code><br>缺点:</p><ol><li>由于 instanceof 是通过原型链判断的, 而 Obejct.property 是所有原型链的终点, 因此 <code>[] instanceof Object === true</code> 等总是成立, 导致在检测数据类型时不会很准确. (另一种解释是被检测目标可能更改过原型指向,导致检测不准确)</li><li>instanceof 不能检测基本数据类型</li></ol><p>Object.prototype.toString.call():<br>基本可以解决所有内置对象类型的判断问题.<br>所有引用类型均有 <code>toString()</code> 方法, <code>toString()</code> 方法默认被所有 Object 对象继承, 其包括了 Array; Date 等常见引用类型, 也包括了 String, Number 等特殊引用的包装类型. <strong><code>toString()</code> 方法若继承后没有被覆盖(重写), 则返回 <code>&quot;[object type]&quot;</code>, 其中 <code>type</code> 就是被检测对象的类型</strong><br>但是,该场景需要在<code>toString</code>方法未被重写的条件下实现, 而大多引用类型, 例如 Array; Date 等, 都对<code>toString</code>方法进行了重写. 因此, 我们在用<code>toString</code>进行类型判断时, 需直接调用 <code>Object.property</code> 原型的 <code>toString</code> 方法, 并用 <code>call</code> 改变 <code>this</code> 指向被检测目标.<br>缺点: 无法用于自定义的构造函数</p><p>constructor:<br><code>xxx.constructor === Animal</code><br>利用了对象的constructor指向构造函数的原理; 但constructor属性会被随意修改, 且容易混淆指向, 不推荐.</p><h3 id="类数组与数组的区别与转换"><a href="#类数组与数组的区别与转换" class="headerlink" title="类数组与数组的区别与转换"></a>类数组与数组的区别与转换</h3><p><strong>参考文章</strong><br><a href="https://blog.csdn.net/thunderevil35/article/details/80617907">类数组与数组</a><br><a href="https://juejin.cn/post/6844903976081555470">JS 原生面经从初级到高级 – 3.8节</a><br><a href="https://juejin.cn/post/6844903711022514184">JavaScript 类数组对象与 arguments</a><br><strong>题解</strong><br>类数组对象定义: 拥有 length 属性且可通过索引属性访问元素的对象</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> arrLike = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;bbb&#x27;</span>,<br>  length: <span class="hljs-number">2</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure><p>类数组对象与数组的相同点: 访问/赋值/获取长度等操作与数组一致<br>区别: 类数组对象不能直接使用数组方法. 因此类数组对象比数组局限性大, 通常需要将类数组转化为数组.<br>区分类数组与数组的方法:</p><ol><li>instanceof</li><li>constructor</li><li>toString()</li><li>ES提供的 isArray()</li></ol><p>类数组到数组的转化:<br>call/apply实现: 改变Array原型slice方法的this指向, 将arguments复制为新的数组; (splice方法也可以,但splice方法是在原类数组基础上做的改变,不是创建新数组)<br>Array.from: 可根据类数组或可迭代对象创建出新数组<br>… Spread语法: 将类数组扩展为字符串后,再重新定义为数组</p><ol><li><code>Array.prototype.slice.call(arguments)</code></li><li><code>Array.prototype.slice.apply(arguments)</code></li><li><code>Array.from(arguments)</code></li><li><code>[...arguments]</code></li></ol><p>除了转化外, 类数组对象还可以通过<strong>方法借用</strong>调用数组方法, 例如 <code>Array.prototype.push.call(arguments, &#39;xxx&#39;)</code> 等</p><h3 id="数组的常见API"><a href="#数组的常见API" class="headerlink" title="数组的常见API"></a>数组的常见API</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903614918459406">js 数组详细操作方法及解析合集</a><br><strong>题解</strong><br>数组原型提供了许多方法(API), 可大致分为三类: 改变原数组; 不改变原数组; 数组遍历<br>API的具体参数及作用不在本文详述, 具体可通过参考文章了解.<br>改变原数组的API(9):</p><ol><li><code>array.splice(index, num, item1,...)</code></li><li><code>array.sort(func(a,b)&#123;...&#125;)</code></li><li><code>array.pop()</code></li><li><code>array.push(item1,...)</code></li><li><code>array.shift()</code></li><li><code>array.unshift(item1,...)</code></li><li><code>array.reverse()</code></li><li><code>array.copyWithin(target, start, end)</code></li><li><code>array.fill(num, start, end)</code></li></ol><p>不改变原数组的API(8):</p><ol><li><code>array.slice(begin, end)</code></li><li><code>array.join(str)</code></li><li><code>array.toLocalString()</code></li><li><code>array.toString()</code></li><li><code>array.concat(array1,...)</code></li><li><code>array.indexOf(searchElement, fromIndex)</code></li><li><code>array.lastIndexOf(searchElement, fromIndex)</code></li><li><code>array.includes(searchElement, fromIndex)</code></li></ol><p>遍历数组(12):<br>遵循原则: 尽量不要在遍历的时候，修改后面要遍历的值; 尽量不要在遍历的时候修改数组的长度（删除/添加）</p><ol><li><code>array.forEach(function(currentValue, index, arr), thisValue)</code></li><li><code>array.every(function(currentValue, index, arr), thisValue)</code></li><li><code>array.some(function(currentValue, index, arr), thisValue)</code></li><li><code>array.filter(function(currentValue, index, arr), thisValue)</code></li><li><code>array.map(function(currentValue, index, arr), thisValue)</code></li><li><code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></li><li><code>array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue)</code></li><li><code>array.find(function(currentValue, index, arr), thisArg)</code></li><li><code>array.findIndex(function(currentValue, index, arr), thisArg)</code></li><li><code>array.keys()</code></li><li><code>array.values()</code></li><li><code>array.entries()</code></li></ol><h3 id="bind、call、apply的区别"><a href="#bind、call、apply的区别" class="headerlink" title="bind、call、apply的区别"></a>bind、call、apply的区别</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903768132157447">细说 call、apply 以及 bind 的区别和用法</a><br><a href="https://zh.javascript.info/call-apply-decorators">装饰器模式和转发，call/apply</a><br><a href="https://zh.javascript.info/bind">函数绑定</a><br><strong>题解</strong><br>call / apply 区别:<br>主要体现在参数: call 第二参数接收任何可迭代对象; apply 第二参数接收数组或类数组对象</p><p>bind / (call; apply) 区别:<br>bind 方法返回新的函数, 该函数 this 指向提供的第一参数;<br>bind 方法不会立即执行, 需要手动调用; call/apply 方法立即执行</p><p>bind / call / apply 共同点:<br>作用对象必须是一个函数, 即 <code>Function.apply()</code> 等;<br>目的是改变函数执行时的上下文;</p><h3 id="new的原理"><a href="#new的原理" class="headerlink" title="new的原理"></a>new的原理</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903789070123021">重学 JS 系列：聊聊 new 操作符</a><br><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/12">如何实现一个 new</a><br><a href="https://zh.javascript.info/prototype-methods">Object.create</a><br><strong>题解</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">const</span> test = <span class="hljs-keyword">new</span> Test(<span class="hljs-string">&#x27;Siri&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(test.name) <span class="hljs-comment">// Siri</span><br><br><span class="hljs-comment">// 2.</span><br>Test.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br>test.sayName() <span class="hljs-comment">// Siri</span><br><br><span class="hljs-comment">// 3.</span><br>fuction <span class="hljs-function"><span class="hljs-title">Test2</span>(<span class="hljs-params">name</span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test3</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-keyword">return</span> &#123;<br>    age: <span class="hljs-number">18</span>,<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> test2 = <span class="hljs-keyword">new</span> Test2(<span class="hljs-string">&#x27;Siri&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(test2.name) <span class="hljs-comment">// Siri</span><br><br><span class="hljs-keyword">const</span> test3 = <span class="hljs-keyword">new</span> Test3(<span class="hljs-string">&#x27;Siri&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(test3) <span class="hljs-comment">// &#123;age: 18&#125;</span><br><span class="hljs-built_in">console</span>.log(test3.name) <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure><p>new 作用:</p><ol><li>new 创建的实例可以访问构造函数中的属性</li><li>new 创建的实例可以访问构造函数原型中的属性, new 将实例和构造函数通过原型链连接</li><li>构造函数返回原始值, 返回值不会生效; 构造函数返回对象, 该对象有效, 返回对象会导致 new 操作符不起作用(new 操作符本质上返回了该构造函数的 this 对象)</li></ol><p>new 操作符的实现:</p><ol><li>new 操作符需要返回一个 this 对象(构造函数的 this)</li><li>为了可以访问构造函数原型, 该 this 对象需要连接构造函数构成一条原型链</li><li>返回原值时要忽略, 返回对象则正常返回</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">_new(Fn, <span class="hljs-operator">...</span><span class="hljs-params">args</span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> _this = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Fn</span>.</span></span>prototype); <span class="hljs-comment">// 通过 Object.create , 基于 Fn.prototype 原型创建空对象</span><br>  <span class="hljs-keyword">let</span> obj = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Fn</span>.</span></span>apply(_this, args); <span class="hljs-comment">// 基于 _this 空对象立即执行 Fn , 在 _this 上挂载 args 参数. Fn 可能有返回值, 创建一个 obj 变量接收</span><br>  return obj instanceof Object ? obj : _this <span class="hljs-comment">// 若返回值为对象, 则返回该对象, 否则返回 _this 对象, 这样就忽略了原始值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="如何正确判断this？"><a href="#如何正确判断this？" class="headerlink" title="如何正确判断this？"></a>如何正确判断this？</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903805587619854">嗨，你真的懂this吗？</a><br><strong>题解</strong><br>建议看完下述题解后, 参考上方文章的例子, 自己尝试分析一遍 this 指向.</p><p>this 绑定优先级: new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定<br>判断顺序如下: </p><ol><li>函数是否通过 new 绑定, 若是, 则 this 绑定创建的实例对象;</li><li>函数是否通过 call, apply, bind 绑定, 若是, 则 this 绑定第一参数指定的对象;</li><li>函数是否在某个上下文对象中调用(隐式绑定), 若是, this 绑定该上下文对象, 一般是obj.foo(), 若对象链式调用, this 指向最近的调用上下文对象; </li><li>如果以上都不是, 那么使用默认绑定; 如果在严格模式下, 则绑定到undefined, 否则绑定到全局对象;</li><li>null / undefined 作为 this 的绑定对象传入 call, apply, bind 会被忽略(无效), 此时应用默认绑定规则;</li><li>如果是箭头函数, 箭头函数的 this 继承的是外层代码块的this </li></ol><p>箭头函数 this 是动态的, 当箭头函数被使用时(JS代码执行时) this 指向才能确定, 其指向上一层代码块的 this; 个人理解: 普通函数 this 未被调用时默认指向全局, 在调用时确定指向, 其指向调用它的对象, 而箭头函数为被调用时不存在 this, 调用时 this 指向其定义位置(注意是定义区域而不是调用区域, 与普通函数差别体现在这)的上层块级作用域;<br><strong>PS: 箭头函数不能用 call/apply/bind; yield; arguments 等</strong></p><h3 id="闭包及其作用"><a href="#闭包及其作用" class="headerlink" title="闭包及其作用"></a>闭包及其作用</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903990656761864">动画：什么是闭包？</a><br><a href="https://juejin.cn/post/6844903815041253390">为了前端的深度-闭包概念与应用</a><br><a href="https://juejin.cn/post/6844903612879994887">闭包详解一</a><br><a href="https://juejin.cn/post/6844903606311714824">深入理解闭包之前置知识→作用域与词法作用域</a><br><strong>题解</strong><br>前置知识(作用于 &amp; 词法作用域):<br>作用域: 一套用于如何查找变量以及如何确定变量位置的规则. 简单理解作用域就是查找变量的地方; 作用域又分为静态作用域(词法作用域) &amp; 动态作用域;<br>作用域链: 查找变量时所遵循从下到上逐层查找的规则.<br><strong>词法作用域</strong>: 作用域的一种工作模式, 是静态的作用域. 其作用域位置由书写代码时<strong>函数声明的位置</strong>来决定的.</p><p><strong>闭包概念</strong>(网上有很多种说法, 但都大同小异):</p><ul><li>一个内部函数保持着其对外部函数词法作用域的访问权限;</li><li>一个函数对其周围状态(词法环境)的引用, 与该函数捆绑在一起的组合称为闭包;</li><li>保护一个可重用的局部变量的词法结构;</li><li>当函数可以记住并访问所在的词法作用域时, 就产生了闭包, 即使函数是在当前词法作用域之外执行; (&lt;&lt;你不知道的JavaScript&gt;&gt;)</li></ul><p>个人理解:<br>函数在书写代码时, 就已经确定了其周围的词法环境, 当函数被调用时, 会创建一个执行上下文环境, 在这里将完成一系列的变量初始化与赋值等. 当函数执行完成后, 该执行上下文环境会被销毁, 被回收机制回收, 此时若环境内的变量没有被引用, 那么会随着上下文环境一同被回收; 但是! 若在该函数执行完成后, 其内部(只有内部的情况,外部是无法访问内部变量的)仍有对该变量的引用(常见的就是内部嵌套函数, 函数回调等), 那么该变量就不会被回收.<br>综上所述, 若一个内部函数持有对其外部函数词法作用域的访问权限, 那么闭包就形成了; 广义上讲任何函数都是闭包, 最外层函数引用全局作用域的变量, 其也保持了全局作用域的访问权限, 因此也是闭包; 一般我们提及的闭包都指的是有效(能给代码产生效益)的闭包.</p><p><strong>闭包应用</strong><br>优点: <strong>保存</strong> &amp; <strong>保护</strong></p><ol><li>私有变量</li><li>回调与计时器</li><li>绑定函数上下文</li><li>偏应用函数</li><li>函数重载: 缓存记忆 / 函数包装</li><li>即时函数: 独立作用域 / 简介代码 / 循环 / 类库包装 / 通过参数限制作用域内名称</li></ol><p>缺点: 闭包信息始终会保存在内存里<br>小疑问: 函数仅对外部函数词法环境内某个变量持有引用, 其他变量仍会存在吗? 个人认为会存在, 因为变量和其环境是绑定关系(同生共死); 但是好像这些变量也无法再被利用了, 回收机制可以清除吗?</p><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903797039300615">图解原型和原型链</a><br><a href="https://juejin.cn/post/6844904093828251662">2020面试收获 - js原型及原型链</a><br><strong>题解</strong><br>仔细阅读上面两篇文章, 就能大致理解”原型/构造函数/实例/原型链/类”的概念了.<br>总结以下:</p><ol><li>原型: 是个对象, 主要作用是共享方法, 通过原型共享方法, 可以避免重复开辟内存空间的问题.</li><li>构造函数与原型的关系: <code>构造函数.prototype == 原型</code>, <code>原型.constructor == 构造函数</code></li><li>实例与原型的关系: <code>实例.__proto__ == 原型</code></li><li>原型链: 原型与原型层层链接的过程, <code>原型1.__proto__ == 原型2</code>; 作用: 使对象可以使用构造函数原型对象的属性和方法, 查找对象属性或方法时, 顺着原型链从下至上查找. <strong>实例 -&gt; 原型 -&gt; 原型 -&gt; … -&gt; null</strong></li><li>继承: 属性继承通过 call 改变 this 指向实现; 方法继承通过子类原型指向父类实例实现(将子类原型添加到原型链中)</li></ol><p>除上述总结外, 还有 new 的操作实现, ES6 类的实现等</p><h3 id="prototype与-proto-的关系与区别"><a href="#prototype与-proto-的关系与区别" class="headerlink" title="prototype与__proto__的关系与区别"></a>prototype与__proto__的关系与区别</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903713669120008">详解原型链中的prototype和 <strong>proto</strong></a><br><a href="https://juejin.cn/post/6844903869428793358"><strong>proto</strong> 和 prototype 到底有什么区别</a><br><a href="https://github.com/creeperyang/blog/issues/9">从__proto__和prototype来深入理解JS对象和原型链</a><br><a href="https://juejin.cn/post/6844903854463516685">隔壁小孩也能看懂的 7 种 JavaScript 继承实现</a><br><strong>题解</strong><br>前置知识:<br><strong>Object &amp; Function</strong><br>JS 中引用类型有很多: Object, Function, Array, Date …;<br>其中 Object, Function 是能被 typeof 识别的, 其余的本质上都是 Object 的衍生对象;<br>Function 在 JS 中被单独视为一类, 是因为它在 JS 中是所谓的一等公民, JS 中没有类的概念, 其是通过函数来模拟类的, 因此, <code>prototype</code> 是用来区分 Function 和 Object 的关键: 函数创建时, JS 会为函数自动添加 prototype 属性, 其值为一个带有 constructor 属性的对象;<br><strong><code>[[Prototype]]</code></strong><br>每个对象都有一个内部属性<code>[[Prototype]]</code>, 其用于存放该对象的原型. 通过 <code>__proto__</code> , <code>Object.getPrototypeOf/Object.setPrototypeOf</code>访问, 通过 <code>Function.prototype</code> 设置;</p><ol><li><code>__proto__</code> 存在于所有对象上, <code>prototype</code> 只存在于函数上;</li><li>每个对象都对应一个原型对象, 并从原型对象继承属性和方法, 该对应关系由 <code>__proto__</code> 实现(访问对象内部属性<code>[[Prototype]]</code>);</li><li><code>prototype</code> 用于存储共享的属性和方法, 其作用主要体现在 new 创建对象时, 为 <code>__proto__</code> 构建一个对应的原型对象(设置实例对象的内部属性<code>[[Prototype]]</code>);</li><li><code>__proto__</code> 不是 ECMAScript 语法规范的标准, 是浏览器厂商实现的一种访问和修改对象内部属性 <code>[[Prototype]]</code> 的访问器属性(getter/setter), 现常用 ECMAScript 定义的 <code>Object.getPrototypeOf</code> 和 <code>Object.setPrototypeOf</code> 代替;</li><li><code>prototype</code> 是 ECMAScript 语法规范的标准;</li></ol><p><strong>多读多看, 一时间可能难以理解</strong></p><h3 id="继承的实现方式及比较"><a href="#继承的实现方式及比较" class="headerlink" title="继承的实现方式及比较"></a>继承的实现方式及比较</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903854463516685">隔壁小孩也能看懂的 7 种 JavaScript 继承实现</a><br><a href="https://juejin.cn/post/6844903810767421447">重学 JS 系列：聊聊继承</a><br><strong>题解</strong><br>前置知识:<br>JS 中没有类的概念, 继承是通过原型链来实现的, ES6 的 class 关键字, 实际上类似于原型链模拟类的一个语法糖; JS 设计之初所有数据类型都是对象, 为了模拟类, JS 期望用 new 操作符从一个原型对象中生成一个实例对象, 实现对象间的联系; 在类中 new 会调用该类的构造函数, JS 做了简化, new 直接调用构造函数而不是类, 通过构造函数就达到了生成实例对象的目的; 但该方法有一个缺点就是无法共享属性和方法, 每个实例对象都有自己的 this; 为解决这一问题, JS 设计者为构造函数设置了 prototype 属性, 里面存储所有需要共享的属性和方法, 当实例对象被创建时, 将自动引用 prototype 的属性和方法(new 操作符内部的实现: <code>实例.__proto__ = Function.prototype</code>), 因此实例对象属性和方法可以分为本地(构造函数内定义的)和引用(构造函数原型对象定义的);<br><strong>JS 的七大继承方式</strong></p><ol><li>原型链继承: 子类原型对象指向父类实例;<br>缺点: 子类无法向父类传参; 引用类型的属性被所有实例共享<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父类 --&gt;</span><br>function Parent() &#123;<br>  this.name = &#x27;Siri&#x27;;<br>&#125;<br><span class="hljs-comment">&lt;!-- 在父类原型链上添加方法 --&gt;</span><br>Parent.prototype.callName = function () &#123;<br>  console.log(this.name)<br>&#125;<br><span class="hljs-comment">&lt;!-- 子类 --&gt;</span><br>function Child() &#123;&#125;<br><span class="hljs-comment">&lt;!-- 原型链继承 --&gt;</span><br>Child.prototype = new Parent();<br><br>const child = new Child();<br>child.callName(); // Siri<br></code></pre></div></td></tr></table></figure></li><li>构造函数继承: 调用父类构造函数, 并用 call 改变构造函数的 this 指向<br>优点: 子类可向父类传参; 各实例间属性不再被共享(每个实例都有父类的副本实现, 且都改变了 this 指向自身)<br>缺点: 由于各子类间互不相同, 导致方法不再被共享, 每个实例都创建了各自的属性和方法, 占用内存;<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父类 --&gt;</span><br>function Parent(name) &#123;<br>  this.name = [name];<br>  <span class="hljs-comment">&lt;!-- 方法添加在构造函数内 --&gt;</span><br>  this.callName = function() &#123;<br>    console.log(this.name);<br>  &#125;<br>&#125;<br><span class="hljs-comment">&lt;!-- 子类 --&gt;</span><br>function Child() &#123;<br>  <span class="hljs-comment">&lt;!-- 构造函数继承 --&gt;</span><br>  Parent.call(this, &#x27;Siri&#x27;);<br>&#125;<br><br>const child1 = new Child();<br>const child2 = new Child();<br>child1.name.push(&#x27;John&#x27;);<br><br>console.log(child1.name); // [&#x27;Siri&#x27;,&#x27;John&#x27;]<br>console.log(child2.name); // [&#x27;Siri&#x27;]<br></code></pre></div></td></tr></table></figure></li><li>组合继承: 属性通过构造函数继承, 共享方法通过原型链继承<br>优点: 各实例间属性不共享, 但能共享原型链上定义的方法<br>缺点: 调用了两次父类构造函数, 实例对象和其对应的原型对象属性重复, 在查找属性时, 会优先选择实例对象的属性, 不会到原型对象上找属性, 从而浪费了存储空间; (寄生组合式继承解决了这点, 在此之前先了解何为原型式继承和寄生式继承)<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父类 --&gt;</span><br>function Parent(name) &#123;<br>  this.name = name;<br>  this.hobbies = [&#x27;sing&#x27;,&#x27;dance&#x27;,&#x27;rap&#x27;];<br>&#125;<br>Parent.prototype.sayHi = function () &#123;<br>  console.log(&#x27;Hi&#x27; this.name);<br>&#125;<br><span class="hljs-comment">&lt;!-- 子类 --&gt;</span><br>function Child(age) &#123;<br>  <span class="hljs-comment">&lt;!-- 构造函数继承 --&gt;</span><br>  Parent.call(this, &#x27;Siri&#x27;);<br>  this.age = age;<br>&#125;<br><span class="hljs-comment">&lt;!-- 原型链继承 --&gt;</span><br><span class="hljs-comment">&lt;!-- 第一次父类构造函数调用 --&gt;</span><br>Child.prototype = new Parent();<br><br><span class="hljs-comment">&lt;!-- 第二次父类构造函数调用 --&gt;</span><br>const child = new Child(18);<br></code></pre></div></td></tr></table></figure></li><li>原型式继承: 将传入对象作为原型, 创建实例对象<br>ESMAScript5 中用 Object.create(prototype) 规范了原型式继承<figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObj</span><span class="hljs-params">(obj)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>  F.prototype = obj;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();<br>&#125;<br><span class="hljs-keyword">const</span> person = &#123;<br>  name: <span class="hljs-string">&#x27;Siri&#x27;</span>,<br>  age: <span class="hljs-number">18</span>,<br>&#125;<br><span class="hljs-keyword">const</span> person1 = createObj(person);<br></code></pre></div></td></tr></table></figure></li><li>寄生式继承: 创建一个函数封装继承过程, 并可扩展额外功能, 返回继承后的对象;<br>与构造函数继承类似, 返回的对象间不共享属性方法;<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObj</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> tmp = <span class="hljs-built_in">Object</span>.create(obj);<br>  tmp.callName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-keyword">const</span> person = &#123;<br>  name: <span class="hljs-string">&#x27;Siri&#x27;</span>,<br>  age: <span class="hljs-number">18</span>,<br>&#125;<br><span class="hljs-keyword">const</span> person1 = createObj(person);<br></code></pre></div></td></tr></table></figure></li><li>寄生组合式继承: 利用空函数作为媒介, 避免了多次调用父类构造函数;<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">function Parent(name) &#123;<br>  this.name = name<br>  this.hobbies = [&#x27;sing&#x27;,&#x27;dance&#x27;,&#x27;rap&#x27;];<br>&#125;<br>function Child(age) &#123;<br>  <span class="hljs-comment">&lt;!-- 构造函数继承 --&gt;</span><br>  Parent.call(this, &#x27;Siri&#x27;);<br>  this.age = age;<br>&#125;<br><span class="hljs-comment">&lt;!-- 寄生式继承 --&gt;</span><br><span class="hljs-comment">&lt;!-- 用临时的空函数充当子类和父类原型链继承的媒介 --&gt;</span><br><span class="hljs-comment">&lt;!-- 与原型链继承相比, tmp 临时函数在 new 调用后就销毁, 因此 Child 既指向了父类原型对象, 又避免多次调用父类构造函数(因为仅用到了父类原型对象, 父类内部属性没有被创建), 创建不必要的属性 --&gt;</span><br>const tmp = function() &#123;&#125;;<br>tmp.prototype = Parent.prototype;<br>Child.prototype = new tmp();<br><br>const child = new Child();<br></code></pre></div></td></tr></table></figure></li><li>ES6 extends 继承: 在后续 ES6 知识点中详细讲解;</li></ol><h3 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844904197595332622">浅拷贝与深拷贝</a><br><a href="https://segmentfault.com/a/1190000020255831">如何写出一个惊艳面试官的深拷贝?</a><br><strong>题解</strong><br>以下概念都针对引用类型:<br>赋值: 将对象赋值给新变量, 复制的是对象在栈中的地址, 新变量与对象指向同一堆内存数据, 两者相互联动;<br>浅拷贝: 在堆内存中开辟新的内存存储拷贝的对象, 拷贝前后对象在堆中内存空间不同, 其基本数据类型互不影响, 但其引用类型共享同一块内存, 相互影响;<br>深拷贝: 在堆内存中开辟新的内存存储拷贝的对象, 拷贝对象内若存在子对象, 则进行递归拷贝, 拷贝前后对象互不影响;<br><strong>浅拷贝实现</strong></p><ol><li>Object.assign(): 将任意多个源对象的可枚举属性拷贝给目标对象, 并将目标对象返回;<figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- 源对象 --&gt;</span></span><br><span class="xml">let obj1 = </span><span class="hljs-template-variable">&#123; person: &#123;name: &quot;kobe&quot;, age: 41&#125;</span><span class="xml">,sports:&#x27;basketball&#x27; &#125;;</span><br><span class="xml"><span class="hljs-comment">&lt;!-- 浅拷贝, 返回对象由 obj2 接收 --&gt;</span></span><br><span class="xml">let obj2 = Object.assign(</span><span class="hljs-template-variable">&#123;&#125;</span><span class="xml">, obj1)</span><br></code></pre></div></td></tr></table></figure></li><li>函数库 lodash 的 <code>_.clone()</code> 方法<figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- 引入 lodash 库 --&gt;</span></span><br><span class="xml">const _ = require(&#x27;lodash&#x27;);</span><br><span class="xml"><span class="hljs-comment">&lt;!-- 源对象 --&gt;</span></span><br><span class="xml">let obj1 = </span><span class="hljs-template-variable">&#123; person: &#123;name: &quot;kobe&quot;, age: 41&#125;</span><span class="xml">,sports:&#x27;basketball&#x27; &#125;;</span><br><span class="xml"><span class="hljs-comment">&lt;!-- 浅拷贝 --&gt;</span></span><br><span class="xml">let obj2 = _.clone(obj1)</span><br></code></pre></div></td></tr></table></figure></li><li>展开运算符 <code>...</code>: 将对象展开, 再创建一个空对象包裹, 重新组合成对象<figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- 源对象 --&gt;</span></span><br><span class="xml">let obj1 = </span><span class="hljs-template-variable">&#123; person: &#123;name: &quot;kobe&quot;, age: 41&#125;</span><span class="xml">,sports:&#x27;basketball&#x27; &#125;;</span><br><span class="xml"><span class="hljs-comment">&lt;!-- 浅拷贝 --&gt;</span></span><br><span class="xml">let obj2 = </span><span class="hljs-template-variable">&#123;...obj1&#125;</span><br></code></pre></div></td></tr></table></figure></li><li>Array.prototype.concat(): 数组的浅拷贝<figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;username: &#x27;kobe&#x27;&#125;];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span> = arr1.concat();<br></code></pre></div></td></tr></table></figure></li><li>Array.prototype.slice(): 数组的浅拷贝<figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">arr1</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;username: &#x27;kobe&#x27;&#125;];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr2</span> = arr1.slice();<br></code></pre></div></td></tr></table></figure></li></ol><p><strong>深拷贝实现</strong></p><ol><li>JSON.parse(JSON.stringify()): 利用JSON.stringify将对象转成JSON字符串, 再用JSON.parse把字符串解析成对象, 产生新对象, 而且对象会开辟新的内存空间，实现深拷贝;<br>缺点: 不能处理对象内的函数和正则等, 会变成 null;<figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- 源对象 --&gt;</span></span><br><span class="xml">let obj1 = </span><span class="hljs-template-variable">&#123; person: &#123;name: &quot;kobe&quot;, age: 41&#125;</span><span class="xml">,sports:&#x27;basketball&#x27; &#125;;</span><br><span class="xml"><span class="hljs-comment">&lt;!-- 深拷贝 --&gt;</span></span><br><span class="xml">let obj2 = JSON.parse(JSON.stringify(obj1));</span><br></code></pre></div></td></tr></table></figure></li><li>函数库 lodash 的 <code>_.cloneDeep()</code> 方法<figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- 源对象 --&gt;</span></span><br><span class="xml">let obj1 = </span><span class="hljs-template-variable">&#123; person: &#123;name: &quot;kobe&quot;, age: 41&#125;</span><span class="xml">,sports:&#x27;basketball&#x27; &#125;;</span><br><span class="xml"><span class="hljs-comment">&lt;!-- 深拷贝 --&gt;</span></span><br><span class="xml">let obj2 = _.cloneDeep(obj1);</span><br></code></pre></div></td></tr></table></figure></li></ol><p><strong>手撕浅拷贝 / 深拷贝</strong></p><ol><li>浅拷贝:<figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> clone(obj) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">copy</span> = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-built_in">[key</span>,<span class="hljs-keyword">value</span>] <span class="hljs-keyword">of</span> Object.entries(obj)) &#123;<br>    <span class="hljs-keyword">copy</span><span class="hljs-built_in">[key</span>] = <span class="hljs-keyword">value</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">copy</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>简易版深拷贝:<br>未解决”循环引用”问题<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> deep<span class="hljs-constructor">Clone(<span class="hljs-params">target</span>)</span> &#123;<br>  <span class="hljs-comment">// 递归终止条件</span><br>  <span class="hljs-keyword">if</span> (typeof target<span class="hljs-operator"> === </span>&#x27;<span class="hljs-keyword">object</span>&#x27;) &#123;<br>    <span class="hljs-comment">// 这部分其实就是浅拷贝</span><br>    <span class="hljs-comment">// 判断是否为数组</span><br>    <span class="hljs-keyword">let</span> obj = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">target</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-literal">[<span class="hljs-identifier">key</span>, <span class="hljs-identifier">value</span>]</span> <span class="hljs-keyword">of</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>entries(target)) &#123;<br>      <span class="hljs-comment">// 此处需要继续判断 value 是不是 object, 因此递归写在这里, obj[key] 收集递归值</span><br>      obj<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = deep<span class="hljs-constructor">Clone(<span class="hljs-params">value</span>)</span>;<br>    &#125;<br>    <span class="hljs-comment">// 返回递归值</span><br>    return obj;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    return target;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>完整版深拷贝:<br>简易版深拷贝没有考虑对象内调用自身的情况, 会出现”循环引用”, 结果就是死循环导致栈内存溢出<br>“循环引用” 解决方案:<br>额外开辟一个存储空间，存储当前对象和拷贝对象的对应关系, Map 是比较好的选择;<br>当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝;<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> deep<span class="hljs-constructor">Clone(<span class="hljs-params">target</span>, <span class="hljs-params">map</span> = <span class="hljs-params">new</span> Map()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (typeof target<span class="hljs-operator"> === </span>&#x27;<span class="hljs-keyword">object</span>&#x27;) &#123;<br>    <span class="hljs-keyword">let</span> obj = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">target</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-literal">[<span class="hljs-identifier">key</span>, <span class="hljs-identifier">value</span>]</span> <span class="hljs-keyword">of</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>entries(target)) &#123;<br>      <span class="hljs-comment">// value 是被拷贝的对象, 检查它是否存在(被拷贝过), 若存在则直接返回该值, 不需要拷贝;</span><br>      <span class="hljs-keyword">if</span> (map.get(value)) &#123;<br>        return value;<br>      &#125;<br>      <span class="hljs-comment">// 若不存在, 则将其添加至索引表, 并对其深拷贝; </span><br>      <span class="hljs-comment">// 此处 obj 刚传入时是空对象, 但由于是引用, 所以后续改变 obj 也会更新表内的值;</span><br>      map.set(value, obj);<br>      <span class="hljs-comment">// 注意传入 map</span><br>      obj<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = deep<span class="hljs-constructor">Clone(<span class="hljs-params">value</span>, <span class="hljs-params">map</span>)</span>;<br>    &#125;<br>    return obj;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    return target;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903651278848014">函数防抖和节流</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/22">JavaScript专题之跟着underscore学防抖</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/26">JavaScript专题之跟着 underscore 学节流</a><br><a href="https://github.com/Bulandent/blog/issues/28">死磕 36 个 JS 手写题</a><br><strong>题解</strong><br>应用场景: 进行窗口 resize, scroll, 输入框内容校验等操作时, 频繁触发绑定事件函数, 导致页面频繁重渲染, 加重浏览器负担<br>防抖与节流的类似作用: 减少触发的频率<br><strong>防抖</strong><br>触发事件后 n 秒后才执行函数, 如果在 n 秒计时期间又触发了事件, 则重新计算函数执行时间;</p><ol><li>简易版防抖:<figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">// 外层封装, 形成闭包;<br>function debounce (<span class="hljs-keyword">func</span>, wait) &#123;<br>  <span class="hljs-keyword">let</span> timer = null;<br>  // 返回真正用于绑定触发事件的函数;<br>  <span class="hljs-keyword">return</span> function() &#123;<br>    // 存储 this 指向: this 指向触发函数的事件对象;<br>    <span class="hljs-keyword">const</span> context = this;<br>    <span class="hljs-keyword">const</span> args = [...arguments]<br>    // 函数触发时, 先清除计时器, 停止之前正在计时的函数;<br>    clearTimeout(timer);<br>    // 重新设置计时器;<br>    timer = setTimeout(()=&gt;&#123;<br>      // 此处 apply 重新设置 this 是必要的, 尽管箭头函数 this 指向 function() <span class="hljs-meta">&#123;...&#125;</span> 的 this;<br>      // function() <span class="hljs-meta">&#123;...&#125;</span> 触发时 this 就是事件对象;<br>      // 但是执行的 <span class="hljs-keyword">func</span> this 指向不能明确, 所以要 apply 强制指向事件对象;<br>      <span class="hljs-keyword">func</span>.apply(context, args);<br>    &#125;, wait);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>完整版防抖(支持立即执行/支持函数返回值/支持取消功能)<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait, immediate = <span class="hljs-literal">false</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>, result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> mainFunc =  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">const</span> args = [...arguments];<br><br>    <span class="hljs-keyword">if</span> (timer) &#123; <span class="hljs-built_in">clearTimeout</span>(timer) &#125;;<br>    <span class="hljs-keyword">if</span> (immediate) &#123;<br>      <span class="hljs-comment">// 立即执行: 和非立即执行(简易版)相反即可;</span><br>      <span class="hljs-comment">// 当 timer 为 null 时, 可立即执行; 同时创建计时器, 计时完成后再将 timer 置为 null;</span><br>      <span class="hljs-keyword">let</span> callNow = !timer;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;, wait);<br>      <span class="hljs-keyword">if</span> (callNow) &#123;<br>        <span class="hljs-comment">// 立即执行可以返回函数值, 非立即执行不可以;</span><br>        <span class="hljs-comment">// 因为 setTimeout() 中还未完成 result 赋值, result 就被返回了, 值为 undefined;</span><br>        result = func.apply(context, args);<br>      &#125; <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 同简易版防抖</span><br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        func.apply(context, args);<br>      &#125;, wait)<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-comment">// 取消防抖功能</span><br>  mainFunc.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 清除现有计时器, 并将计时器初始化为null;</span><br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// console.log(timer);</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> mainFunc;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><p><strong>节流</strong><br>连续触发事件但是在 n 秒中只执行一次函数, 节流会稀释函数的执行频率;<br><strong>与防抖区别在于, 防抖的计时器会刷新, 只执行最后一次</strong></p><ol><li>简易版节流:<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 时间戳节流法: 立即执行第一次</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>  <span class="hljs-comment">// 初始化时间</span><br>  <span class="hljs-keyword">let</span> time = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">const</span> args = [...arguments];<br><br>    <span class="hljs-comment">// 获得当前时间戳</span><br>    <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>    <span class="hljs-comment">// 时间差 &gt; 阈值, 则触发函数; 由于第一次的时间差必定大于阈值, 所以第一次立即执行</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">now - time &gt; wait</span>)</span> &#123;<br>      <span class="hljs-comment">// console.log(now);</span><br>      func.apply(context, args);<br>      <span class="hljs-comment">// 更新时间戳</span><br>      time = now;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 定时器节流法: 停止后执行最后一次</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle2</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">const</span> args = [...arguments];<br><br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        timer = <span class="hljs-literal">null</span>;<br>        func.apply(context, args);<br>      &#125;, wait);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>完整版节流:<br>逻辑有点绕, 可先实现时间戳和计时器, 再整理它们的逻辑, 在时间戳计时器执行时屏蔽计时器(清除), 在计时器执行时屏蔽时间戳(重置时间戳);<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>  <span class="hljs-comment">// 计时器和时间戳初始化</span><br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>, pre = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">const</span> mainFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">let</span> args = [...arguments];<br><br>    <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>    <span class="hljs-comment">// 此处逻辑可能有点绕, 可以先把时间戳和计时器的实现都先写出来, 再调整逻辑</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">now - pre &gt; wait</span>)</span> &#123;<br>      <span class="hljs-comment">// 执行时间戳, 则屏蔽计时器方法, 即清除计时器并置为 null</span><br>      <span class="hljs-keyword">if</span> (timer) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-comment">// 正常的时间戳方法</span><br>      func.apply(context, args);<br>      pre = now;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer) &#123;<br>      <span class="hljs-comment">// 若时间戳不执行了, 此时 timer 为 null, 触发计时器方法执行</span><br>      <span class="hljs-comment">// 注意: 计时器计时时间是剩余时间而不是设置的阈值</span><br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-comment">// 重置时间戳</span><br>        pre = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><br>        timer = <span class="hljs-literal">null</span>;<br>        func.apply(context, args);<br>      &#125;, wait-(now - pre))<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> mainFunc<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>进阶版节流:<br>可控制是否第一次立即执行, 以及是否在末尾执行回调;<br>方法: 设置个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定:<br>leading：false 表示禁用第一次执行<br>trailing: false 表示禁用停止触发的回调<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, wait, options=&#123;&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>, pre = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 不能同时设置禁用第一次执行和末尾回调</span><br>  <span class="hljs-keyword">if</span> ((options.leading === <span class="hljs-literal">false</span>) &amp;&amp; (options.trailing === <span class="hljs-literal">false</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;options 参数不能同时为 true&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> mainFunc =  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">const</span> args = [...arguments];<br><br>    <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>    <span class="hljs-comment">// 通过控制 pre 来控制是否第一次执行</span><br>    <span class="hljs-comment">// 当 pre == 0 且禁用第一次执行时, 让 pre == now, 就不执行第一次的时间戳方法了</span><br>    <span class="hljs-comment">// pre == 0 用于区分第一次时间戳方法和后续时间戳方法, 若只有 options.leading === false, 时间戳就被永久禁用了</span><br>    <span class="hljs-keyword">if</span> (!pre &amp;&amp; options.leading === <span class="hljs-literal">false</span>) pre = now;<br>    <span class="hljs-keyword">if</span> (now - pre &gt; wait) &#123;<br>      <span class="hljs-comment">// 重置计时器方法</span><br>      <span class="hljs-keyword">if</span> (timer) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;<br>      func.apply(context, args);<br>      pre = now;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer &amp;&amp; options.trailing !== <span class="hljs-literal">false</span>) &#123;<br>      <span class="hljs-comment">// options.trailing !== false 时才开放计时器方法</span><br>      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-comment">// 重置时间戳方法</span><br>        <span class="hljs-comment">// 当禁用第一次执行时, 时间戳要重置回 0</span><br>        pre = options.leading === <span class="hljs-literal">false</span> ? <span class="hljs-number">0</span> : +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br>        <span class="hljs-comment">// timer 类似于开关, null 时表示可以执行下一次回调了</span><br>        timer = <span class="hljs-literal">null</span>;<br>        func.apply(context, args)<br>      &#125;, wait-(now-pre))<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 取消节流功能: 参数初始化</span><br>  mainFunc.cancel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> mainFunc;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="作用域和作用域链、执行期上下文"><a href="#作用域和作用域链、执行期上下文" class="headerlink" title="作用域和作用域链、执行期上下文"></a>作用域和作用域链、执行期上下文</h3><p><strong>参考文章</strong><br><a href="https://segmentfault.com/a/1190000018513150">深入理解JavaScript作用域和作用域链</a><br><a href="https://segmentfault.com/a/1190000018550118">深入理解JavaScript执行上下文和执行栈</a><br><a href="https://segmentfault.com/a/1190000012646221">前端基础进阶（四）：详细图解作用域链与闭包</a><br><a href="https://juejin.cn/post/6844903682283143181">理解 JavaScript 中的执行上下文和执行栈</a><br><strong>题解</strong><br><strong>作用域(块级作用域 / 全局作用域 / 函数作用域)</strong><br>作用域概念: 程序源代码中定义变量的区域; 它是一套规则, 规定了如何在当前作用域与自己作用域中查找变量;<br>作用域作用: 隔离变量;<br>词法作用域: 静态作用域, 在书写代码时根据变量和块作用域定义的位置决定;<br><strong>全局作用域</strong><br>全局作用域有且只有一个, 定义在全局作用域中的变量可在代码任何地方被访问;<br>全局作用域弊端: 变量命名冲突, 易污染全局命名空间;</p><ul><li>最外层函数</li><li>最外层函数外定义的变量</li><li>所有未定义直接赋值的变量</li><li>所有 window 对象的属性</li></ul><p><strong>函数作用域</strong><br>函数定义时确定的变量区域, 其内部定义的变量只能在该函数内被调用;</p><p><strong>块级作用域</strong><br>在任何代码块内部(一对花括号包裹)都会创建一个块级作用域;<br>ES6 块级作用域特点:</p><ul><li>变量声明不会提升</li><li>禁止重复声明</li></ul><p><strong>执行上下文</strong><br>前置知识:<br>JS 代码运行分为两个阶段: <strong>编译阶段</strong> &amp; <strong>执行阶段</strong><br>编译阶段由编译器完成, 将代码翻译成可执行代码, 在该阶段完成了”词法分析; 语法分析; 作用域规则确定”;<br>执行阶段由引擎完成, 主要完成可执行代码的执行操作, 该阶段完成了”执行上下文创建; 执行函数代码; 垃圾回收”;<br><strong>概念:</strong> JS 代码执行时所在的环境; JS 所有代码都在执行上下文中运行;<br><strong>生命周期:</strong></p><ol><li>创建: 创建变量对象(初始化函数参数, arguments, 函数声明提升, 变量声明提升) -&gt; <strong>创建作用域链</strong> -&gt; 确定 this 指向 / 全局执行上下文是: 创建全局对象(浏览器中为 window 对象) -&gt; this 指向该全局对象</li><li>执行: 变量赋值, 执行代码</li><li>回收: 一段代码执行完毕后, 从执行上下文出栈, 等待回收执行上下文;</li></ol><p><strong>类型:</strong><br>全局上下文和函数执行上下文的区别: 作用区域不同; 函数执行上下文额外有 this, argument 和函数参数;</p><ol><li>全局执行上下文(有且只有一个): 任何不在调用函数中的代码都位于全局执行上下文中; </li><li>函数执行上下文: 在函数被调用时创建, 每个调用函数对应一个执行上下文;</li><li>Eval函数执行上下文: 不常用, 不做讨论;</li></ol><ul><li><strong>变量提升细节</strong><br>变量提升发生在执行上下文创建过程中: 先把代码中即将执行的变量/函数声明都拿出来; 变量先暂时赋值为<code>undefined</code>, 函数则先声明好可使用, 然后变量提升(当函数和变量同名且都会被提升, 函数声明优先级比较高, 因此变量声明会被函数声明所覆盖, 但是可以重新赋值); </li><li><strong>确定 this 指向细节</strong><br>this 在执行上下文创建过程中才能确定, 函数定义的时候是不能确认的;<br>确定 this 的方法: new 绑定 &gt; apply/bind 绑定 &gt; 隐式绑定 &gt; 默认绑定; 箭头函数 this 指向其定义时的上层块级作用域;</li><li><strong>执行上下文栈细节</strong><br>多个函数被调用时会产生多个函数执行上下文, JS 执行在单线程上, 所有代码需要排队进行, 因此需要一个管理函数执行上下文的数据结构;<br>JS 引擎采用栈结构管理执行上下文, <strong>执行上下文栈是一个存储函数调用的栈结构, 遵循先进后出的原则</strong>;<br>栈执行上下文压入顺序: 全局执行上下文 -&gt; 函数执行上下文1 -&gt; 函数执行上下文2 -&gt; …<br>栈执行上下文弹出顺序: … -&gt; 函数执行上下文2(出栈,等待回收) -&gt; 函数执行上下文1(出栈,等待回收) -&gt; 全局执行上下文(在浏览器关闭时出栈)<br>即 JS 执行引擎总是访问栈顶的执行上下文; </li></ul><p><strong>作用域链</strong><br>作用域链之所以放在最后讲, 是因为作用域链是在执行上下文中被创建的, 其发生在创建变量对象之后, 包含变量对象并用于解析变量, 变量解析遵循从最内层嵌套代码不断向上层环境查找(也有文章说是父级作用域)的规则, 直到找到该变量, 若未找到则报错;<br>抽象概念: 作用域链是由当前环境与上层环境的一系列变量对象组成, 它保证了当前执行环境对符合访问权限的变量和函数的有序访问;<br>上层环境和父级作用域的讨论: 个人认为上层环境和父级作用域都可以, 只是理解的角度不同, 如下例代码:</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 全局变量 --&gt;</span><br>let a = 10;<br><br>function print() &#123;<br>  console.log(a);<br>&#125;<br><br>function border1() &#123;<br>  let a = 20;<br>  print();<br>&#125;<br><br>border1(); // 10<br></code></pre></div></td></tr></table></figure><p>若以上层环境理解: 由于 print 函数直接执行, this 默认指向全局作用域, 因此 a == 10;<br>若以父级作用域理解: print 函数的父级作用域是全局作用域(作用域是在函数定义时就已经确定了的), 因此 a == 10;<br><strong>父级作用域可能更容易判断: 因为其在书写代码时就确定了, 不用再通过 this 去判断执行环境; 以上例为例, <code>print()</code> 定义时已经确定了父级作用域是全局作用域, 因此调用时向上查找的全局作用域而不是 <code>border1</code></strong></p><p><strong>执行上下文与作用域</strong><br><strong>区别:</strong> 执行上下文在运行时确定, 随时可能改变; 作用于在定义时就确定, 并且不会改变;<br><strong>关系:</strong> 作用域可能包含多个上下文环境(多个函数调用), 也可能没有上下文环境(函数从未被调用, 或者函数执行完毕, 上下文环境被销毁), 也可能同时存在多个上下文(闭包); 同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。</p><h3 id="DOM常见的操作方式"><a href="#DOM常见的操作方式" class="headerlink" title="DOM常见的操作方式"></a>DOM常见的操作方式</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903604445249543">JavaScript操作DOM常用的API</a><br><strong>题解</strong><br>前置知识:<br><strong>DOM(文档对象模型)</strong>: HTML 和 XML 文档的<strong>编程接口</strong>, 提供了对文档的结构化表述;<br>DOM 可以说是 HTML 文件的另一种展示, 我们可以通过编辑器以代码的形式展示, 也可以通过浏览器以页面的形式展示; DOM 将文档解析为一个由节点和对象(包含属性和方法)组成的结构集合;<br>DOM 是一个编程接口, 它连接了 web 页面和脚本语言, 让开发人员可以通过操作 DOM 来改变或控制 web 页面;<br><strong>Node</strong>:<br>已知 DOM 是节点和对象组成的结构集合, DOM 的节点和对象从 Node 中继承;<br>每个节点类型对应一个节点类型常量,<br>常用的 Node 的节点类型常量(节点常量 / 值 / 描述): </p><ol><li>Node.ElEMENT_NODE / 1 / 元素节点(如<code>&lt;p&gt;</code>,<code>&lt;div&gt;</code>等)</li><li>Node.TEXT_NODE / 3 / 文字</li><li>Node.DOCUMENT_NODE / 9 / Document 节点</li><li>Node.DOCUMENT_FRAGMENT_NODE / 11 / DocumentFragment 节点</li></ol><p>Node 类型通过 Node 的 nodeType 属性判断, 值为一个整数(即上述节点类型常量的值);</p><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (X.nodeType === <span class="hljs-number">9</span>) &#123;<br>  <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;X 是一个 Document 节点&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>常用的 Node 节点类型: element, text, comment, document, document_fragment</p><ul><li><strong>Element</strong><br>提供了对元素标签名, 子节点和特性的访问; <code>&lt;div&gt;, &lt;span&gt;, &lt;a&gt;</code> 等标签都属于 element;</li><li><strong>Text</strong><br>文本节点, 包含纯文本内容, 不能包含html代码, 但可以包含转义后的html代码;</li><li><strong>Comment</strong><br>HTML文档的注释;</li><li><strong>Document</strong><br>文档, 在浏览器中, document对象是HTMLDocument的一个实例, 表示整个页面, 它同时也是window对象的一个属性;</li><li><strong>DocumentFragment</strong><br>所有节点中唯一一个没有对应标记的类型; 一种轻量级的文档, 当作一个临时的仓库用来保存可能会添加到文档中的节点;</li></ul><p><strong>DOM 的 API</strong></p><ol><li>节点创建型API: 创建节点</li></ol><ul><li>createElement: 传入指定的一个标签名来创建一个元素; <code>let element = document.createElement(tagName)</code>; (<strong>注意:</strong> 通过createElement创建的元素并不属于HTML文档, 它只是创建出来, 并未添加到HTML文档中, 要调用 <code>appendChild</code> 或 <code>insertBefore</code> 等方法将其添加到HTML文档树中)</li><li>createTextNode: 创建一个文本节点; <code>let text = document.createTextNode(data)</code>; (<strong>注意:</strong> 接收文本节点中的文本作为参数, 创建后的文本节点只是独立的一个节点, 同样需要 <code>appendChild</code> 将其添加到HTML文档树中)</li><li>cloneNode: 返回调用该方法的节点的一个副本;</li><li>createDocumentFragment: 创建 DOM 节点(文档片段); <code>let fragment = document.createDocumentFragment();</code>; 通常用例是”创建文档片段 -&gt; 附加元素 -&gt; 将文档片段插入 DOM 树”; 在实际 DOM 树中, 文档片段会被其附加的子元素代替; 文档片段存在于内存中, 不在 DOM 树中, 因此附加子元素时不会引起页面回流(对元素位置和几何上的计算), 能优化性能;</li><li><strong>总结:</strong> 创建型 API 所创建的节点是孤立的, 通常需要手动添加至 DOM 树; cloneNode 复制节点时要注意子节点和事件绑定的问题; createDocumentFragment 可以解决添加大量节点的性能问题;</li></ul><ol start="2"><li>页面修改型API</li></ol><ul><li>appendChild: 向目标节点添加子元素至末尾; <code>parent.appendChild(child)</code>; (<strong>注意:</strong> 不会同时存在两个相同节点在页面上, 若存在, 执行 appendChild 相当于把这个节点移动到末尾, 如果child绑定了事件, 被移动时, 它依然绑定着该事件)</li><li>insertBefore: 添加一个节点到一个参照节点之前; <code>parentNode.insertBefore(newNode, refNode)</code>; parentNode 表示新节点添加的父节点, newNode 表示要添加的节点, refNode 表示参照节点; (<strong>注意:</strong> refNode 参数必传, refNode 为 undefined 或 null, 则节点会被添加至子元素末尾)</li><li>removeChild: 删除指定的子节点并返回删除的节点; <code>let deleteChild = parent.removeChild(node)</code>; </li><li>replaceChild: 使用一个节点替换另一个节点; <code>parent.replaceChild(newChild, oldChild)</code>; (<strong>注意:</strong> newChild 若是页面上的节点, 则 replaceChild 执行的是将该节点转移到 oldChild 位置)</li><li><strong>总结:</strong> 新增或替换的节点若存在于页面上, 则其原来位置的节点将被移除, 同一个节点不能同时存在于页面的多个位置; 节点绑定的事件不会因为页面修改操作消失, 会一直保留;</li></ul><ol start="3"><li>节点查询型API</li></ol><ul><li>document.getElementById: 根据元素id返回元素, 返回值是Element类型, 如果不存在该元素, 则返回null; <code>let element = document.getElementById(id)</code>; (<strong>注意:</strong> HTML 中若存在多个相同 id 的元素, 则返回第一个元素)</li><li>document.getElementsByTagName: 返回一个包括所有给定标签名称的元素的HTML集合; <code>let elements = document.getElementByTagName(name)</code>; (<strong>注意:</strong> 搜索范围是整个 HTML 文档, 返回的 HTML 集合是动态的, 它可以自动更新并保持与 DOM 树的同步; 若不存在指定标签, 接口返回空的 HTML Collection 而不是 null)</li><li>document.getElementsByName: 通过指定 name 属性获取元素, 返回一个 NodeList 对象; <code>let elements = document.getElementsByName(name)</code>; (<strong>注意:</strong> NodeList 是会随时变化的)</li><li>document.getElementsByClassName: 根据元素的class返回一个即时的HTMLCollection; <code>let elements = document.getElementsByClassName(names)</code>; elements 为 HTML 集合, 包含了匹配的所有元素, names 为字符串, 包含所要匹配的类名列表, 类名通过空格分隔; (<strong>注意:</strong> getElementsByClassName 可在任何元素上调用, 不仅仅是 document)</li><li>document.querySelector: 通过 css 选择器来查找元素, 返回第一个匹配的元素(深度优先搜索), 若没有则返回 null; <code>let element = document.querySelector(selectors)</code>; </li><li>document.querySelectorAll: 通过 css 选择器来查找元素, 返回所有匹配的元素; <code>let elementList = document.querySelectorAll(selectors)</code>; elementList 是一个静态的 NodeList 类型的对象, selectors 是一个由逗号连接的包含一个或多个CSS选择器的字符串; (<strong>注意:</strong> 返回的 NodeList 是静态非即时的, 结果不会随着文档树变化而变化)</li></ul><ol start="4"><li>节点关系型API</li></ol><ul><li>parentNode: 返回元素父节点;</li><li>parentElement: 返回元素的父元素节点, 与 parentNode 不同在于, 父节点必须是 Element, 若不是则返回 null;</li><li>childNodes: 即时 NodeList, 表示元素的子节点列表; </li><li>children: 即时 HTML Collection, 返回 Element 子节点; 注意 HTML Collection 和 NodeList 的区别;</li><li>firstChild: 返回 DOM 树节点的第一个子节点, 若无子节点则返回 null;</li><li>lastChild: 返回当前节点的最后一个子节点, 若无子节点返回 null;</li><li>hasChildNodes: 返回布尔值, 表明当前节点是否包含子节点;</li><li>previousSibling: 返回当前节点的前一个兄弟节点,没有则返回null;</li><li>previousElementSibling: 返回当前元素在其父元素的子元素节点中的前一个元素节点;</li><li>nextSibling: 返回其父节点的childNodes列表中紧跟在其后面的节点;</li><li>nextElementSibling: 返回当前元素在其父元素的子元素节点中的后一个元素节点;</li></ul><ol start="5"><li>元素属性API</li></ol><ul><li>setAttribute: 设置指定元素的一个属性值, 若属性存在则更新其值, 否则添加新的属性; <code>element.setAttribute(name, value)</code>; name 为属性值, value 为属性值; </li><li>getAttribute: 返回元素内的一个指定属性值, 若不存在返回 null 或 “”; <code>let attr = element.setAttribute(attrName)</code>;</li><li>removeAttribute: 移除指定元素的一个属性; <code>element.removeAttribute(attrName)</code>;</li></ul><h3 id="Array-sort-方法与实现机制"><a href="#Array-sort-方法与实现机制" class="headerlink" title="Array.sort()方法与实现机制"></a>Array.sort()方法与实现机制</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903614918459406">js 数组详细操作方法及解析合集</a><br><a href="https://juejin.cn/post/6844903609885261832">六种排序算法的JavaScript实现以及总结</a><br><a href="https://juejin.cn/post/6844903507439419399">深入了解javascript的sort方法</a><br><strong>题解</strong><br>Array.sort()<br>作用: 对数组元素进行排序, 并返回排序后的数组;<br>参数: (可选) 规定排序顺序的比较函数; 若没有传比较函数, 默认按字母升序, 非字符元素调用 toString() 将元素转为字符串的 Unicode 再比较;<br>比较函数的两个默认参数 (a, b):</p><ul><li>若比较函数返回值&lt;0，那么a将排到b的前面;</li><li>若比较函数返回值=0，那么a 和 b 相对位置不变;</li><li>若比较函数返回值&gt;0，那么b 排在a 将的前面;</li></ul><p>Array.sort() 实现机制:<br>Array.sort()只需传入比较的规则即可, 但实际内部依靠排序算法支撑;<br>不同浏览器采用的排序算法不相同, Firefox 采用快速排序, Chrome 采用归并排序;</p><p><strong>排序算法(升序)</strong></p><ol><li>冒泡排序<br>时间复杂度: <code>O(n^2)</code><br>10000条数据耗时: 360.530ms<figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(arr)</span> &#123;</span><br>  const lens = arr.<span class="hljs-built_in">length</span>;<br>  <span class="hljs-keyword">for</span> (let <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; lens; <span class="hljs-built_in">i</span>++) &#123;<br>    <span class="hljs-keyword">for</span> (let <span class="hljs-built_in">j</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">j</span> &lt; lens - <span class="hljs-built_in">i</span>; <span class="hljs-built_in">j</span>++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[<span class="hljs-built_in">j</span>] &gt; arr[<span class="hljs-built_in">j</span> + <span class="hljs-number">1</span>]) &#123;<br>        [arr[<span class="hljs-built_in">j</span>], arr[<span class="hljs-built_in">j</span> + <span class="hljs-number">1</span>]] = [arr[<span class="hljs-built_in">j</span> + <span class="hljs-number">1</span>], arr[<span class="hljs-built_in">j</span>]];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>选择排序<br>时间复杂度: <code>O(n^2)</code><br>10000条数据耗时: 78.949ms<figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(arr)</span> &#123;</span><br>  const lens = arr.<span class="hljs-built_in">length</span>;<br>  <span class="hljs-keyword">for</span> (let <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; lens; <span class="hljs-built_in">i</span>++) &#123;<br>    let <span class="hljs-built_in">min</span> = <span class="hljs-built_in">i</span>;<br>    <span class="hljs-keyword">for</span> (let <span class="hljs-built_in">j</span> = <span class="hljs-built_in">i</span>; <span class="hljs-built_in">j</span> &lt; lens; <span class="hljs-built_in">j</span>++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[<span class="hljs-built_in">min</span>] &gt; arr[<span class="hljs-built_in">j</span>]) &#123;<br>        <span class="hljs-built_in">min</span> = <span class="hljs-built_in">j</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span> !== <span class="hljs-built_in">i</span>) &#123;<br>      [arr[<span class="hljs-built_in">i</span>], arr[<span class="hljs-built_in">min</span>]] = [arr[<span class="hljs-built_in">min</span>], arr[<span class="hljs-built_in">i</span>]];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>插入排序<br>时间复杂度: <code>O(n^2)</code><br>10000条数据耗时: 40.008ms<figure class="highlight matlab"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(arr)</span> &#123;</span><br>  const lens = arr.<span class="hljs-built_in">length</span>;<br>  <span class="hljs-keyword">for</span> (let <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>; <span class="hljs-built_in">i</span> &lt; lens; <span class="hljs-built_in">i</span>++) &#123;<br>    let <span class="hljs-built_in">j</span> = <span class="hljs-built_in">i</span>;<br>    let tmp = arr[<span class="hljs-built_in">i</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">j</span> &gt; <span class="hljs-number">0</span> &amp;&amp; arr[<span class="hljs-built_in">j</span> - <span class="hljs-number">1</span>] &gt; tmp) &#123;<br>      arr[<span class="hljs-built_in">j</span>] = arr[<span class="hljs-built_in">j</span><span class="hljs-number">-1</span>];<br>      <span class="hljs-built_in">j</span>--;<br>    &#125;<br>    arr[<span class="hljs-built_in">j</span>] = tmp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>归并排序<br>时间复杂度: <code>O(nlogn)</code><br>10000条数据耗时: 11.314ms<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = main(arr);<br>  <span class="hljs-keyword">return</span> res<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">const</span> left = arr.slice(<span class="hljs-number">0</span>, mid);<br>    <span class="hljs-keyword">const</span> right = arr.slice(mid);<br>    <span class="hljs-comment">// 回收递归结果</span><br>    <span class="hljs-keyword">const</span> mergeResult = merge(main(left), main(right));<br>    <span class="hljs-keyword">return</span> mergeResult;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">left, right</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> il = <span class="hljs-number">0</span>, ir = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">while</span> (il &lt; left.length &amp;&amp; ir &lt; right.length) &#123;<br>      left[il] &lt; right[ir] ? result.push(left[il++]) : result.push(right[ir++]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result.concat(left.slice(il)).concat(right.slice(ir));<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>快速排序<br>时间复杂度: <code>O(nlogn)</code><br>10000条数据耗时: 7.193ms<figure class="highlight swift"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs swift">function <span class="hljs-built_in">quickSort</span>(arr) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">left</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">right</span> = arr.length - <span class="hljs-number">1</span>;<br>  main(arr, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>);<br>  <span class="hljs-keyword">return</span> arr;<br><br>  function main(arr, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>) &#123;<br>    <span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    const index = <span class="hljs-built_in">partition</span>(arr, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">left</span> &lt; index - <span class="hljs-number">1</span>) &#123;<br>      main(arr, <span class="hljs-keyword">left</span>, index - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-keyword">right</span>) &#123;<br>      main(arr, index, <span class="hljs-keyword">right</span>);<br>    &#125;<br>  &#125;<br><br>  function <span class="hljs-built_in">partition</span>(arr, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>) &#123;<br>    const midPivot = arr[<span class="hljs-type">Math</span>.floor((<span class="hljs-keyword">left</span> + <span class="hljs-keyword">right</span>) / <span class="hljs-number">2</span>)];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">left</span> &lt;= <span class="hljs-keyword">right</span>) &#123;<br>      <span class="hljs-keyword">while</span> (arr[<span class="hljs-keyword">left</span>] &lt; midPivot) &#123;<br>        <span class="hljs-keyword">left</span>++;<br>      &#125;<br>      <span class="hljs-keyword">while</span> (arr[<span class="hljs-keyword">right</span>] &gt; midPivot) &#123;<br>        <span class="hljs-keyword">right</span>--;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">left</span> &lt;= <span class="hljs-keyword">right</span>) &#123;<br>        [arr[<span class="hljs-keyword">left</span>], arr[<span class="hljs-keyword">right</span>]] = [arr[<span class="hljs-keyword">right</span>], arr[<span class="hljs-keyword">left</span>]];<br>        <span class="hljs-keyword">left</span>++;<br>        <span class="hljs-keyword">right</span>--;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">left</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>堆排序<figure class="highlight erlang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang">后续更新...<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="Ajax-请求过程"><a href="#Ajax-请求过程" class="headerlink" title="Ajax 请求过程"></a>Ajax 请求过程</h3><p><strong>参考文章</strong><br><a href="https://segmentfault.com/a/1190000017176090">前端校招准备–Ajax原理及其实现</a><br><a href="https://juejin.cn/post/6844903573529034759">ajax常见面试题</a><br><a href="https://juejin.cn/post/6844903618764603399">Ajax原理一片就够了</a><br><a href="https://www.w3school.com.cn/js/js_ajax_http.asp">W3school – AJAX</a><br><strong>题解</strong><br>概念: AJAX (Asynchronous Javascript And XML) 异步 JavaScript 和 XML, 是一种创建交互式网页应用的网页开发技术; 其可以与服务器进行少量数据交换, 使网页局部实现异步更新;<br><strong>Ajax 异步请求过程:</strong></p><ol><li>创建 XMLHttpRequest 对象</li><li>初始化参数(规定请求类型, URL 以及是否异步处理请求)</li><li>发送请求</li><li>接收响应数据</li></ol><p><strong>自己实现 AJAX 请求封装:</strong><br>前置知识:<br>Ajax的核心 – XMLHttpRequest 对象; 在Chrome, Firefox, Opera, Safari以及IE7+都内建了 XmlHttpRequest 对象, 但是 IE5 和 IE6 是使用 ActiveX 对象。<br>XMLHttpRequest 对象方法:</p><ol><li>abort(): 取消现有连接, 重置 XMLHttpRequest 对象状态值为 0;</li><li>open(): 初始化 http 请求参数;</li><li>send(): 发送 http 请求;</li><li>setRequestHeader(): 设置请求头(一般用于’POST’请求);</li></ol><p>XMLHttpRequest 对象属性:</p><ol><li>onreadystateChange: XMLHttpRequest 对象状态值发生改变时触发的回调函数;</li><li>reposeText: 服务器返回数据的字符串格式;</li><li>reposeXML: 服务器返回数据的 XML 格式(兼容 DOM 的文档数据对象);</li><li>status: 从服务器返回的状态码;</li></ol><ul><li>2xx: 成功处理请求</li><li>3xx: 重定向</li><li>4xx: 客户端错误</li><li>5xx: 服务端错误</li></ul><ol start="5"><li>statusText: 伴随状态码返回的信息;</li><li>readyState: XMLHttpRequest 对象状态值;</li></ol><ul><li>0: XmlHttpRequest 对象已创建或者已经被 abort() 方法重置</li><li>1: 对象已经初始化，但是请求还未发送（调用了open()方法，send()方法还没有调用）</li><li>2: 请求已经发送，没有接收到响应信息（sed()方法已经被调用）</li><li>3: 已经接收到了所有的响应头，响应体开始接收但未完成</li><li>4: 响应信息已经全部接收</li></ul><p>http状态码 (status) 和对象状态值 (readyState) 的区别:<br>readyState 针对 XMLHttpRequest 对象, 标记了 XMLHttpRequest 对象当前处于哪个状态;<br>status 针对服务器, 标记了服务器当前处于哪个状态, 由服务器接收到请求后返回;<br>readyState 标记了 XMLHttpRequest 对象的整个请求过程, 只有当请求过程全部完成后(完整执行了一次请求), 服务器才会接收到请求并返回一个 status , 根据服务器返回的 status 调用不同的函数;</p><p><strong>AJAX 请求封装的代码实现</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> ajax(<span class="hljs-keyword">options</span>) &#123;<br>  let xhr = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">window</span>.XMLHttpRequest) &#123;<br>    xhr = <span class="hljs-built_in">new</span> XMLHttpRequest();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    // 兼容 IE5, IE6<br>    xhr = <span class="hljs-built_in">new</span> ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);<br>  &#125;<br><br>  // 初始化配置项<br>  <span class="hljs-keyword">options</span> = <span class="hljs-keyword">options</span> || &#123;&#125;; // 配置项是否为空<br>  <span class="hljs-keyword">options</span>.<span class="hljs-keyword">type</span> = (<span class="hljs-keyword">options</span>.<span class="hljs-keyword">type</span> || <span class="hljs-string">&#x27;GET&#x27;</span>).toUpperCase(); // 请求方式统一大写, 默认 <span class="hljs-keyword">GET</span> 请求<br>  <span class="hljs-keyword">options</span>.dataType = <span class="hljs-keyword">options</span>.dataType || <span class="hljs-string">&#x27;json&#x27;</span>; // 默认请求体 <span class="hljs-type">json</span> 格式<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">options</span>.<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;GET&#x27;</span>) &#123;<br>    xhr.<span class="hljs-keyword">open</span>(<span class="hljs-keyword">options</span>.<span class="hljs-keyword">type</span>, <span class="hljs-keyword">options</span>.url, <span class="hljs-keyword">true</span>);<br>    xhr.send();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">options</span>.<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;POST&#x27;</span>) &#123;<br>    // 创建并初始化请求<br>    xhr.<span class="hljs-keyword">open</span>(<span class="hljs-keyword">options</span>.<span class="hljs-keyword">type</span>, <span class="hljs-keyword">options</span>.url, <span class="hljs-keyword">true</span>);<br>    // POST 请求需设置请求头格式<br>    xhr.setRequestHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, &quot;application/x-www-form-urlencoded&quot;)<br>    // 发送请求<br>    xhr.send();<br>  &#125;<br>  <br>  // 设置请求状态值改变对应触发的回调函数<br>  xhr.onreadystateChange = <span class="hljs-keyword">function</span>() &#123;<br>    <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;<br>      // 注: 只有当 readyState === <span class="hljs-number">4</span>, 即完整执行一次请求后, 服务端才返回 status<br>      <span class="hljs-keyword">if</span> (xhr.status &gt;=<span class="hljs-number">200</span> &amp;&amp; xhr.status &lt; <span class="hljs-number">300</span>) &#123;<br>        <span class="hljs-keyword">options</span>.success &amp;&amp; <span class="hljs-keyword">options</span>.success(xhr.responseText, xhr.responseXML);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">options</span>.fail &amp;&amp; <span class="hljs-keyword">options</span>.fail(xhr.status, xhr.statusText);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="JS-垃圾回收机制"><a href="#JS-垃圾回收机制" class="headerlink" title="JS 垃圾回收机制"></a>JS 垃圾回收机制</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903556265279502#comment">简单了解JavaScript垃圾回收机制</a><br><a href="https://juejin.cn/post/6844903833387155464">JavaScript中的垃圾回收和内存泄漏</a><br><strong>题解</strong><br>前置知识:</p><ul><li>垃圾回收机制: JS 找出不再使用的变量, 然后释放其占用的内存; 工作在 JavaScript 引擎内部;</li><li>堆: 动态存放对象的内存空间;</li><li>mutator: 应用程序本身, 例如变量;</li><li>allocator: 负责从堆中调取内存空间供 mutator 使用(动态分配);</li><li>活动对象/非活动对象: mutator 所引用的对象; <code>let a = &#123;name: bar&#125;</code> 中 a 是 mutator , 其引用的 <code>&#123;name: bar&#125;</code> 是活动对象, <code>a = null</code> 后, <code>&#123;name: bar&#125;</code> 不再被任何 mutator 引用, 因此变为了非活动对象;</li><li>内存泄漏: 对象不再被使用但是仍处于被引用状态, 无法被回收释放; 常见的内存泄漏: 意外的全局变量; 被遗忘的计时器或回调函数; 闭包; 没有清理的 DOM 元素引用;</li></ul><p><strong>引用计数法</strong><br>所有对象记录引用自己的 mutator 的数量; 当引用其的 mutator 数量为 0 时, 视为垃圾并被回收机制回收;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(); <span class="hljs-comment">// obj 计数 1 (a)</span><br><span class="hljs-keyword">let</span> b = a; <span class="hljs-comment">// obj 计数 2 (a,b)</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-literal">null</span>; <span class="hljs-comment">// obj 计数 1 (b)</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-literal">null</span>; <span class="hljs-comment">// obj 计数 0</span><br>&lt;!-- GC 回收 obj --&gt;<br></code></pre></div></td></tr></table></figure><ul><li>引用计数法优势: 即时回收垃圾(目标被引用数为 0 时, 立刻被回收); 每次垃圾回收占用时间短; 不用去遍历堆内所有活动对象和非活动对象;</li><li>引用计数法劣势: 对象计数器占用空间; 无法解决循环引用无法回收的问题</li></ul><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- 循环引用 --&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- f()执行完毕后, 由于其内部对象发生循环引用, 两者引用次数始终为 1, 无法被 GC 回收, 造成内存泄露 --&gt;</span></span><br><span class="xml">function f()</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  var o = &#123;&#125;</span><span class="xml">;</span><br><span class="xml">  var o2 = </span><span class="hljs-template-variable">&#123;&#125;</span><span class="xml">;</span><br><span class="xml">  o.a = o2; // o 引用 o2,o2的引用次数是1</span><br><span class="xml">  o2.a = o; // o2 引用 o,o的引用此时是1</span><br><br><span class="xml">  return &quot;azerty&quot;;</span><br><span class="xml">&#125;</span><br><span class="xml">f();</span><br></code></pre></div></td></tr></table></figure><p><strong>标记清除法</strong></p><ol><li>标记阶段: GC 从全局作用域的变量, 沿作用域逐层向里深度遍历, 遍历到堆中对象时(说明该对象被引用), 做上标记, 继续递归遍历直到最深层作用域的最后一个节点;</li><li>清除阶段: 遍历整个堆, 回收没有被打上标记的对象;</li></ol><ul><li>标记清除法优势: 实现简单, 标记不占用许多内存(有标记/没有标记, 一位二进制位即可表示); 解决了循环引用(两对象循环引用是无法从全局对象出发获取的, 因此就无法被标记, 其内存会被 GC 回收);</li><li>标记清除法缺点: 碎片化; 需要多次遍历, 无法即时回收;</li></ul><p>由于标记清除法需要遍历, 而遍历往往需要占用一部分运行时间, 为了避免长时间执行 GC, 标记清除法的 GC 回收机制采用定时运行的方式, 在程序运行过程中, 每隔一段时间进行一次统一的 GC;</p><p><strong>复制算法</strong><br>将一个内存空间分为两部分，一部分是From空间，另一部分是To空间，将From空间里面的活动对象复制到To空间，然后释放掉整个From空间，然后此刻将From空间和To空间的身份互换，那么就完成了一次GC。</p><p><strong>小疑问: 文章提到的 GC 都是在堆内存中操作, 回收的是堆的对象, 那栈内存中的原始值是如何被回收的? 例如<code>let a = 1; a = 2</code> 此时 <code>1</code> 在栈中没有被使用, 应该被释放(上述操作中, 栈重新开辟了内存存储 <code>a = 2</code> 而不是在原位置替换值, 因为原始值不可改变)</strong></p><h3 id="JS-String、Array和Math方法"><a href="#JS-String、Array和Math方法" class="headerlink" title="JS String、Array和Math方法"></a>JS String、Array和Math方法</h3><p><strong>参考文章</strong><br><a href="https://segmentfault.com/a/1190000025123515">js中的String字符串方法</a><br><a href="https://www.w3school.com.cn/js/js_string_methods.asp">W3school - JavaScript 字符串方法</a><br><a href="https://www.w3school.com.cn/js/js_array_methods.asp">W3school - JavaScript 数组方法</a><br><a href="https://www.w3school.com.cn/js/js_array_sort.asp">W3school - JavaScript 数组排序</a><br><a href="https://www.w3school.com.cn/js/js_array_iteration.asp">W3school - JavaScript 数组迭代</a><br><a href="https://www.w3school.com.cn/js/js_math.asp">W3school - JavaScript Math 对象</a></p><h3 id="addEventListener-和-onclick-的区别"><a href="#addEventListener-和-onclick-的区别" class="headerlink" title="addEventListener 和 onclick() 的区别"></a>addEventListener 和 onclick() 的区别</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903834075021326">你真的理解事件冒泡和事件捕获吗？</a><br><a href="https://segmentfault.com/a/1190000039368505">onclick和addEventListener的区别</a><br><strong>题解</strong><br>前置知识:<br><a href="https://juejin.cn/post/6844903834075021326">事件冒泡与事件捕获</a><br>作用: 解决页面中的事件流(事件发生顺序)<br>事件冒泡: 事件从最内层元素触发, 并一直向上传播, 直到 document 对象; <code>element -&gt; body -&gt; html -&gt; document</code><br>事件捕获: 事件从最外层触发, 向内传播, 直到最具体的元素; <code>document -&gt; html -&gt; body -&gt; document</code><br><strong>addEventListener</strong>:</p><ul><li>语法: <code>element.addEventListener(event, function, useCapture)</code></li><li>event: 事件名, 不能以’on’开头;</li><li>function: 触发事件执行的回调函数;</li><li>useCapture: true - 冒泡阶段执行; false - 捕获阶段执行;</li></ul><p><strong>addEventListener 和 onclick() 的区别:</strong></p><ol><li>onclick 事件不能重复绑定, 只能指向唯一对象（重复绑定事件只会使最后绑定的事件响应）; addEventListener 可以给一个对象注册多个listener（重复绑定事件会依次从上到下响应）<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>);<br>btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;;<br>btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)&#125;;<br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)&#125;, <span class="hljs-literal">false</span>);<br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)&#125;, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 4</span><br></code></pre></div></td></tr></table></figure></li><li>onclick() 事件流通过事件冒泡处理, addEventListener 可自定义事件流处理方式;</li><li>onclick() 是 DOM0 级处理事件, 作用于 HTML 对象, addEventListener 是 DOM2 级处理事件, 作用于任何对象;</li></ol><h3 id="new和Object-create的区别"><a href="#new和Object-create的区别" class="headerlink" title="new和Object.create的区别"></a>new和Object.create的区别</h3><p><strong>参考文章</strong><br><a href="https://segmentfault.com/a/1190000016523214">JavaScript中new操作符和Object.create()的原理</a><br><a href="https://juejin.cn/post/6844903917835436045">Object.create()、new Object()和{}的区别</a><br><a href="https://juejin.cn/post/6844903589815517192">详解Object.create(null)</a><br><strong>题解</strong><br>首先自己手撸一遍 new 和 Object.create 的简单实现, 很多关系就显而易见了:<br><strong>new 实现</strong></p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart">function _<span class="hljs-keyword">new</span> (Fn, ...args) &#123;<br>  <span class="hljs-keyword">const</span> _<span class="hljs-keyword">this</span> = <span class="hljs-built_in">Object</span>.create(Fn.prototype);<br>  <span class="hljs-keyword">const</span> res = Fn.apply(_<span class="hljs-keyword">this</span>, [...args]);<br>  <span class="hljs-keyword">if</span> (typeof res === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    retrun _<span class="hljs-keyword">this</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Object.create 实现</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create = <span class="hljs-keyword">function</span>(objPrototype, properties) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-constructor">F()</span> &#123;&#125;;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>prototype = objPrototype;<br>  <span class="hljs-keyword">if</span> (properties) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Properties(F, <span class="hljs-params">properties</span>)</span><br>  &#125;<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">F()</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到, 在 new 的实现中, 我们用到了 <code>Object.create</code> 方法:<br><code>Object.create(arg, pro)</code> 方法的作用是根据传递的参数 arg (传递一个原型)创建一个对象, 若不传入其余参数, 则创建的是一个空对象(<strong>不挂载任何属性和方法</strong>), 对象原型指向 arg 原型;<br>而 new 关键字创建的对象的原型指向构造函数的原型, 该创建的对象<strong>还挂载了构造函数的一系列属性</strong>;<br><strong>注意:</strong> <code>Object.create(null)</code> 创建的对象不包含 Object 原型的任何属性和方法, 除非我们执行 <code>Object.create(Object.prototype)</code>; <code>new Object()</code> 创建的对象指向 Object 原型, 继承了它的属性和方法; 当我们需要一个干净且可定制的对象时, 考虑采用 <code>Object.create(null)</code> 创建空对象, 该对象不继承 <code>Object.prototype</code> 的任何属性和方法;</p><h3 id="DOM的location对象"><a href="#DOM的location对象" class="headerlink" title="DOM的location对象"></a>DOM的location对象</h3><p><strong>参考文章</strong><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Location">MDN - Location</a></p><h3 id="浏览器从输入URL到页面渲染的整个流程"><a href="#浏览器从输入URL到页面渲染的整个流程" class="headerlink" title="浏览器从输入URL到页面渲染的整个流程"></a>浏览器从输入URL到页面渲染的整个流程</h3><p><strong>参考文章</strong><br><a href="https://www.nowcoder.com/discuss/258810">（详解）从浏览器输入 URL 到页面展示过程发生了什么？</a><br><a href="https://segmentfault.com/a/1190000023283609">十五张图带你彻底搞懂从URL到页面展示发生的故事</a></p><h3 id="跨域、同源策略及跨域实现方式和原理"><a href="#跨域、同源策略及跨域实现方式和原理" class="headerlink" title="跨域、同源策略及跨域实现方式和原理"></a>跨域、同源策略及跨域实现方式和原理</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理（完整版）</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a><br><strong>题解</strong><br>后续更新…</p><h3 id="浏览器的回流（Reflow）和重绘（Repaints）"><a href="#浏览器的回流（Reflow）和重绘（Repaints）" class="headerlink" title="浏览器的回流（Reflow）和重绘（Repaints）"></a>浏览器的回流（Reflow）和重绘（Repaints）</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903569087266823">浏览器的回流与重绘 (Reflow &amp; Repaint)</a><br><a href="https://juejin.cn/post/6844903779700047885">你真的了解回流和重绘吗</a><br><a href="https://juejin.cn/post/6844903859719143437">前端基本功（四）：性能优化之你真的懂回流、重绘与合成层吗？</a><br><strong>题解</strong><br>后续更新…</p><h3 id="JavaScript中的arguments"><a href="#JavaScript中的arguments" class="headerlink" title="JavaScript中的arguments"></a>JavaScript中的arguments</h3><p><strong>参考文章</strong><br><a href="https://segmentfault.com/a/1190000007091243?utm_source=sf-similar-article">JavaScript arguments 对象全面介绍</a><br><a href="https://segmentfault.com/a/1190000009328344?utm_source=sf-similar-article">JavaScript深入之类数组对象与arguments</a><br><strong>题解</strong><br>arguments 对象概念: 一个类数组对象, 是传给 function 的参数组成的列表;<br>重点:</p><ol><li>类数组对象: 与数组结构类似, 键名为索引, 并有 length 属性, 打印出来的结果和数组一样, 例如 <code>[&#39;A&#39;,&#39;a&#39;,0]</code>; 读写方式, 获取长度, for…in… 遍历等同数组一样; 但不能调用数组 Array 的方法;</li><li>包含的是传递给函数的参数, 注意表达, 即默认值是不被包含在 arguments 内的;</li></ol><p>arguments 对象转数组:<br><strong>提问: 为什么通常将 arguments 转为数组?</strong><br>因为数组的方法更多, 功能更强大, 我们通常获取 arguments 后第一步先将它转为数组对象;<br><strong>提问: 为什么不直接将 arguments 设计为数组对象?</strong><br>为了向前兼容, 在 ES6 中有 Rest 参数可以替代 arguments;<br>arguments 转数组的常用方法有:</p><ol><li>方法借用: <code>const arr = Array.prototype.slice.call(arguments)</code></li><li>方法借用: <code>const arr = Array.prototype.splice.call(arguments, 0)</code></li><li>方法借用: <code>const arr = Array.prototype.concat.apply([], arguments)</code></li><li>ES6 Array.from(): <code>const arr = Array.from(arguments)</code></li><li>ES6 扩展运算符: <code>const arr = [...arguments]</code></li><li>ES6 Rest参数(接收剩余参数, 存储于数组内)替换arguments: <code>function(...args) &#123;console.log(args)&#125;</code></li></ol><p><strong>函数的 arguments 不能泄露或向外传递(直接返回/间接返回/闭包泄露等都不行)</strong><br>V8 引擎会跳过优化, 造成性能损失;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArgs</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArgs</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-keyword">return</span> args;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArgs</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> args;<br>    &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意上述表达, 不能向外传递, arguments 是可以向内传递给嵌套函数的;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>) </span>&#123;<br>  getName.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>) <span class="hljs-comment">// apply 可将数组或类数组作为参数传递给目标;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi &#x27;</span> + name)<br>&#125;<br>sayHi(<span class="hljs-string">&#x27;Siri&#x27;</span>) <span class="hljs-comment">// Hi Siri</span><br></code></pre></div></td></tr></table></figure><p><strong>修改 arguments 的值</strong><br>在严格模式下, arguments 同参数没有联系, 修改一个值不会改变另一个值;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeValue</span>(<span class="hljs-params">a</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 1 , 1</span><br>  a = <span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 10 , 1</span><br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">20</span>;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 10 , 20</span><br>&#125;<br>changeValue(<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p>非严格模式下, arguments 与参数关联;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeValue</span>(<span class="hljs-params">a</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 1 , 1</span><br>  a = <span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 10 , 10</span><br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">20</span>;<br>  <span class="hljs-built_in">console</span>.log(a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 20 , 20</span><br>&#125;<br>changeValue(<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><p><strong>arguments 应用场景</strong></p><ol><li>参数不定长</li><li>函数柯里化 (后续介绍)</li><li>递归调用</li><li>函数重载: 同名不同参数的函数(方法)称为重载函数(方法), 同名函数(方法)根据传参类型不同执行对应的函数(方法)称为函数重载; JS 不对传入参数类型进行严格定义, 因此不具备函数重载功能, 若有同名函数, 后面的函数会将前面的函数覆盖; (<strong>后续有机会再补充函数重载的方法</strong>)<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">arg1, arg2</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是函数1&#x27;</span>) &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">arg1, arg2, arg3</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是函数2&#x27;</span>) &#125;<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 我是函数2</span><br></code></pre></div></td></tr></table></figure></li></ol><h3 id="宏任务与微任务-amp-EventLoop事件循环"><a href="#宏任务与微任务-amp-EventLoop事件循环" class="headerlink" title="宏任务与微任务 &amp; EventLoop事件循环"></a>宏任务与微任务 &amp; EventLoop事件循环</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903638238756878">JS事件循环机制（event loop）之宏任务/微任务</a><br><a href="https://juejin.cn/post/6844903657264136200">微任务、宏任务与Event-Loop</a><br><a href="https://segmentfault.com/a/1190000022577369">JavaScript基础四：事件循环EventLoop</a><br><a href="https://segmentfault.com/a/1190000022805523?utm_source=sf-similar-article">JavaScript中的Event Loop（事件循环）机制</a><br><strong>题解</strong></p><ol><li>JavaScript 是单线程语言, JS 任务需要遵循一定的顺序执行;</li><li>为了避免某个任务执行时间过长而阻塞后面任务的执行, JS 将任务分为了同步和异步任务;</li><li>同步任务和异步任务执行的场所不同, 具体可见<a href="https://user-gold-cdn.xitu.io/2018/7/14/164974fb89da87c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">同步/异步任务思维导图</a>; 具体执行过程如下:</li></ol><ul><li>同步任务进入主线程执行, 异步任务进入 <code>Event Table</code> 执行, 并在此阶段注册其内部的回调函数;</li><li>注册的回调函数会被放入 <code>Event Queue</code> 中等待;</li><li>主线程中同步任务执行完毕后(js 引擎通过 <code>monitoring process</code> 进程持续监测主线程执行栈是否为空), 此时执行栈为空, 会去 <code>Event Queue</code> 检查是否存在等待的回调函数, 若存在则读取 <code>Event Queue</code> 的函数到主线程中执行;</li></ul><ol start="4"><li>异步任务又被细分为宏任务和微任务, JS 在处理宏任务和微任务时又遵循特殊的执行顺序;</li><li>当 JS 遇到宏任务时, 先将其放入 <code>Macro Event Queue</code> 中, 然后将微任务放入 <code>Micro Event Queue</code> 中(注意宏任务队列和微任务队列不是一个队列); 在读取(向外拿)回调函数时, 先从微任务队列拿微任务的回调函数, 然后再从宏任务队列中拿宏任务的回调函数; (换句话说, 每一次宏任务执行前, 要清空上一次的微任务队列, 宏任务在微任务之后执行);</li></ol><p>经过上述讲解, 我们可以看到, 分析 JS 的执行顺序, 应遵循的思路为: 同步 or 异步 -&gt; 同步放入主线程/异步放入 <code>Event Table</code> -&gt; <code>Event Table</code> 中判断宏任务 or 微任务 -&gt; 注册回调放入各自队列 -&gt; 清空微任务 -&gt; 执行下一次宏任务(此处并不是清空, 因为可能本次宏任务会添加新的微任务) -&gt; …;</p><p>在通过例子深入了解 JS 执行机制前, 我们需要记住几个常用的宏任务和微任务:<br><strong>宏任务:</strong> 整体 script 代码(script 代码是异步代码, 其内部可能包含同步代码, 但整体上是异步宏任务, 许多文章对于 script 代码解释有出入, 以自己理解为准), setTimeout, setInterval, setImmediate;<br><strong>微任务:</strong> 原生 Promise(有些实现的promise将then方法放到了宏任务中, 具体在手撕 Promise 时再讨论), process.nextTick, MutationObserver, Object.observe(已废弃);</p><p><strong>例一</strong></p><figure class="highlight lua"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lua">console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><br>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br>Promise.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>&#125;);<br><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br><br>/**请写出打印结果<br> * script start<br> * script <span class="hljs-keyword">end</span><br> * promise1<br> * promise2<br> * setTimeout<br> */<br><br>/**过程解析<br> * 添加执行环境 - 任务入栈:<br> * 最开始 JS 整体代码作为异步输入<br> * console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>) 同步代码, 放入主线程队列<br> * setTimeout 异步宏任务, 经 Event Table 注册回调后, 其回调放入宏任务队列<br> * Promise.resolve() 异步微任务, 经 Event Table 注册回调后, 回调放入微任务队列 (Promise 由于链式调用, 微任务队列 promise1 先入, promise2 后入)<br> * console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>) 同步代码, 放入主线程队列<br> * <br> * 执行 - 任务出栈:<br> * 先执行主线程, 输出 script start, script <span class="hljs-keyword">end</span><br> * 主线程为空, 清除微任务队列, 微任务回调出队列, 进入主线程执行, 输出 promise1, promise2<br> * 微任务为空, 清除宏任务队列, 宏任务回调出队列, 进入主线程执行, 输出 setTimeout<br> * 主线程, 任务队列均为空, 执行完毕;<br> */<br></code></pre></div></td></tr></table></figure><p><strong>例二</strong></p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript"><span class="hljs-built_in">setTimeout</span>(()=&gt;&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout1&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject)=&gt;&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise1&#x27;</span>);<br>  resolve();<br>&#125;)<br><br>p.<span class="hljs-keyword">then</span>(()=&gt;&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise2&#x27;</span>);<br>&#125;)<br><br><br><span class="hljs-comment">/**请写出打印结果</span><br><span class="hljs-comment"> * Promise1</span><br><span class="hljs-comment"> * Promise2</span><br><span class="hljs-comment"> * setTimeout1</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**过程解析</span><br><span class="hljs-comment"> * 入队</span><br><span class="hljs-comment"> * 最开始 JS 整体代码作为异步输入</span><br><span class="hljs-comment"> * setTimeout 异步宏任务, 注册回调并添加至宏任务</span><br><span class="hljs-comment"> * new Promise 是同步任务, 其内部 executor 函数在主线程自动执行, 因此将 executor 函数添加至主线程;</span><br><span class="hljs-comment"> * Promise.then() 异步微任务, 注册回调并添加至微任务</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 出队</span><br><span class="hljs-comment"> * 清空主线程, 输出 Promise1;</span><br><span class="hljs-comment"> * 清空微任务队列, 输出 Promise2;</span><br><span class="hljs-comment"> * 取宏任务队列回调, 输出 setTimeout1;</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><p><strong>例三</strong></p><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript"><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(()=&gt;&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise1&#x27;</span>)  <br>  <span class="hljs-built_in">setTimeout</span>(()=&gt;&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout2&#x27;</span>)<br>  &#125;,<span class="hljs-number">0</span>)<br>&#125;);<br><br><span class="hljs-built_in">setTimeout</span>(()=&gt;&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout1&#x27;</span>)<br>  <span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(()=&gt;&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Promise2&#x27;</span>)    <br>  &#125;)<br>&#125;,<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">/**输出结果</span><br><span class="hljs-comment"> * Promise1</span><br><span class="hljs-comment"> * setTimeout1</span><br><span class="hljs-comment"> * Promise2</span><br><span class="hljs-comment"> * setTimeout2</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**过程解析</span><br><span class="hljs-comment"> * 入队</span><br><span class="hljs-comment"> * 最开始 JS 整体代码作为异步输入</span><br><span class="hljs-comment"> * Promise.resolve() 异步微任务, 注册回调并添加至微任务</span><br><span class="hljs-comment"> * setTimeout 异步宏任务, 注册回调并添加至宏任务</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 出队</span><br><span class="hljs-comment"> * 主线程没有任务, 清空微任务, 输出 Promise1, 此时碰到 setTimeout 宏任务;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 入队</span><br><span class="hljs-comment"> * setTimeout 注册回调并添加至宏任务队尾</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 出队</span><br><span class="hljs-comment"> * 微任务为空, 此时获取宏任务队列最开始的回调并执行, 输出 setTimeout1;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 入队</span><br><span class="hljs-comment"> * 遇到 Promise.resolve 异步微任务, 注册其回调并添加至微任务;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 出队</span><br><span class="hljs-comment"> * 下一次宏任务队列回调执行前, 必须保证微任务队列是清空的, 因此此时清空微任务回调, 输出 Promise2</span><br><span class="hljs-comment"> * (这就是宏任务不用清空这两个字的原因)</span><br><span class="hljs-comment"> * 清空后, 获取宏任务回调并执行, 输出 setTimeout2</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><p>经过上述三个例子, 你可能对 JS 执行机制有了大致的了解, 在判断执行顺序时, 我们需要<strong>先构建初步的执行上下文(入队), 同步添加至主线程, 异步则进一步判断宏任务还是微任务, 注册回调并添加至各自的等待队列; 执行上下文构建完成后, 开始执行(出队), 先执行主线程的同步代码, 清空主线程后再清空微任务队列, 微任务队列清空后, 再从宏任务队列获取回调(多次强调, 此处是获取而不是清空)并执行; 在执行宏任务回调时, 又可能会添加新的主线程和微队列任务(第二轮构建入队), 我们要在下一次执行宏任务回调前, 将其清空(第二轮执行出队), 依次不断循环</strong></p><p><strong>终极考核 - 做对出师</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>        resolve();<br>    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>)<br>    &#125;)<br>&#125;)<br>process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);<br>    resolve();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;9&#x27;</span>);<br>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;11&#x27;</span>);<br>        resolve();<br>    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;12&#x27;</span>)<br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">/**输出结果</span><br><span class="hljs-comment"> * 1</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-comment">/**过程解析</span><br><span class="hljs-comment"> * 首轮构建执行上下文(入队)</span><br><span class="hljs-comment"> * js 代码块作为异步代码入队</span><br><span class="hljs-comment"> * console.log(1) 同步代码, 进入主线程</span><br><span class="hljs-comment"> * setTimeout 异步宏任务, 注册其 function()&#123;...&#125; (不关心其嵌套) 至宏任务队列</span><br><span class="hljs-comment"> * process.nextTick 异步微任务, 注册回调并添加至微任务队列</span><br><span class="hljs-comment"> * new Promise 内部 executor 函数同步执行, 添加至主线程</span><br><span class="hljs-comment"> * .then() 异步微任务, 添加至微任务队列</span><br><span class="hljs-comment"> * setTimeout 异步宏任务, 注册其 function()&#123;...&#125; (不关心其嵌套) 至宏任务队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 首轮执行(出队)</span><br><span class="hljs-comment"> * 清空主线程: 输出 1, 7</span><br><span class="hljs-comment"> * 清空微任务队列: 输出 6, 8</span><br><span class="hljs-comment"> * 获取宏任务第一个回调并执行: 输出 2, 此时遇到 process.nextTick, 开启第二轮入队(构建执行环境)</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *   第二轮入队</span><br><span class="hljs-comment"> *   注册 process.nextTick 回调并添加至微任务队列, </span><br><span class="hljs-comment"> *   添加 new Promise 内同步代码至主线程, </span><br><span class="hljs-comment"> *   注册 .then() 回调至微任务; 此时主线程和微任务队列都不为空, 开启第二轮出队</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *   第二轮出队</span><br><span class="hljs-comment"> *   清空主线程: 输出 4</span><br><span class="hljs-comment"> *   清空微任务队列: 输出 3, 5</span><br><span class="hljs-comment"> *   获取宏任务下一个回调: 输出 9,  此时遇到 process.nextTick, 开启第三轮入队</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *     第三轮入队</span><br><span class="hljs-comment"> *     注册 process.nextTick 回调并添加至微任务队列, </span><br><span class="hljs-comment"> *     添加 new Promise 内同步代码至主线程, </span><br><span class="hljs-comment"> *     注册 .then() 回调至微任务; 此时主线程和微任务队列都不为空, 开启第三轮出队</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> *     第三轮出队</span><br><span class="hljs-comment"> *     清空主线程: 输出 11;</span><br><span class="hljs-comment"> *     清空微任务队列: 输出 10, 12</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 主线程, 宏任务队列, 微任务队列都为空, 执行完毕</span><br><span class="hljs-comment"> * 输出结果为: 1, 7, 6, 8, 2, 4, 3, 5, 9, 11, 10, 12</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><p>回调函数内可能嵌套了多层, 但遵循上述步骤仍可以正确判断, 我们每次<strong>只需关注最外层嵌套函数</strong>即可, <strong>在原有上下文基础上构建第二级的执行上下文, 清空主线程, 清空微队列, 再获取下一个宏任务回调执行并判断</strong>, 遇到嵌套后再循环…</p><p><strong>Event Loop 事件循环:</strong> 上述讲了这么多同步异步, 宏任务微任务, 看似没有提及事件循环, 但我们一直是以它为准进行判断的; <code>Event Loop</code> 实际就是 JavaScript 异步执行机制的一种实现方式; 程序按照主线程-微任务-宏任务的顺序不断重复执行, 并始终维护各执行队列直至全部队列清空的操作就是 <code>Event Loop</code>;</p><h3 id="BOM-属性对象方法"><a href="#BOM-属性对象方法" class="headerlink" title="BOM 属性对象方法"></a>BOM 属性对象方法</h3><p><strong>参考文章</strong><br><a href="https://www.w3school.com.cn/js/js_window.asp">W3school - JavaScript Window - 浏览器对象模型</a></p><h3 id="函数柯里化及其通用封装"><a href="#函数柯里化及其通用封装" class="headerlink" title="函数柯里化及其通用封装"></a>函数柯里化及其通用封装</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903882208837645">「前端进阶」彻底弄懂函数柯里化</a><br><a href="https://juejin.cn/post/6844903638368780295">JavaScript 函数式编程</a><br><strong>题解</strong><br>前置知识:</p><ul><li>柯里化: 一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术;</li><li>JS 函数柯里化: 将一个多参函数转换成一系列使用<strong>一个或多个</strong>参数的函数;</li><li>柯里化函数执行流程: 当接收的参数数量小于原函数的形参数量(不包含默认值)时，返回一个函数用于接收剩余的参数，直至接收的参数数量与形参数量一致，执行原函数;</li><li>函数柯里化的作用: 降低函数的通用性, 提高函数的适用性, 使其拥有更高的自由度; 我们通常要求<strong>函数封装</strong>越通用越好, 这样可以适应各种应用场景, 实现<strong>函数复用</strong>, 但这也导致我们在某个场景内使用时需要重复输入参数, <strong>柯里化</strong>可以很好的实现<strong>参数复用</strong>; 常用于表单校验等, 例子见<a href="https://juejin.cn/post/6844903882208837645">「前端进阶」彻底弄懂函数柯里化</a></li></ul><p><strong>函数柯里化通用封装</strong><br>封装思路:</p><ol><li>创建一个数组用于存放已接收的参数</li><li>通过比较当前接收参数个数和目标函数的形参个数, 判断是直接执行目标函数还是继续返回函数接收参数</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-comment">// 函数柯里化</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * curry</span><br><span class="hljs-comment"> * @param &#123;Function&#125; fn // 接收被柯里化的目标函数名</span><br><span class="hljs-comment"> * @param &#123;Array&#125; arr // 存储已传递的参数</span><br><span class="hljs-comment"> * @returns // 若函数参数未传递满, 则返回函数接收剩余参数; 若传递完成则执行目标函数</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span><span class="hljs-params">(fn, arr = [])</span> </span>&#123;<br>  <span class="hljs-comment">// fn.length &lt;=&gt; arguments.callee.length : 获取函数形参个数(不包含默认值)</span><br>  let lens = fn.length;<br>  <span class="hljs-comment">// 返回一个函数接受剩余参数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 将剩余参数拼接到参数列表</span><br>    arr = arr.concat(args)<br>    <span class="hljs-keyword">if</span> (arr.length &lt; lens) &#123;<br>      <span class="hljs-comment">// 注意此处若用 apply, 需要将多个参数用 [] 包裹, 因为 apply 参数只能接受数组或类数组对象</span><br>      <span class="hljs-comment">// call 接收多个参数, 并通过 Spread 语法统一到参数数组内, 即 fn.call(context, ...args)</span><br>      <span class="hljs-comment">// apply / call 立即执行, 因此此处返回的是 func()</span><br>      <span class="hljs-keyword">return</span> curry.call(<span class="hljs-keyword">this</span>, fn, arr)<br>      <span class="hljs-comment">// return curry.apply(this, [fn, arr])</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, arr)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>函数柯里化的占位符实现</strong><br><a href="https://juejin.cn/post/6844903882208837645">「前端进阶」彻底弄懂函数柯里化</a> 还提及了函数柯里化占位符的实现, 后续有余力补充…</p><h3 id="JS-的-map-和-reduce"><a href="#JS-的-map-和-reduce" class="headerlink" title="JS 的 map() 和 reduce()"></a>JS 的 map() 和 reduce()</h3><p><strong>参考文章</strong><br><a href="https://zh.javascript.info/array-methods">数组方法</a><br><a href="https://juejin.cn/post/6844903856489365518#heading-7">一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧</a><br><a href="https://www.nowcoder.com/discuss/513379?type=post&order=jing&pos=&page=2&channel=-1&source_id=search_post_nctrack">前端秋招面经</a><br><strong>题解</strong><br><strong>Array.prototype.map()</strong><br>作用: 对数组的每个元素都调用函数，并返回结果数组;<br>语法: <code>let res = arr.map(function(item, index, array) &#123;...&#125;)</code><br><code>map&lt;U&gt;(callbackfn: (value: T, index: number, array: T[]) =&gt; U, thisArg?: any): U[];</code><br><strong>原生实现:</strong><br>循环遍历实现 map()</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myMap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callbackfn, thisArg = <span class="hljs-built_in">this</span></span>) </span>&#123;<br>  <span class="hljs-comment">// 结果数组</span><br>  <span class="hljs-keyword">let</span> res = [];<br>  <span class="hljs-comment">// 存储当前数组</span><br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-comment">// 跳过稀疏值</span><br>    <span class="hljs-keyword">if</span> (!arr.hasOwnProperty(i)) <span class="hljs-keyword">continue</span>;<br>    res.push(callbackfn.call(thisArg, arr[i], i, arr))<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>reduce 实现 map()</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myMap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callbackfn, thisArg = <span class="hljs-built_in">this</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.reduce(<span class="hljs-function">(<span class="hljs-params">pre, item, idx, array</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// reduce 会将每次的返回结果存储在下一个 pre 中</span><br>    <span class="hljs-keyword">return</span> [...pre, callbackfn.call(thisArg, item, idx, array)]<br>  &#125;, [])<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Array.prototype.reduce()</strong><br>作用: 将函数应用于所有数组元素, 并将每次返回的结果应用于下一次调用;<br>语法: <code>let value = arr.reduce(function(accumulator, item, index, array) &#123;...&#125;, [initial])</code><br><code>reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, array: T[]) =&gt; T, initialValue: T): T;</code><br><strong>原生实现:</strong><br>循环遍历实现 reduce()</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.myReduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callbackfn, initialValue</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 初始值</span><br>  <span class="hljs-keyword">let</span> startIdx = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 初始值索引</span><br>  <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">if</span> (initialValue !== <span class="hljs-literal">undefined</span>) &#123;<br>    res = initialValue<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 若没有指定初始值, 取数组中第一个有效值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!arr.hasOwnProperty(i)) <span class="hljs-keyword">continue</span>;<br>      res = arr[i];<br>      startIdx = i;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 若指定初始值, 则从0开始遍历; 反之从下一个数组值遍历(第一个作为初始值)</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = ++startIdx || <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-comment">// 寻找有效值</span><br>    <span class="hljs-keyword">if</span> (!arr.hasOwnProperty(i)) <span class="hljs-keyword">continue</span>;<br>    res = callbackfn(res, arr[i], i, arr);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="“-”和“-”的区别"><a href="#“-”和“-”的区别" class="headerlink" title="“==”和“===”的区别"></a>“==”和“===”的区别</h3><p><strong>参考文章</strong><br><a href="https://www.jianshu.com/p/6ac1397e944c">JavaScript 中 == 和 === 的区别</a><br><a href="https://juejin.cn/post/6844903694039777288">从一道面试题说起—js隐式转换踩坑合集</a><br><strong>题解</strong><br><code>==</code>操作符会先将两边的值进行强制类型转换再比较是否相等, 而<code>===</code>操作符不会进行类型转换;<br><code>==</code>操作符只要求比较两个值是否相等, 而<code>===</code>操作符不仅要求值相等, 而且要求类型相同;<br>建议: 由于<code>==</code>和<code>!=</code>带来的隐式类型转换规则非常繁琐, 以及为了避免混淆数据类型导致的 bug, 推荐使用<code>===</code>操作符和<code>!==</code>操作符;<br><strong>JS 隐式转换</strong><br>后续更新…</p><h3 id="setTimeout用作倒计时为何会产生误差？"><a href="#setTimeout用作倒计时为何会产生误差？" class="headerlink" title="setTimeout用作倒计时为何会产生误差？"></a>setTimeout用作倒计时为何会产生误差？</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/search?query=setTimeout%E7%94%A8%E4%BD%9C%E5%80%92%E8%AE%A1%E6%97%B6%E4%B8%BA%E4%BD%95%E4%BC%9A%E4%BA%A7%E7%94%9F%E8%AF%AF%E5%B7%AE&sort=2">前端进阶之setTimeout 倒计时为什么会出现误差？</a><br><a href="https://juejin.cn/post/6844903700247363592">JavaScript 倒计时踩坑集锦</a><br><strong>题解</strong><br>JS 是单线程的, 代码执行从上到下依次执行, 不同任务会被放入不同的等待队列中等待执行;<br>setTimeout 是异步宏任务, setTimeout 被执行时, 其内部回调函数会被注册并添加到宏任务队列(见宏任务/微任务), 这就意味着<strong>当回调被主线程从宏任务队列中拿出来时才会被执行, 但是! setTimeout 的计时过程在放入 <code>Event Table</code> 时就已经开始了</strong>, 这就是 setTimeout 计时器误差产生的原因;<br>此外, 如果timeout嵌套大于 5层, 而时间间隔小于4ms, 则时间间隔增加到4ms, 即多层 setTimeout 嵌套会自带误差;<br><strong>处理定时器误差</strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">function startCountdown(interval) &#123;<br>  let startTime = new Date().getTime();<br>  return setTimeout(()=&gt;&#123;<br>    let endTime = new Date().getTime();<br>    <span class="hljs-comment">&lt;!-- 定时器误差 --&gt;</span><br>    const deviation = endTime - (startTime + interval);<br>    count++;<br><br>    console.log(`$&#123;count&#125; 的延迟为 $&#123;deviation&#125; ms`);<br>    <span class="hljs-comment">&lt;!-- 消除误差 --&gt;</span><br>    startCountdown(interval - deviation)<br>  &#125;, interval)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>setInterval 的定时器误差</strong><br>setInterval 到达计时器阈值时, 会将其回调注入到宏任务队列中, 并且不断重复该过程, 但是! 回调函数是在宏任务队列等待而不是立即执行, 这就导致了定时误差, 它总是会被队列前的任务给阻塞, 并不断累积误差;</p><hr><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p><a href="https://juejin.cn/post/6844903775329583112">近一万字的ES6语法知识点补充</a></p><h3 id="let、const和var的区别-amp-变量提升与暂时性死区"><a href="#let、const和var的区别-amp-变量提升与暂时性死区" class="headerlink" title="let、const和var的区别 &amp; 变量提升与暂时性死区"></a>let、const和var的区别 &amp; 变量提升与暂时性死区</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903752139276301">var和let/const的区别</a><br><a href="https://juejin.cn/post/6844903775329583112">近一万字的ES6语法知识点补充</a><br><strong>题解</strong><br>let/const 与 var 的区别:</p><ol><li>块级作用域<code>&#123;&#125;</code>;</li><li>不存在变量提升;</li><li>暂时性死区;</li><li>不可重复声明;</li><li>let/const 声明的全局变量不会挂载在顶层对象下;</li></ol><p>let/const 声明变量时, 会创建一个块级作用域(一个花括号内是一个新的作用域), 块级作用域内声明的变量只能在其内部(包括子作用域)使用;<br>在同一作用域下, var 声明的变量可在声明前使用, 值为 undefined, let/const 在未声明时使用报错, 值得讨论的是: let/const 其实也存在变量提升的现象, 这是因为 JS 在运行阶段构建执行上下文创建变量时, 会执行函数提升和变量提升, 其声明变量会被创建并提升至作用域顶部, 与 var 不同在于, var 在执行上下文创建变量时就被初始化并赋值为 undefined, 执行时遇到赋值语句则将 undefined 替换, let/const 声明的变量同样会在该阶段被创建, 但不会初始化赋值 undefined, 变量值直到赋值语句执行时才被初始化, 若此时声明变量没有赋值, 则默认赋值 undefined (ES6 标准解释: 由let/const声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问);<br>let/const 声明变量从创建到初始化之间的代码片段称为”暂时性死区”;<br>let/const 不允许在相同作用域内重复声明同一变量;<br>ES6 规定 let/const 声明的变量不属于顶层全局变量(浏览器是windows, Node是Global)的属性, let/const 声明的变量在 Script 作用域下, 我们在使用 let/const 时就无需担心污染全局 window 对象;</p><p>const 特点:</p><ol><li>const 声明后必须初始化赋值;</li><li>const 声明的简单类型变量值不可修改, 复杂类型(对象, 函数, 正则)等在栈内存中的指针地址不能更改, 指针所指向堆内存中的数据可以更改; </li></ol><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p><strong>参考文章</strong><br><a href="https://es6.ruanyifeng.com/#docs/destructuring">ES6阮一峰: 变量的解构赋值</a><br><a href="https://juejin.cn/post/6844903752139276301">var和let/const的区别</a><br><a href="https://juejin.cn/post/6844903775329583112">近一万字的ES6语法知识点补充</a><br><strong>题解</strong><br>请移步阅读”阮一峰 ES6 入门”, 笔记后续补充…</p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p><a href="https://wangjintian.com/2021/04/15/ES6%E7%AF%87-Symbol/">ES6篇 - Symbol</a><br><strong>参考文章</strong><br><a href="https://es6.ruanyifeng.com/#docs/symbol">ES6阮一峰: Symbol</a></p><h3 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h3><p><a href="https://wangjintian.com/2021/04/16/ES6%E7%AF%87-Set&Map/">ES6篇 - Set &amp; Map</a><br><strong>参考文章</strong><br><a href="https://es6.ruanyifeng.com/#docs/set-map">ES6阮一峰: Set 和 Map 数据结构</a></p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p><strong>参考文章</strong><br><a href="https://es6.ruanyifeng.com/#docs/generator">ES6阮一峰: Generator 函数的语法</a><br><a href="https://es6.ruanyifeng.com/#docs/generator-async">ES6阮一峰: Generator 函数的异步应用</a><br><strong>题解</strong><br>Generator 函数 (一种异步编程解决方案):</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">Gen</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 3</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;world&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ending&#x27;</span>;<br>  <span class="hljs-comment">// throw new Error(&#x27;Some Errors&#x27;);</span><br>&#125;<br><br><span class="hljs-keyword">const</span> gen = Gen(); <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure><p><strong>Generator 函数基本组成:</strong></p><ol><li>Generator 是<strong>普通函数</strong>(不是构造函数); 执行 Generator 函数, 返回一个<strong>遍历器对象/指针对象</strong> (而不是直接运行函数体代码): <code>const gen = Gen()</code></li><li>Generator 函数特征: 1. <code>function* 函数名() &#123;...&#125;</code> 2. <code>yield ...</code></li><li>Genrator 可以理解为一个状态机, 封装多个内部状态(<code>yield</code>, <code>return</code>, ‘throw’);</li></ol><p><strong>yield &amp; next</strong></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs plain"><br></code></pre></div></td></tr></table></figure><ol><li>语法: <code>yield 表达式</code>; <code>迭代器对象.next()</code></li><li>特点: yield 是 Generator 的暂停标志; 配合迭代器对象的 next 方法可以手动控制函数分步执行;</li><li>运行逻辑: 每一次执行迭代器对象的 next 方法, 会基于当前暂停位置恢复函数执行, 指针指向下一个 yield 暂停标志, 并执行 yield 表达式, next 方法会返回一个 <code>&#123;value:xxx, done: xxx&#125;</code> 对象, 其中 value 为 yield 表达式的值;</li><li>注意事项:</li></ol><ul><li>yield 表达式<strong>惰性求值</strong>, 只有当指针对象(迭代器对象)调用 next 方法将指针指向该语句时才会运算求值;</li><li>yield 表达式只能用在 Generator 函数内;</li><li>yield 表达式用在另一个表达式内时需要用括号包裹;</li></ul><p>yield 是 Generator 函数暂停执行的标志, 它将 Generator 函数体分隔为多个状态, 需要配合 next 方法使用;</p><p>后续补充…</p><hr><h2 id="手撕代码"><a href="#手撕代码" class="headerlink" title="手撕代码"></a>手撕代码</h2><p><a href="https://github.com/jtwang7/Code-Shredded">GitHub - 手撕代码篇</a><br><a href="https://juejin.cn/post/6844903989083897870">各种源码实现，你想要的这里都有</a></p><h3 id="Promise-A-规范-及其常用方法"><a href="#Promise-A-规范-及其常用方法" class="headerlink" title="Promise(A+规范)及其常用方法"></a>Promise(A+规范)及其常用方法</h3><p><strong>参考文章</strong><br><a href="http://www.fly63.com/article/detial/2071">手写一款符合Promise/A+规范的Promise</a><br><strong>题解</strong><br>自己实现的Promise: <a href="https://github.com/jtwang7/Code-Shredded/blob/master/PromiseA%2B/MyPromise-NoAnnotation.js">Promise A+ – 无注释版</a><br>符合A+规范: 在文件路径下添加 defer 方法并运行 <code>promises-aplus-tests [文件名.js]</code></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建 MyPromise 类;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;<br>  <span class="hljs-comment">// 实例化时接收 executor 函数;</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">executor</span>)</span> &#123;<br>    <span class="hljs-comment">// 管理状态/值/错误信息;</span><br>    <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;pending&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-built_in">this</span>.error = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-comment">// 队列: 存储回调; </span><br>    <span class="hljs-comment">// 解决 executor 内异步操作导致 then 执行时状态仍为 pending 的情况(保存 then 回调, 在状态改变清空队列); </span><br>    <span class="hljs-comment">// 解决多个 then 调用;</span><br>    <span class="hljs-built_in">this</span>.onFulfilledCallbacks = [];<br>    <span class="hljs-built_in">this</span>.onRejectedCallbacks = [];<br>    <span class="hljs-comment">// resolve() 改变状态/存储值;</span><br>    <span class="hljs-built_in">this</span>.resolve = <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有当 pending 状态时执行, 即状态改变不可逆</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 改变状态</span><br>        <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br>        <span class="hljs-comment">// 存储值</span><br>        <span class="hljs-built_in">this</span>.value = val;<br>        <span class="hljs-comment">// 清空成功回调队列</span><br>        <span class="hljs-built_in">this</span>.onFulfilledCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn());<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// reject() 改变状态/存储错误信息;</span><br>    <span class="hljs-built_in">this</span>.reject = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br>        <span class="hljs-built_in">this</span>.error = err;<br>        <span class="hljs-comment">// 清空拒绝回调队列</span><br>        <span class="hljs-built_in">this</span>.onRejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn());<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 实例化时自动执行 executor (利用了 constructor 自动执行的特点);</span><br>    executor(<span class="hljs-built_in">this</span>.resolve, <span class="hljs-built_in">this</span>.reject);<br>  &#125;<br>  <span class="hljs-comment">// then 方法: 接收两个回调函数;</span><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>)</span> &#123;<br>    <span class="hljs-comment">// 确保传入的是函数类型, 若没有传入或传入不是函数类型则取默认值;</span><br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val;<br>    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> err &#125;;<br>    <span class="hljs-comment">// 链式调用: 返回新的 MyPromise 实例;</span><br>    <span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// fulfilled 状态执行;</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&#x27;fulfilled&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 利用 setTimeout 宏任务模拟原生 Promise then() 微任务, 确保 then 在同步代码清空后执行;</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// try...catch... 确保错误抛出被正确捕获;</span><br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 接收回调返回值作为下一次 then() 回调函数的参数</span><br>            <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-built_in">this</span>.value);<br>            <span class="hljs-comment">// 判断回调返回值</span><br>            <span class="hljs-built_in">this</span>._resolvePromise(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>            reject(err);<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-comment">// rejected 状态执行;</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.error);<br>            <span class="hljs-built_in">this</span>._resolvePromise(promise2, x, resolve, reject);<br>          &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>            reject(err);<br>          &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-comment">// pending 状态执行;</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 仍处于 pending 意味着异步还未完成, 将回调保存至回调队列;</span><br>        <span class="hljs-built_in">this</span>.onFulfilledCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 此处 this.value 在清空队列时才被赋值;</span><br>              <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-built_in">this</span>.value);<br>              <span class="hljs-built_in">this</span>._resolvePromise(promise2, x, resolve, reject);<br>            &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>              reject(err);<br>            &#125;<br>          &#125;, <span class="hljs-number">0</span>)<br>        &#125;);<br>        <span class="hljs-built_in">this</span>.onRejectedCallbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.error);<br>              <span class="hljs-built_in">this</span>._resolvePromise(promise2, x, resolve, reject);<br>            &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>              reject(err)<br>            &#125;<br>          &#125;, <span class="hljs-number">0</span>)<br>        &#125;);<br>      &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> promise2;<br>  &#125;<br>  <span class="hljs-comment">// 回调返回值判断;</span><br>  <span class="hljs-function"><span class="hljs-title">_resolvePromise</span>(<span class="hljs-params">promise2, x, resolve, reject</span>)</span> &#123;<br>    <span class="hljs-comment">// 返回 MyPromise 实例本身会导致循环引用, 报错并终止;</span><br>    <span class="hljs-keyword">if</span> (promise2 === x) &#123;<br>      reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Chaining cycle detected for promise&#x27;</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// then 方法内可能存在多次调用 resolve/reject 的情况, 我们只期望执行最开始的 resolve/reject;</span><br>    <span class="hljs-comment">// 通过 called 变量维护上述操作;</span><br>    <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 返回值是 object 或 function 类型且不为空时, 进一步判断;</span><br>    <span class="hljs-comment">// 否则意味着返回值是原始类型, 直接传递给 promise2 then 的回调函数;</span><br>    <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>      <span class="hljs-comment">// try...catch.. 捕获运行 then 方法可能引发的错误;</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 判断 x 是否为 MyPromise 实例: 看它的 then 是否是函数;</span><br>        <span class="hljs-keyword">let</span> then = x.then;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>          <span class="hljs-comment">// 是函数说明 x 是 MyPromise 实例, 通过 call 立即调用执行(因为下一个 then 要的是值而不是 MyPromise 实例);</span><br>          <span class="hljs-comment">// then.call(thisArg, successFunc, rejectFunc);</span><br>          then.call(x, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>            <span class="hljs-comment">// 若 called 为 true 则说明执行过 resolve/reject, 不再执行;</span><br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">this</span>._resolvePromise(x, val, resolve, reject);<br>          &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>            called = <span class="hljs-literal">true</span>;<br>            reject(err);<br>          &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          resolve(x)<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span>;<br>        called = <span class="hljs-literal">true</span>;<br>        reject(err);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      resolve(x);<br>    &#125;<br>  &#125;<br>&#125;<br><br>MyPromise.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (val <span class="hljs-keyword">instanceof</span> MyPromise) <span class="hljs-keyword">return</span> val;<br>  <span class="hljs-comment">// 改变状态为 fulfilled;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(val);<br>  &#125;)<br>&#125;<br><br>MyPromise.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>  <span class="hljs-comment">// 改变状态为 rejected;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    reject(err);<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 等价于执行 then 的第二个回调函数;</span><br>MyPromise.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onRejected</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onRejected)<br>&#125;<br><br><span class="hljs-comment">// 接收 promise 对象数组, 当全部 promise 对象 resolve 时执行 onFulfilled 方法;</span><br><span class="hljs-comment">// 当有一个 promise 对象 reject 时执行 onRejected 方法;</span><br><span class="hljs-comment">// 成功执行的结果按 promise 对象数组的顺序来排放;</span><br>MyPromise.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> lens = promises.length;<br>    <span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(lens);<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 依据索引顺序存放;</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processData</span>(<span class="hljs-params">data, idx</span>) </span>&#123;<br>      arr[idx] = data;<br>      count++;<br>      <span class="hljs-comment">// 若所有 promises 均成功执行回调, 返回结果数组;</span><br>      <span class="hljs-comment">// processData() 写在 MyPromise 内就不需要传递 resolve() 了, 会自动向上索引引用;</span><br>      <span class="hljs-keyword">if</span> (count === lens) resolve(arr);<br>    &#125;<br>    promises.forEach(<span class="hljs-function">(<span class="hljs-params">item, idx</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 遍历 promises 数组, fulfilled 执行成功回调, 存放数据, rejected 执行拒绝回调, 直接退出遍历;</span><br>      item.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        processData(res, idx);<br>      &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> reject(err))<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 接收 promise 对象数组, 返回最先完成的 promise 对象, 不关心它的状态(fulfilled, rejected);</span><br>MyPromise.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    promises.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 遍历数组, 若某 promise 状态落定, 则改变状态并结束遍历;</span><br>      item.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> resolve(res), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> reject(err))<br>    &#125;)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 无论 promise 状态如何, 都会执行 fn 回调</span><br>MyPromise.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<br>    <span class="hljs-comment">// resolve() 保证 fn() 必被执行</span><br>    <span class="hljs-comment">// 后续跟上 then() 用于传递 value 或 error;</span><br>    val =&gt; MyPromise.resolve(fn()).then(<span class="hljs-function">() =&gt;</span> val),<br>    err =&gt; MyPromise.resolve(fn()).then(<span class="hljs-function">() =&gt;</span> err)<br>  )<br>&#125;<br><br><span class="hljs-comment">// 实现一个promise的延迟对象 defer, 用于 Promise A+ 规范测试</span><br>MyPromise.defer = MyPromise.deferred = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> dfd = &#123;&#125;;<br>  dfd.promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    dfd.resolve = resolve;<br>    dfd.reject = reject;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> dfd;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = MyPromise;<br></code></pre></div></td></tr></table></figure><h3 id="Iterator-迭代器实现-amp-Iterable-可迭代对象实现"><a href="#Iterator-迭代器实现-amp-Iterable-可迭代对象实现" class="headerlink" title="Iterator 迭代器实现 &amp; Iterable 可迭代对象实现"></a>Iterator 迭代器实现 &amp; Iterable 可迭代对象实现</h3><p><strong>参考文章</strong><br><a href="https://github.com/yueshuiniao/blog/issues/2">理解ES6的 Iterator 、Iterable 、 Generator</a><br><a href="https://zh.javascript.info/iterable">Iterable object（可迭代对象）</a><br><strong>题解</strong><br><strong>Iterator 迭代器:</strong> 满足迭代器协议的对象;<br>迭代器协议: 对象内置 next() 方法, next() 方法是一个无参函数, 其返回一个对象, 对象拥有 done 和 value 两个属性;</p><ol><li>done(boolean): </li></ol><ul><li><code>done === true</code>, 表示迭代器已经经过了被迭代序列(并非表示不可迭代);</li><li><code>done === false</code>, 表示迭代器可以产生序列中的下一个值;</li></ul><ol start="2"><li>value: 迭代器返回的任意值, <code>done == true</code> 时可省略, value 省略值为 undefined;</li></ol><p>简单理解: 迭代器就是在目标上创建了一个 next() 模拟”指针”, 每次调用 next(), “指针”右移一位, 并返回当前”指针”所指的状态(done)和值(value); 你可以将迭代器理解为一个带由内置指针实现的对象, next() 实现指针操作, 每次执行 next(), 指针会返回当前所指的值和状态, 然后指针右移一位;<br><strong>注意:</strong> <code>done === true</code> 并不代表迭代器无法使用了, 此时仍可以调用 next(), “指针”仍然右移, 但其返回值为自定义值或省略值(此处为 undefined)而非被迭代序列的内部值;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIterator</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  <span class="hljs-comment">// 迭代器实现用到了函数闭包的特性;</span><br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 1. 迭代器: 一个对象(满足迭代器协议), 包含一个 next() 方法;</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-comment">// 2. next() 方法;</span><br>    <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">let</span> done = (i &gt;= target.length);<br>      <span class="hljs-keyword">let</span> value = done ? <span class="hljs-literal">undefined</span> : target[i++];<br>      <span class="hljs-comment">// 返回包含 done 和 value 属性的对象;</span><br>      <span class="hljs-keyword">return</span> &#123; done, value &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Iterable 可迭代对象:</strong> 满足可迭代协议的对象;<br>可迭代协议: 对象包含 [Symbol.iterator] 属性(Symbol 在对象中通过 [] 调用), 其值是一个无参函数, 该函数返回一个迭代器;<br>ES6 内置可迭代对象:</p><ol><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>arguments</li><li>NodeList</li></ol><p>可迭代对象可被用于: </p><ol><li>for…of…</li><li>扩展运算符(…)</li><li>yield*</li><li>解构赋值</li></ol><p>注意: </p><ol><li>迭代器对象不能用于 for…of, 解构赋值等操作, 需要包装成可迭代对象;</li><li>for..of, 解构赋值等操作都会”消耗”迭代器(迭代一遍后, 可迭代对象内的迭代器 done === ture), 因此无法多次对同一可迭代对象执行迭代操作;</li></ol><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 可迭代对象实现: 包装一个迭代器, 并通过 [Symbol.iterator] 暴露;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIterable</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-comment">// 比迭代器多实现了一个 [Symbol.iterator], 返回迭代器;</span><br>    [<span class="hljs-built_in">Symbol</span>.iterator]() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;,<br><br>    <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">let</span> done = (i &gt;= target.length);<br>      <span class="hljs-keyword">let</span> value = !done ? target[i++] : <span class="hljs-literal">undefined</span>;<br>      <span class="hljs-keyword">return</span> &#123; done, value &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>普通对象没有实现可迭代协议, 我们可以向 Object 原型内添加 <code>[Symbol.iterator]</code> 属性, 使其成为可迭代对象;</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 将对象转为数组[[key,value],...]</span><br>  <span class="hljs-keyword">let</span> target = <span class="hljs-built_in">Object</span>.entries(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">let</span> done = (i &gt;= target.length)<br>      <span class="hljs-keyword">let</span> value = !done ? target[i++] : <span class="hljs-literal">undefined</span>;<br>      <span class="hljs-keyword">return</span> &#123; done, value &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Thunk函数实现（结合Generator实现异步）"><a href="#Thunk函数实现（结合Generator实现异步）" class="headerlink" title="Thunk函数实现（结合Generator实现异步）"></a>Thunk函数实现（结合Generator实现异步）</h3><p><strong>参考文章</strong><br><a href="https://segmentfault.com/a/1190000012685168">理解thunk函数的作用及co的实现</a><br><a href="https://zh.javascript.info/generators">Generator</a><br><strong>题解</strong><br>后续补充…</p><h3 id="async实现原理（spawn函数）"><a href="#async实现原理（spawn函数）" class="headerlink" title="async实现原理（spawn函数）"></a>async实现原理（spawn函数）</h3><p><strong>参考文章</strong><br><a href="https://segmentfault.com/a/1190000022638499">Async / Await / Generator 实现原理</a><br><strong>题解</strong><br>后续补充…</p><h3 id="继承的几种实现与比较"><a href="#继承的几种实现与比较" class="headerlink" title="继承的几种实现与比较"></a>继承的几种实现与比较</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903854463516685">隔壁小孩也能看懂的 7 种 JavaScript 继承实现</a><br><a href="https://juejin.cn/post/6844903810767421447">重学 JS 系列：聊聊继承</a><br><strong>题解</strong><br><strong>原型链继承</strong></p><ul><li>所有实例共享父类属性和方法(共享同一内存空间);</li><li>若内存空间内的值被修改, 所有继承的子类实例值都会发生改变;</li><li>子类不能向父类传参;<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> Parent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Siri&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.hobby = [];<br>  <span class="hljs-built_in">this</span>.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi &#x27;</span> + <span class="hljs-built_in">this</span>.name);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> Child = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.action = <span class="hljs-string">&#x27;eat&#x27;</span>;<br>&#125;<br>&lt;!-- 子类原型连接父实例 --&gt;<br>&lt;!-- 不能通过父子原型直接连接 --&gt;<br>Child.prototype = <span class="hljs-keyword">new</span> Parent();<br></code></pre></div></td></tr></table></figure></li></ul><p><strong>构造函数继承</strong></p><ul><li>避免了引用类型的属性被所有实例共享;</li><li>可以在child中向parent传参;</li><li>子类每次实例化都创建一个 this, 挂载所有父类属性和方法, 导致一些共享方法重复创建;<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> Parent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Siri&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.hobby = [];<br>  <span class="hljs-built_in">this</span>.age = age;<br>  <span class="hljs-built_in">this</span>.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi &#x27;</span> + <span class="hljs-built_in">this</span>.name);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> Child = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// call 执行父类构造函数, 将父类所有属性方法挂载到子类 this 上;</span><br>  Parent.call(<span class="hljs-built_in">this</span>, <span class="hljs-number">18</span>);<br>  <span class="hljs-built_in">this</span>.action = <span class="hljs-string">&#x27;eat&#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p><strong>组合式继承</strong><br>原型链继承特点: 共享父类属性和方法; 构造函数继承特点: 各子类实例有独立的属性和方法;<br>我们期望各子类实例能共享父类的方法, 同时能维护自己的属性;<br>组合式继承: 在父类原型上定义方法, 在父类构造函数内定义属性, 子类通过原型链继承实现对函数的复用，通过构造函数继承保证每个实例都有它自己的属性;</p><ul><li>子类实例能维护自己的属性, 同时共享父类方法;</li><li>组合式继承最大的缺点在于其调用两次父构造函数, 一次是设置子类实例的原型的时候, 一次是在创建子类型实例的时候; 这导致实例对象和原型对象上的属性值重复, 子类索引父类属性时，会优先在实例对象上找到属性, 不会继续通过原型链向原型对象查找，而这部分原型对象上的属性值就浪费了存储空间;</li><li>组合式继承的缺点在后续寄生式组合继承中解决;<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> Parent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">age</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Siri&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.hobby = [];<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>Parent.prototype.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi &#x27;</span> + <span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><span class="hljs-keyword">let</span> Child = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 属性通过构造函数继承;</span><br>  Parent.call(<span class="hljs-built_in">this</span>, <span class="hljs-number">18</span>);<br>  <span class="hljs-built_in">this</span>.action = <span class="hljs-string">&#x27;eat&#x27;</span>;<br>&#125;<br><span class="hljs-comment">// 共享方法通过原型链继承;</span><br>Child.prototype = <span class="hljs-keyword">new</span> Parent();<br></code></pre></div></td></tr></table></figure></li></ul><p><strong>原型式继承</strong></p><ul><li>创建空的构造函数, 连接原型, 返回构造函数的实例; 实例可以通过原型链访问到传入对象;</li><li>ES5 通过 Object.create() 规范化了原型式继承;</li><li>原型式继承与原型链继承类似, 引用类型的属性值始终会共享相应的值;<figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span><span class="hljs-params">(obj)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>  F.prototype = obj;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p><strong>寄生组合式继承</strong></p><ul><li>组合式继承中两次调用了父类构造函数, 导致子类实例对象中包含了父类属性, 其原型对象也挂载了父类属性, 而索引父类属性时在子类实例中找到属性则停止索引, 其原型对象的父类属性占用了空间导致内存浪费;</li><li>*寄生组合关键在于其用临时空构造函数代替了父类构造函数完成了原型链继承, 只改变空构造函数原型指向获取父类原型, 获取其原型上的共享方法, 而不挂载父类构造函数的属性, 从而避免了内存浪费;<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> Parent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Siri&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.hobby = [];<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>Parent.prototype.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi &#x27;</span> + <span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><span class="hljs-keyword">let</span> Child = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 构造函数继承;</span><br>  Parent.call(<span class="hljs-built_in">this</span>, <span class="hljs-number">18</span>);<br>  <span class="hljs-built_in">this</span>.action = <span class="hljs-string">&#x27;eat&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 关键: 用临时空构造函数仅接收父类原型的共享方法, 而不挂载父类的属性;</span><br><span class="hljs-keyword">let</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>F.prototype = Parent.prototype;<br><span class="hljs-comment">// 原型链继承;</span><br>Child.prototype = <span class="hljs-keyword">new</span> F();<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903854463516685">隔壁小孩也能看懂的 7 种 JavaScript 继承实现</a><br><a href="https://juejin.cn/post/6844903810767421447">重学 JS 系列：聊聊继承</a><br><strong>题解</strong></p><ul><li>子类必须在 constructor 方法中调用 super方法 (子类没有 this 对象, 其 this 继承于父类);</li><li>只有调用 super 之后, 才可以使用 this 关键字, 这是因为子类实例的构建, 是基于对父类实例加工, 只有 super 方法才能返回父类实例;</li></ul><p>与 ES5 构造函数继承的区别:<br>ES5 的继承实质是先创造子类的实例对象 this, 然后再将父类的方法添加到 this 上面(Parent.call(this));<br>ES6 的继承机制实质是先创造父类的实例对象 this (所以必须先调用 super() 方法), 然后再用子类的构造函数修改 this;</p><figure class="highlight scala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">parents</span> </span>&#123;<br>  constructor()&#123;<br>    <span class="hljs-keyword">this</span>.grandmather = <span class="hljs-symbol">&#x27;ros</span>e&#x27;;<br>    <span class="hljs-keyword">this</span>.grandfather = <span class="hljs-symbol">&#x27;jac</span>k&#x27;;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">children</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">parents</span></span>&#123;<br>  constructor(mather,father)&#123;<br>    <span class="hljs-comment">//super 关键字，表示父类的构造函数，用来新建父类的 this 对象。</span><br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-keyword">this</span>.mather = mather;<br>    <span class="hljs-keyword">this</span>.father = father;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="防抖和节流-1"><a href="#防抖和节流-1" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p><strong>参考文章</strong><br><a href="https://juejin.cn/post/6844903651278848014">函数防抖和节流</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/22">JavaScript专题之跟着underscore学防抖</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/26">JavaScript专题之跟着 underscore 学节流</a><br><a href="https://github.com/Bulandent/blog/issues/28">死磕 36 个 JS 手写题</a><br><strong>题解</strong><br><strong>非立即执行版防抖</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span><span class="hljs-params">(fn, wait )</span> </span>&#123;<br>  let timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>;<br>    clearTimeout(timer)<br>    timer = setTimeout(() =&gt; &#123;<br>      fn.call(ctx, args)<br>    &#125;, wait)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>立即执行版防抖</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span><span class="hljs-params">(fn, wait)</span> </span>&#123;<br>  let timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>;<br>    clearTimeout(timer);<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      fn.call(ctx, args);<br>    &#125;<br>    timer = setTimeout(() =&gt; &#123;<br>      timer = <span class="hljs-literal">null</span><br>    &#125;, wait)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>合并版防抖</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span><span class="hljs-params">(fn, wait, immediate)</span> </span>&#123;<br>  let timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>;<br>    timer &amp;&amp; clearTimeout(timer)<br>    <span class="hljs-keyword">if</span> (immediate) &#123;<br>      let callNow = !timer;<br>      timer = setTimeout(()=&gt;&#123;<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;, wait)<br>      <span class="hljs-keyword">if</span> (callNow) fn.call(ctx, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timer = setTimeout(()=&gt;&#123;<br>        fn.call(ctx, args)<br>      &#125;, wait)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong><em>防抖关键: 每次执行函数前, 清空上一次的计时器, 并在回调执行后设置新的计时器;</em></strong></p><p><strong>非立即执行版节流</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span><span class="hljs-params">(fn, wait)</span> </span>&#123;<br>  let timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = setTimeout(() =&gt; &#123;<br>        fn.call(ctx, args);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;, wait)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>立即执行版节流</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span><span class="hljs-params">(fn, wait)</span> </span>&#123;<br>  let preTime = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>;<br>    let curTime = <span class="hljs-keyword">new</span> Date().getTime();<br>    <span class="hljs-keyword">if</span> (curTime - preTime &gt; wait) &#123;<br>      fn.call(ctx, args);<br>      preTime = <span class="hljs-keyword">new</span> Date().getTime();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>合并版节流</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span><span class="hljs-params">(fn, wait)</span> </span>&#123;<br>  let timer = <span class="hljs-literal">null</span>, preTime = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>;<br>    let curTime = <span class="hljs-keyword">new</span> Date().getTime();<br>    <span class="hljs-keyword">if</span> (curTime - preTime &gt; wait) &#123;<br>      <span class="hljs-keyword">if</span> (timer) &#123;<br>        clearTimeout(timer);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;<br>      fn.call(ctx, args);<br>      preTime = <span class="hljs-keyword">new</span> Date().getTime();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer) &#123;<br>      timer = setTimeout(()=&gt;&#123;<br>        preTime = <span class="hljs-keyword">new</span> Date().getTime();<br>        fn.call(ctx, args);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;,wait-(curTime-preTime))<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>可控的合并版节流</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript"><span class="hljs-comment">// options.leading === false: 禁用立即执行</span><br><span class="hljs-comment">// options.trailing === false: 禁用非立即执行</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span><span class="hljs-params">(fn, wait, options)</span> </span>&#123;<br>  let timer = <span class="hljs-literal">null</span>, preTime = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>;<br>    let curTime = <span class="hljs-keyword">new</span> Date().getTime();<br>    <span class="hljs-keyword">if</span> (!options.leading &amp;&amp; preTime === <span class="hljs-number">0</span>) preTime = curTime;<br>    <span class="hljs-keyword">if</span> (curTime - preTime &gt; wait) &#123;<br>      <span class="hljs-keyword">if</span> (timer) &#123;<br>        clearTimeout(timer);<br>        timer = <span class="hljs-literal">null</span>;<br>      &#125;<br>      fn.call(ctx, args);<br>      preTime = <span class="hljs-keyword">new</span> Date().getTime();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer &amp;&amp; options.trailing) &#123;<br>      timer = setTimeout(() =&gt; &#123;<br>        fn.call(ctx, args);<br>        timer = <span class="hljs-literal">null</span>;<br>        preTime = options.leading ? <span class="hljs-keyword">new</span> Date().getTime() : <span class="hljs-number">0</span>;<br>      &#125;, wait - (curTime - preTime))<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong><em>节流关键: 设置一个开关(关闭状态无法执行回调), 回调执行时, 关闭开关并计时, 计时结束打开开关, 与防抖区别在于它不需要在每次触发函数时重置开关;</em></strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端小记</title>
    <link href="/2021/04/02/%E5%89%8D%E7%AB%AF%E5%B0%8F%E8%AE%B0/"/>
    <url>/2021/04/02/%E5%89%8D%E7%AB%AF%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包篇"><a href="#闭包篇" class="headerlink" title="闭包篇"></a>闭包篇</h1><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p><a href="https://juejin.cn/post/6844903606311714824">深入理解闭包之前置知识→作用域与词法作用域</a></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><a href="https://juejin.cn/post/6844903612879994887">闭包详解一</a><br><a href="https://juejin.cn/post/6844903616885555214">闭包详解二：JavaScript中的高阶函数</a></p><h1 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h1><p><a href="https://juejin.cn/post/6844903797039300615">图解原型和原型链</a> <strong>PS:个人认为非常适合初入了解的一篇文章</strong><br><a href="https://juejin.cn/post/6844904093828251662">2020面试收获 - js原型及原型链</a></p><h1 id="设计模式篇"><a href="#设计模式篇" class="headerlink" title="设计模式篇"></a>设计模式篇</h1><h2 id="Vue双向绑定-发布订阅-数据劫持"><a href="#Vue双向绑定-发布订阅-数据劫持" class="headerlink" title="Vue双向绑定(发布订阅 + 数据劫持)"></a>Vue双向绑定(发布订阅 + 数据劫持)</h2><blockquote><p>该部分较难理解,但该部分是Vue响应式原理的重要体现,请仔细阅读,并动手实现!</p></blockquote><p><a href="https://juejin.cn/post/6844903903822086151">0 到 1 掌握：Vue 核心之数据双向绑定</a> <strong>很详细的代码解释</strong><br><a href="https://juejin.cn/post/6844903601416978439">面试官: 实现双向绑定Proxy比defineproperty优劣如何?</a> <strong>PS:Vue3的双向绑定趋势 – Proxy</strong></p><h2 id="设计模式-发布订阅-amp-观察者模式"><a href="#设计模式-发布订阅-amp-观察者模式" class="headerlink" title="设计模式(发布订阅 &amp; 观察者模式)"></a>设计模式(发布订阅 &amp; 观察者模式)</h2><p><a href="https://juejin.cn/post/6844903698154389517">JavaScript设计模式</a> <strong>前半部分为发布订阅代码实现,后半部分为Vue双向绑定</strong><br><a href="https://juejin.cn/post/6844903587043082247">面试官:既然React/Vue可以用Event Bus进行组件通信,你可以实现下吗?</a> <strong>发布订阅实现Event Bus</strong></p><blockquote><p>自己实现了一个EventBus, 主要就用到了发布订阅模式, 通过 emit 发布信息(参数), on 接收信息并执行回调. 参考 <a href="https://wangjintian.com/2021/04/02/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0EventBus/">简单实现EventBus</a></p></blockquote><p><a href="https://juejin.cn/post/6844903556714070024">从vue源码看观察者模式</a><br><a href="https://juejin.cn/post/6844903603107266567">不好意思，观察者模式跟发布订阅模式就是不一样</a> <strong>发布订阅与观察者模式的区别? 评论各执己见,酌情参考</strong></p><h1 id="组件通信篇"><a href="#组件通信篇" class="headerlink" title="组件通信篇"></a>组件通信篇</h1><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p><a href="https://juejin.cn/post/6844903887162310669">vue中8种组件通信方式</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单实现EventBus</title>
    <link href="/2021/04/02/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0EventBus/"/>
    <url>/2021/04/02/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0EventBus/</url>
    
    <content type="html"><![CDATA[<h1 id="EventBus-原理"><a href="#EventBus-原理" class="headerlink" title="EventBus 原理"></a>EventBus 原理</h1><p>通过维护类内的一个的受保护属性, 将<code>emit</code>发送的事件及参数存储, 并通过<code>on</code>监听事件并接收参数执行回调.<br>事件的存储和检索都通过 Map 来完成, Map 可以存储任何类型的键名, 非常适合检索工作.</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义EventEmitter类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._events = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// 存储事件</span><br>    <span class="hljs-built_in">this</span>._maxListnersNum = <span class="hljs-number">10</span>; <span class="hljs-comment">// 设置最大监听数上限</span><br>  &#125;<br>  <span class="hljs-comment">// 发送事件 (同Vue.$emit())</span><br>  <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">event, ...args</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>._events.get(event)) &#123;<br>      <span class="hljs-built_in">this</span>._events.set(event, args); <span class="hljs-comment">// 将事件名和对应传递参数保存</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 监听事件并出发回调 (同Vue.on())</span><br>  <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">event, callback</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> payload = <span class="hljs-built_in">this</span>._events.get(event); <span class="hljs-comment">// 执行时触发,监听事件名是否存在</span><br>    <span class="hljs-keyword">if</span> (payload &amp;&amp; payload.length &gt; <span class="hljs-number">0</span>) &#123;<br>      callback.apply(<span class="hljs-built_in">this</span>, payload); <span class="hljs-comment">// 通过 call/apply 方法触发回调</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      callback.call(<span class="hljs-built_in">this</span>, payload);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 移除事件监听</span><br>  <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">event</span>)</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-built_in">this</span>._events.has(event)</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>._events.delete(event);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;No Event&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = EventEmitter;<br></code></pre></div></td></tr></table></figure><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> EventEmitter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./eventEmitter&#x27;</span>);<br><br><span class="hljs-keyword">const</span> eventEmitter = <span class="hljs-keyword">new</span> EventEmitter();<br><br>eventEmitter.emit(<span class="hljs-string">&#x27;sayHi&#x27;</span>, &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Siri&#x27;</span>,<span class="hljs-attr">text</span>:<span class="hljs-string">&#x27;Hi&#x27;</span>&#125;);<br>eventEmitter.on(<span class="hljs-string">&#x27;sayHi&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;name,text&#125;</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;text&#125;</span> <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>&#125;)<br><br>eventEmitter.off(<span class="hljs-string">&#x27;sayHi&#x27;</span>)<br>eventEmitter.on(<span class="hljs-string">&#x27;sayHi&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(val);<br>&#125;)<br><br><span class="hljs-comment">// result</span><br><span class="hljs-comment">// Hi Siri</span><br><span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>登录及Token校验</title>
    <link href="/2021/03/29/%E7%99%BB%E5%BD%95%E5%8F%8AToken%E6%A0%A1%E9%AA%8C/"/>
    <url>/2021/03/29/%E7%99%BB%E5%BD%95%E5%8F%8AToken%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="登录及Token校验"><a href="#登录及Token校验" class="headerlink" title="登录及Token校验"></a>登录及Token校验</h1><h2 id="登录系统工作流程梳理"><a href="#登录系统工作流程梳理" class="headerlink" title="登录系统工作流程梳理"></a>登录系统工作流程梳理</h2><ol><li>进入页面，默认重定向到应用页面，但在路由跳转前，先判断浏览器中是否存储 token，若没有 token 且跳转的页面不是登陆页面，则中断本次跳转并强制跳转到登陆页面。</li><li>输入用户名与密码，发送至后端校验，若校验成功，后端生成 token 并返回，前端将其存储至 localStorage 和 vuex</li><li>同理，在应用页面路由跳转时，每次跳转始终向后端发送校验请求，一旦失败，表明 token 已过期，自动跳转至登陆页面，重新登陆。</li></ol><h2 id="后端逻辑-egg"><a href="#后端逻辑-egg" class="headerlink" title="后端逻辑 (egg)"></a>后端逻辑 (egg)</h2><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-comment">// 导入 jwt</span><br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>);<br><span class="hljs-keyword">const</span> Service = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;egg&#x27;</span>).Service;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br>  app =  <span class="hljs-built_in">this</span>.app;<br>  <span class="hljs-comment">// jwt 的密钥，字符串内容可自定义</span><br>  secret = <span class="hljs-string">&#x27;MADEBYWANGJT&#x27;</span>;<br><br>  <span class="hljs-comment">// 当浏览器中没有 token 时触发用户名密码登录函数</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">passwordVerify</span>(<span class="hljs-params">&#123; account, password &#125;</span>)</span> &#123;<br>    <span class="hljs-comment">// if not exist: got []</span><br>    <span class="hljs-comment">// if exist: got [ &#123;account:string, password:string, token:null, id:number&#125; ]</span><br>    <span class="hljs-keyword">const</span> [user] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.app.mysql.select(<span class="hljs-string">&#x27;login&#x27;</span>, &#123;<br>      where: &#123; account &#125;<br>    &#125;)<br><br>    <span class="hljs-comment">// 用户名不存在</span><br>    <span class="hljs-keyword">if</span> (user === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> &#123;<br>      state: <span class="hljs-number">401</span>,<br>      message: <span class="hljs-string">&#x27;ACCOUNT NOT EXISTED&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (user.password === password) &#123;<br>      <span class="hljs-keyword">if</span> (user.token === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// jwt.sign() 参数配置</span><br>        <span class="hljs-comment">// payload 负载：可自定义，若 jwt.verify() 校验成功，会显示在 decoded 内</span><br>        <span class="hljs-keyword">const</span> payload = &#123;<br>          name: account,<br>          admin: <span class="hljs-literal">true</span>,<br>        &#125;<br>        <span class="hljs-comment">// jwt.sign(payload,secret,options)</span><br>        <span class="hljs-comment">// 作用：生成 token</span><br>        <span class="hljs-comment">// options 可参照 npm jwt 的内容</span><br>        <span class="hljs-keyword">const</span> tk = jwt.sign(<br>          payload,<br>          <span class="hljs-built_in">this</span>.secret,<br>          &#123;<br>            <span class="hljs-comment">// 加密方式</span><br>            algorithm: <span class="hljs-string">&#x27;HS256&#x27;</span>,<br>            <span class="hljs-comment">// 有效时间</span><br>            expiresIn: <span class="hljs-string">&#x27;2 hours&#x27;</span>,<br>          &#125;<br>        )<br>        <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.app.mysql.update(<span class="hljs-string">&#x27;login&#x27;</span>, &#123;<br>          id: user.id,<br>          token: tk,<br>        &#125;);<br>        <span class="hljs-keyword">return</span> &#123;<br>          state: <span class="hljs-number">201</span>,<br>          token: tk,<br>        &#125;;<br>      &#125;<br>      <span class="hljs-keyword">return</span> &#123;<br>        state: <span class="hljs-number">201</span>,<br>        token: user.token,<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>      state: <span class="hljs-number">401</span>,<br>      message: <span class="hljs-string">&#x27;PASSWORD ERROR&#x27;</span>,<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 若已知 token, 则进行 token 校验</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">tokenVerify</span>(<span class="hljs-params">&#123; account, token &#125;</span>)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">let</span> decoded = jwt.verify(token, <span class="hljs-built_in">this</span>.secret);<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;校验成功&#x27;</span>);<br>      <span class="hljs-keyword">return</span> &#123;<br>        state: <span class="hljs-number">200</span>,<br>        decoded<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-comment">// token 过期: 清除数据库token</span><br>      <span class="hljs-keyword">const</span> [user] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.app.mysql.select(<span class="hljs-string">&#x27;login&#x27;</span>, &#123;<br>        where: &#123; account &#125;<br>      &#125;)<br>      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.app.mysql.update(<span class="hljs-string">&#x27;login&#x27;</span>, &#123;<br>        id: user.id,<br>        token: <span class="hljs-literal">null</span>,<br>      &#125;)<br>      <span class="hljs-keyword">return</span> &#123;<br>        state: <span class="hljs-number">402</span>,<br>        message: <span class="hljs-string">&#x27;TOKEN EXPIRED&#x27;</span>,<br>        err,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = LoginService;<br></code></pre></div></td></tr></table></figure><p><strong>重点：</strong><br><code>jwt</code> 的使用：</p><ol><li>安装：<code>npm install --save jsonwebtoken</code></li><li>token 生成：<code>jwt.sign(payload,secret,options)</code></li><li>token 校验：<code>jwt.verify(token, secret, [(err,decoded)=&gt;&#123;...&#125;])</code></li></ol><p><code>jwt.sign()</code>参数解析：</p><ol><li>payload：负载。(Object) ，由用户自定义。作用：校验成功时所传递的参数</li><li>secret: 密钥。(String)，由用户自定义。作用：生成 token 的一个环节</li><li>options: 配置。(Object)，jwt 提供。作用：token 配置项、</li><li>返回值：token: String</li></ol><p><code>jwt.verify()</code>参数解析：</p><ol><li>token：token 值。(String) ，jwt 生成的 token。</li><li>secret: 密钥。(String)，该 token 所对应的密钥。</li><li>function(err,decoded) {…}：回调函数，可对结果做进一步处理，若返回err，则…；若返回decoded，则…；可选参数，若不指定，则校验成功返回 decoded，失败返回 err，可由 try … catch … 捕获。</li><li>返回值 decoded: Object  ||  err: Object</li></ol><h2 id="前端逻辑"><a href="#前端逻辑" class="headerlink" title="前端逻辑"></a>前端逻辑</h2><figure class="highlight pf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pf"><span class="hljs-variable">&lt;template&gt;</span><br>  <span class="hljs-variable">&lt;div class=&quot;circle&quot; @click=&quot;sign&quot;&gt;</span><br>    <span class="hljs-variable">&lt;!-- .stop 修饰符阻止事件冒泡 --&gt;</span><br>    <span class="hljs-variable">&lt;a class=&quot;log-in&quot; @click.stop=&quot;sign&quot;&gt;</span>登录&lt;/a&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br><span class="hljs-variable">&lt;script&gt;</span><br>import &#123; loginPost &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/network/index&quot;</span>;<br><br>export <span class="hljs-keyword">default</span> &#123;<br>  name: <span class="hljs-string">&quot;LoginBtn&quot;</span>,<br>  methods: &#123;<br>    async sign() &#123;<br>      // store 内获取账户和密码<br>      <span class="hljs-keyword">const</span> &#123;account, password&#125; = this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.<span class="hljs-keyword">user</span>;<br><br>      // 校验是否输入<br>      if (account === <span class="hljs-string">&quot;&quot;</span> || password === <span class="hljs-string">&quot;&quot;</span>) &#123;<br>        this.<span class="hljs-variable">$Message</span>.info(<span class="hljs-string">&quot;请输入账户或密码 ...&quot;</span>);<br>      &#125; else &#123;<br>        // 发起请求<br>        <span class="hljs-keyword">const</span> res = await loginPost(this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.<span class="hljs-keyword">user</span>);<br><br>        if (res.<span class="hljs-keyword">state</span> === <span class="hljs-number">201</span>) &#123;<br>          // <span class="hljs-number">201</span>状态码：localStorage没有token且登陆成功，token录入缓存<br>          this.<span class="hljs-variable">$store</span>.commit(<span class="hljs-string">&quot;setToken&quot;</span>, res.token);<br>          localStorage.<span class="hljs-built_in">set</span>Item(account, res.token);<br>          this.<span class="hljs-variable">$router</span>.push(<span class="hljs-string">&quot;/main/home&quot;</span>);<br><br>        &#125; else if (res.<span class="hljs-keyword">state</span> === <span class="hljs-number">200</span>) &#123;<br>          // <span class="hljs-number">200</span>状态码：本地token与服务端校验成功<br>          this.<span class="hljs-variable">$router</span>.push(<span class="hljs-string">&quot;/main/home&quot;</span>);<br><br>        &#125; else if (res.<span class="hljs-keyword">state</span> === <span class="hljs-number">401</span>) &#123;<br>          // 错误，打印错误原因(用户名/密码错误)<br>          this.<span class="hljs-variable">$Message</span>.info(res.message);<br>          this.<span class="hljs-variable">$router</span>.push(<span class="hljs-string">&quot;/login&quot;</span>);<br><br>        &#125; else if (res.<span class="hljs-keyword">state</span> === <span class="hljs-number">402</span>) &#123;<br>          this.<span class="hljs-variable">$store</span>.commit(<span class="hljs-string">&quot;deleteToken&quot;</span>, res.<span class="hljs-keyword">state</span>);<br>        &#125;<br>      &#125;<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br><span class="hljs-variable">&lt;style scoped&gt;</span><br>...<br>&lt;/style&gt;<br></code></pre></div></td></tr></table></figure><p><strong>全局路由守卫</strong><br>每次跳转前都判断 token 是否有效。<br><strong>注意：</strong> 这里判断条件为 <code>!token &amp;&amp; to.name !== &#39;login&#39;</code> , 若只判断 token 是否存在，执行 <code>&#39;next(/login)</code> 强制跳转时，又会触发 <code>router.beforeEach</code> ，导致死循环</p><figure class="highlight pf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pf">// 链接跳转前，先校验token<br>router.beforeEach((<span class="hljs-keyword">to</span>, <span class="hljs-keyword">from</span>, next) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; account, token &#125; = store.<span class="hljs-keyword">state</span>.<span class="hljs-keyword">user</span>;<br>  // 若没有 token 且跳往的页面不是登陆页面，则中断当前导航并跳转到登陆页面<br>  if (!token &amp;&amp; <span class="hljs-keyword">to</span>.name !== &#x27;login&#x27;) &#123;<br>    alert(&#x27;token过期,请重新登录~&#x27;)<br>    next(&#x27;/login&#x27;)<br>  &#125; else &#123;<br>    // 若存在 token，则每次跳转都校验 token 是否仍然有效<br>    loginPost(&#123; account, token &#125;).then(res =&gt; &#123;<br>      console.<span class="hljs-keyword">log</span>(res);<br>      store.commit(&#x27;deleteToken&#x27;, res.<span class="hljs-keyword">state</span>);<br>    &#125;)<br>    next();<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Egg</tag>
      
      <tag>MySQL</tag>
      
      <tag>Vue</tag>
      
      <tag>axios</tag>
      
      <tag>前后端联调</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie,document.cookie</title>
    <link href="/2021/03/28/Cookie,document.cookie/"/>
    <url>/2021/03/28/Cookie,document.cookie/</url>
    
    <content type="html"><![CDATA[<h1 id="Cookie-document-cookie"><a href="#Cookie-document-cookie" class="headerlink" title="Cookie,document.cookie"></a>Cookie,document.cookie</h1><ol><li>Cookie : 直接<strong>存储在浏览器</strong>中的一小串数据。是 <strong>HTTP 协议的一部分</strong>，由 RFC 6265 规范定义。</li><li>Cookie 通常是<strong>由 Web 服务器使用响应 <code>Set-Cookie HTTP-header</code> 设置</strong>的。然后<strong>浏览器</strong>使用 <code>Cookie HTTP-header</code> 将它们自动添加到（几乎）每个对相同域的请求中。(服务器设置，并由浏览器添加至请求)</li></ol><h2 id="Cookie-作用：身份验证"><a href="#Cookie-作用：身份验证" class="headerlink" title="Cookie 作用：身份验证"></a>Cookie 作用：身份验证</h2><ol><li>用户登录后，服务器<strong>在响应中</strong>使用 Set-Cookie HTTP-header 来设置具有唯一“会话标识符（session identifier）”的 cookie。</li><li>下次如果请求是由<strong>相同域</strong>发起的，浏览器会使用 Cookie HTTP-header 通过网络发送 cookie。</li><li>服务器接收时识别cookie就知道是谁发起了请求。</li></ol><p><strong>就好比公司打卡，第一天上班HR根本不认识你，此时会给你发工作证来标明你唯一的身份，之后打卡，HR只要识别你工作证就能知道是你打卡而不是别人打卡。</strong></p><h2 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h2><p>cookie 是服务器在响应阶段设置的，在浏览器端可以通过 <code>document.cookie</code> 访问</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>document.cookie</code> 不是对象属性，而是一个访问器(getter/setter)，因此可以读取和写入。</p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p><code>console.log(document.cookie)</code> 隐式调用了 get 方法，并返回所有的cookie。<br><code>document.cookie</code> 的值由 <code>name=value</code> 对组成，以<code>;</code>分隔。每个都是独立的 cookie。**key 和 value 都不需要 ‘’ **</p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p><code>document.cookie = &#39;user=John&#39;</code> 调用 set 方法写入一个cookie<br>此处只是插入了一个cookie，而不是覆盖了所有cookie，这就证明了document.cookie是访问器而不是对象属性。<br>cookie 的 name 和 value 可以是任何字符，为了保证格式有效，通常需要用内建的函数(<strong><code>encodeURIComponent</code></strong>)进行转义。</p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery">// 特殊字符（空格），需要编码<br><span class="hljs-keyword">let</span><span class="hljs-built_in"> name</span> = <span class="hljs-string">&quot;my name&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">value</span> = <span class="hljs-string">&quot;John Smith&quot;</span><br><br>// 将 cookie 编码为 my<span class="hljs-meta">%20name</span>=John<span class="hljs-meta">%20Smith</span><br><span class="hljs-type">document</span>.cookie = encodeURIComponent<span class="hljs-built_in">(name</span>) + <span class="hljs-string">&#x27;=&#x27;</span> + encodeURIComponent(<span class="hljs-keyword">value</span>);<br><br>alert<span class="hljs-built_in">(document</span>.cookie); // ...; my<span class="hljs-meta">%20name</span>=John<span class="hljs-meta">%20Smith</span><br></code></pre></div></td></tr></table></figure><h2 id="Cookie-的设置选项"><a href="#Cookie-的设置选项" class="headerlink" title="Cookie 的设置选项"></a>Cookie 的设置选项</h2><p>在写入 Cookie 时，可以设置相应的选项：选项写在 key=value 之后，并以 <code>;</code> 分隔。<br><code>document.cookie = &quot;user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT&quot;</code></p><ol><li><code>path=/mypath</code>：url 路径前缀，该路径下的页面可以访问该 cookie。必须是绝对路径。默认为当前路径。<br>如果一个 cookie 带有 <code>path=/admin</code> 设置，那么该 cookie 在 <code>/admin</code> 和 <code>/admin/something</code> 下都是可见的，但是在 <code>/home</code> 或 <code>/adminpage</code> 下不可见。<strong>即设置路径及其子路径可访问cookie</strong><br>通常，我们应该将 path 设置为根目录：path=/，以使 cookie 对此网站的所有页面可见。</li><li><code>domain=site.com</code>：设置可访问 cookie 的根域，其使得该域下所有子域均可访问 cookie。<br>默认情况下，cookie 只有在当前域下才能被访问到。如果 cookie 设置在 site.com 下，我们在 other.com 下就无法获取它，甚至在 site.com 子域下也无法访问。显示的 domain 设置可以解决上述问题。</li><li><code>expires=Tue, 19 Jan 2038 03:14:07 GMT</code>：cookie 的到期日期，那时浏览器会自动删除它。<br>日期必须完全采用 GMT 时区的这种格式。可以使用 <code>date.toUTCString</code> 来获取它。</li><li><code>max-age=3600</code>：expires 的替代选项，具指明 cookie 的过期时间距离当前时间的秒数。</li><li><code>secure</code>：设置 Cookie 只能通过 HTTPS 传输<br>cookie 是基于域的，它们不区分协议。默认情况下，如果我们在 <a href="http://site.com/">http://site.com</a> 上设置了 cookie，那么该 cookie 也会出现在 <a href="https://site.com/">https://site.com</a> 上，反之亦然。使用此选项，如果一个 cookie 是通过 <a href="https://site.com/">https://site.com</a> 设置的，那么它不会在相同域的 HTTP 环境下出现</li><li><code>samesite</code>：防止 XSRF（跨网站请求伪造）攻击。<br>XSRF? 用户在某页面登陆时，会向该页面发送cookie，页面核实cookie后允许用户进行后续操作。通常发送cookie请求是用户登录时执行的，但是cookie请求可以通过脚本执行！即黑客在其他网站可以用脚本模拟用户登录，从而欺骗页面。<br><code>samesite=strict</code> 保证如果用户来自同一网站之外，那么设置了 samesite=strict 的 cookie 永远不会被发送。只有在该网站下的操作才会发送 cookie。但是这样同样会屏蔽一些用户默许的合法链接，比如通过用户自己的笔记或收藏夹访问等。<strong>解决办法：</strong>通过使用两个 cookie 来解决这个问题：一个 cookie 用于“一般识别”，另一个带有 samesite=strict 的 cookie 用于进行数据更改的操作。这样，从网站外部来的用户可以访问网站，但是支付操作等必须是从银行网站启动的，这样第二个 cookie 才能被发送。<br><code>samesite=lax</code> 宽松模式，当从外部来到网站，则禁止浏览器发送 cookie，但是增加了一个例外。如果以下两个条件均成立，则会发送 samesite=lax cookie：a. HTTP 方法是“安全的”（例如 GET 方法，而不是 POST）b. 执行顶级导航（更改浏览器地址栏中的 URL）</li><li>httpOnly：禁止任何 JavaScript 访问 cookie。我们使用 document.cookie 看不到此类 cookie，也无法对此类 cookie 进行操作。即 Cookie 操作只能在服务端进行。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LocalStorage,sessionStorage</title>
    <link href="/2021/03/28/LocalStorage,sessionStorage/"/>
    <url>/2021/03/28/LocalStorage,sessionStorage/</url>
    
    <content type="html"><![CDATA[<h1 id="LocalStorage-sessionStorage"><a href="#LocalStorage-sessionStorage" class="headerlink" title="LocalStorage,sessionStorage"></a>LocalStorage,sessionStorage</h1><h2 id="LocalStorage-sessionStorage-与-Cookie-的区别"><a href="#LocalStorage-sessionStorage-与-Cookie-的区别" class="headerlink" title="LocalStorage,sessionStorage 与 Cookie 的区别"></a>LocalStorage,sessionStorage 与 Cookie 的区别</h2><ol><li><strong>Web存储对象(LocalStorage,sessionStorage)不会随每个请求被发送到服务器。可以保存更多数据</strong>。大多数浏览器都允许保存至少 2MB 的数据（或更多），并且具有用于配置数据的设置。</li><li><strong>服务器无法通过 HTTP header 操纵存储对象</strong>。对于Web存储对象的操作一切都是在 JavaScript 中完成的。</li><li>存储对象绑定到源（域/协议/端口三者）。不同协议或子域 对应 不同的存储对象，它们之间无法访问彼此数据。</li></ol><h2 id="LocalStorage-sessionStorage-存储对象的方法和属性"><a href="#LocalStorage-sessionStorage-存储对象的方法和属性" class="headerlink" title="LocalStorage,sessionStorage 存储对象的方法和属性"></a>LocalStorage,sessionStorage 存储对象的方法和属性</h2><ol><li>setItem(key, value) —— 存储键/值对。</li><li>getItem(key) —— 按照键获取值。</li><li>removeItem(key) —— 删除键及其对应的值。</li><li>clear() —— 删除所有数据。</li><li>key(index) —— 获取该索引下的键名。</li><li>length —— 存储的内容的长度。</li></ol><h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li>在<strong>同源(协议/域/端口均相同)**的所有标签页和窗口之间</strong>共享数据**。(url路径可以不同，即源下路径不同，也可以获取数据)</li><li><strong>数据不会过期</strong>。它在浏览器重启甚至系统重启后仍然存在。</li></ol><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ol><li>sessionStorage 的数据<strong>只存在于当前浏览器标签页</strong>。不同标签页存储数据不同。</li><li>数据在页面刷新后仍然保留，但在关闭/重新打开浏览器标签页后不会被保留。</li></ol><h2 id="存储对象遍历"><a href="#存储对象遍历" class="headerlink" title="存储对象遍历"></a>存储对象遍历</h2><p>存储对象不可迭代(<code>for..of..</code>不适用)</p><h3 id="for-let-i-0-i-lt-localStorage-length-i"><a href="#for-let-i-0-i-lt-localStorage-length-i" class="headerlink" title="for(let i=0; i&lt;localStorage.length; i++)"></a>for(let i=0; i&lt;localStorage.length; i++)</h3><p>用最普通的for循环遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">localStorage</span>.length; i++</span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> key = <span class="hljs-built_in">localStorage</span>.key(i);<br>  alert(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;<span class="hljs-built_in">localStorage</span>.getItem(key)&#125;</span>`</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="for-let-key-in-localStorage"><a href="#for-let-key-in-localStorage" class="headerlink" title="for(let key in localStorage)"></a>for(let key in localStorage)</h3><p>用遍历对象键的方式：<br>缺点：遍历所有键，会输出 localStorage 或 sessionStorage 的内建字段</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">localStorage</span></span>)</span> &#123;<br>  alert(key); <span class="hljs-comment">// 显示 getItem，setItem 和其他内建的东西</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="通过-hasOwnProperty-或使用-Object-keys-过滤原型内建字段"><a href="#通过-hasOwnProperty-或使用-Object-keys-过滤原型内建字段" class="headerlink" title="通过 hasOwnProperty 或使用 Object.keys 过滤原型内建字段"></a>通过 hasOwnProperty 或使用 Object.keys 过滤原型内建字段</h4><p><strong><code>.hasOwnProperty()</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">localStorage</span></span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">localStorage</span>.hasOwnProperty(key)) &#123;<br>    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过像 &quot;setItem&quot;，&quot;getItem&quot; 等这样的键</span><br>  &#125;<br>  alert(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;<span class="hljs-built_in">localStorage</span>.getItem(key)&#125;</span>`</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong><code>Object.keys()</code></strong><br>更佳的选择，不需要写额外判断条件，Object.keys()只返回属于对象的键，会忽略原型上的。</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">localStorage</span>);<br><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> keys</span>)</span> &#123;<br>  alert(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>: <span class="hljs-subst">$&#123;<span class="hljs-built_in">localStorage</span>.getItem(key)&#125;</span>`</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h2><p>Web存储对象(localStorage,sessionStorage)的键值对都必须是字符串，其内部会进行自动转化。<br>因此，对象类型的值存储要手动通过 <code>JSON.stringify()</code> 处理，以免出错。<br>或者可以对整个存储对象进行字符串化处理。</p><h2 id="Storage-事件"><a href="#Storage-事件" class="headerlink" title="Storage 事件"></a>Storage 事件</h2><h3 id="触发条件："><a href="#触发条件：" class="headerlink" title="触发条件："></a>触发条件：</h3><p>当 localStorage 或 sessionStorage 中的数据更新后，storage 事件就会触发。<br><strong>事件会在所有可访问到存储对象的 window 对象上触发，导致当前数据改变的 window 对象除外。</strong></p><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><p><strong>其允许同源的不同窗口交换消息</strong><br>常用于监听同源下不同窗口 LocalStorage 变化，当一个窗口数据更新时，另一个窗口及时进行反应。</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 等同于 <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;storage&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;)<br><span class="hljs-built_in">window</span>.onstorage = event =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (event.key != <span class="hljs-string">&#x27;now&#x27;</span>) <span class="hljs-keyword">return</span>;<br>  alert(event.key + <span class="hljs-string">&#x27;:&#x27;</span> + event.newValue + <span class="hljs-string">&quot; at &quot;</span> + event.url);<br>&#125;;<br><br><span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;now&#x27;</span>, <span class="hljs-built_in">Date</span>.now());<br></code></pre></div></td></tr></table></figure><h3 id="事件属性："><a href="#事件属性：" class="headerlink" title="事件属性："></a>事件属性：</h3><ol><li>key —— 发生更改的数据的 key（如果调用的是 .clear() 方法，则为 null）。</li><li>oldValue —— 旧值（如果是新增数据，则为 null）。</li><li>newValue —— 新值（如果是删除数据，则为 null）。</li><li>url —— 发生数据更新的文档的 url。</li><li>storageArea —— 发生数据更新的 localStorage 或 sessionStorage 对象。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件通信</title>
    <link href="/2021/03/28/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/03/28/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue组件通信"><a href="#Vue组件通信" class="headerlink" title="Vue组件通信"></a>Vue组件通信</h1><p>参考链接：<a href="https://segmentfault.com/a/1190000022700216">组件之间相互传值的方式</a></p><h2 id="父传子-props"><a href="#父传子-props" class="headerlink" title="父传子(props)"></a>父传子(props)</h2><p>一：在父组件的子组件标签中绑定自定义属性<br>二：子组件中使用props接收<br><strong>父组件</strong></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">&lt;user-detail :<span class="hljs-attribute">myName</span>=<span class="hljs-string">&quot;name&quot;</span> :<span class="hljs-attribute">myObject</span>=<span class="hljs-string">&quot;object&quot;</span> /&gt;<br>    <br><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>&#123;<br>    components: &#123;<br>        UserDetail<br>    &#125;<br>    <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    props: &#123;<br>      myName: &#123;<br>        type: <span class="hljs-built_in">String</span>,  <span class="hljs-comment">// 变量类型</span><br>        <span class="hljs-keyword">default</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 默认值</span><br>        requires: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 表示必填选项</span><br>      &#125;,<br>      myObject: &#123;<br>        type: <span class="hljs-built_in">Object</span>,<br>        <span class="hljs-keyword">default</span>() &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;, <span class="hljs-comment">// 对象或数组默认值需要用函数返回</span><br>      &#125;,<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>子组件接受的父组件的值分为<strong>引用类型</strong>和<strong>普通类型</strong>：<br><strong>普通类型：</strong>字符串（String）、数字（Number）、布尔值（Boolean）、空（Null）<br><strong>引用类型：</strong>数组（Array）、对象（Object）<br>vue 单向数据流，规定了组件之间的数据是单向流通的，子组件是不允许直接对父组件传来的值进行修改的。我们需要先把传过来的值重新赋值给data中的一个变量，然后再更改那个变量。<br>当子组件接收的是普通类型数据时，修改该存储变量不会更改父组件相应的值；当子组件接收的是引用类型时，在子组件中修改存储的变量后，父组件的也会修改。这是因为引用类型变量保存的是对象的地址，父组件的变量，子组件接受的变量以及子组件另存为的变量都指向同一对象地址，因此会共享数据。除非有特殊需要，否则不要轻易修改传递的对象值。</p><h2 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h2><h3 id="emit"><a href="#emit" class="headerlink" title="($emit)"></a>($emit)</h3><p>一：子组件绑定一个事件，当事件触发时，通过<code>$emit</code>向父组件发送一个事件(可携带参数传递，多个参数用对象包裹)<br>二：在父组件对应子组件上定义并绑定对应于<code>$emit</code>发送的事件(可接受携带的参数)<br><strong>子组件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;button @click=<span class="hljs-string">&quot;changeParentName&quot;</span>&gt;改变父组件的name&lt;/button&gt;<br>​<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    methods: &#123;<br>        <span class="hljs-comment">//子组件的事件</span><br>        changeParentName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;handleChange&#x27;</span>, <span class="hljs-string">&#x27;Jack&#x27;</span>) <span class="hljs-comment">// 向父组件发送handleChange事件并传参Jack</span><br>            <span class="hljs-comment">// 注：此处事件名称与父组件中绑定的事件名称要一致</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>父组件</strong></p><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> @<span class="hljs-attr">handleChange</span>=<span class="hljs-string">&quot;changeName&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br>​<br>methods: &#123;<br>    changeName<span class="hljs-built_in">(name</span>) &#123;  //<span class="hljs-built_in"> name</span>形参是子组件中传入的值Jack<br>        this<span class="hljs-built_in">.name</span> =<span class="hljs-built_in"> name</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>父组件用<code>@</code>接收子组件发送的事件。父组件需要定义一个函数来接受子组件发送的事件。子组件向父组件发送事件，需要特定的条件触发(若要实现子组件变量修改后，立刻改变父组件变量，可以用watch监听子组件变量，并在watch内定义函数发送自定义事件)。</p><h3 id="callback"><a href="#callback" class="headerlink" title="(callback)"></a>(callback)</h3><p>通过“父传子”回调函数实现“子传父”的功能<br>一：在父组件中定义一个callback函数，并把 callback 函数传过去<br>二：在子组件中接收，并执行 callback 函数<br><strong>父组件</strong></p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir">&lt;child <span class="hljs-symbol">:callback=<span class="hljs-string">&quot;callback&quot;</span>&gt;&lt;/child&gt;</span><br>​<br><span class="hljs-symbol">methods:</span> &#123;<br>    <span class="hljs-symbol">callback:</span> function(name) &#123;<br>        this.name = name<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-params">&lt;button @click=&quot;callback(&#x27;Jack&#x27;)&quot;&gt;</span>改变父组件的name<span class="hljs-params">&lt;/button&gt;</span><br>​<br><span class="hljs-symbol">props:</span> &#123;<br><span class="hljs-symbol">    callback:</span> Function,<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="refs"><a href="#refs" class="headerlink" title="$refs"></a>$refs</h2><p>父组件可以通过<code>$refs</code>访问指定的子组件实例，从而调用组件的方法或访问数据。<br><strong>这种方式的组件通信不能跨级</strong><br><strong>使用<code>$refs</code>时要注意，此时子组件可能未完全挂在完成；因此我们一般使用<code>$refs</code>调用子组件的data和methods(在子组件created阶段就完成了)</strong><br>此外还有<code>$parent</code>,<code>$children</code>，但不建议使用。<br><strong>子组件</strong></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>&#123;<br>    data () &#123;<br>        return &#123;<br>            title: <span class="hljs-string">&#x27;子组件&#x27;</span><br>        &#125;<br>    &#125;,<br>    methods: &#123;<br>        sayHello () &#123;<br>            console.log(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>父组件</strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;childRef&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>​<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    created () &#123;<br><span class="javascript">      <span class="hljs-comment">// 通过 $ref 来访问子组件</span></span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.$refs.childRef.title);  <span class="hljs-comment">// 子组件</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$refs.childRef.sayHello(); <span class="hljs-comment">// Hello</span></span><br><br><span class="javascript">      <span class="hljs-comment">// 通过 $children 来调用子组件的方法</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$children.sayHello(); <span class="hljs-comment">// Hello</span></span><br>    &#125;<br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="兄弟通信"><a href="#兄弟通信" class="headerlink" title="兄弟通信"></a>兄弟通信</h2><h3 id="props-和-emit-结合使用"><a href="#props-和-emit-结合使用" class="headerlink" title="props 和 $emit 结合使用"></a>props 和 $emit 结合使用</h3><p>同级子组件通过父组件作为中转站传值。一个子组件通过 <code>$emit</code> 传递参数到父组件，父组件接收传递的值，并通过 props 传递给另一个子组件。<br><strong>该方法跨级传递时过于繁琐，需要从底层一步步向上传递，到根组件后再一步步向下传递。后续介绍的空实例中转可以解决该问题</strong><br><strong>父组件</strong></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">&lt;child-a :<span class="hljs-attribute">myName</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;<br>&lt;child-b :<span class="hljs-attribute">myName</span>=<span class="hljs-string">&quot;name&quot;</span> @<span class="hljs-attribute">changeName</span>=<span class="hljs-string">&quot;editName&quot;</span> /&gt;  <br>    <br><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>&#123;<br>    data() &#123;<br>        return &#123;<br>            name: <span class="hljs-string">&#x27;John&#x27;</span><br>        &#125;<br>    &#125;,<br>    components: &#123;<br>        <span class="hljs-string">&#x27;child-a&#x27;</span>: ChildA,<br>        <span class="hljs-string">&#x27;child-b&#x27;</span>: ChildB,<br>    &#125;,<br>    methods: &#123;<br>        editName(name) &#123;<br>            this.name = name<br>        &#125;,<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>子组件</strong></p><figure class="highlight handlebars"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs handlebars"><span class="xml">// child-a 组件</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">newName</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">    props: [&quot;myName&quot;],</span><br><span class="xml">    computed: &#123;</span><br><span class="xml">        newName() &#123;</span><br><span class="xml">            if(this.myName) &#123; // 判断是否有值传过来</span><br><span class="xml">                return this.myName</span><br><span class="xml">            &#125;</span><br><span class="xml">            return &#x27;John&#x27; //没有传值的默认值</span><br><span class="xml">        &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml">// child-b 组件</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">myName</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeName&quot;</span>&gt;</span>修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">    props: [&quot;myName&quot;],</span><br><span class="xml">    methods: &#123;</span><br><span class="xml">        changeName() &#123;</span><br><span class="xml">            this.$emit(&#x27;changeName&#x27;, &#x27;Lily&#x27;)   // 触发事件并传值</span><br><span class="xml">        &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><h3 id="空Vue实例中转-适用于任何场景"><a href="#空Vue实例中转-适用于任何场景" class="headerlink" title="空Vue实例中转(适用于任何场景)"></a>空Vue实例中转(适用于任何场景)</h3><p>一：创建一个 EventBus.js 文件，暴露一个 vue 实例</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">import Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;Vue&#x27;</span>  <br><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>new Vue()<br></code></pre></div></td></tr></table></figure><p>二：在要传值的文件里导入这个空 vue 实例，定义方法并通过 <code>$emit</code> 发送事件函数（也可以在 main.js 中全局引入该 js 文件）<br>三：在接收传值的组件中也导入 vue 实例，通过 <code>$on</code> 监听回调，回调函数接收所有触发事件时传入的参数<br><strong>注意：空Vue实例的this指向当前父级块作用域，一般为组件实例</strong></p><figure class="highlight handlebars"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs handlebars"><span class="xml">// 发送事件</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">name</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeName&quot;</span>&gt;</span>修改姓名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">​</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import &#123; EventBus &#125; from &quot;../EventBus.js&quot;</span><br><span class="xml">​</span><br><span class="xml">export default &#123;</span><br><span class="xml"> data() &#123;</span><br><span class="xml">     return &#123;</span><br><span class="xml">         name: &#x27;John&#x27;,</span><br><span class="xml">     &#125;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  methods: &#123;</span><br><span class="xml">      changeName() &#123;</span><br><span class="xml">          this.name = &#x27;Lily&#x27;</span><br><span class="xml">          EventBus.$emit(&quot;editName&quot;, this.name) // 触发全局事件,并且把改变后的值传入事件函数</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听事件并触发回调</span><br><span class="hljs-keyword">import</span> &#123; EventBus &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../EventBus.js&quot;</span><br>​<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            name: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>         EventBus.$on(<span class="hljs-string">&#x27;editName&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;<br>             <span class="hljs-built_in">this</span>.name = name<br>         &#125;)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="provide-amp-inject-跨级通信"><a href="#provide-amp-inject-跨级通信" class="headerlink" title="provide &amp; inject 跨级通信"></a>provide &amp; inject 跨级通信</h2><p><a href="https://v3.cn.vuejs.org/guide/component-provide-inject.html">provide/inject – Vue3官方文档</a><br>Vue 高阶的方法：(provied &amp; inject) 选项需要一起使用：允许一个祖先组件通过<code>provide</code>向其所有子孙后代注入一个依赖，不论组件层次有多深，子组件都能通过<code>inject</code>接收，该关系在起上下游关系成立的时间里始终生效<br><strong>祖先组件</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">export</span> <span class="hljs-selector-tag">default</span> &#123;<br>  <span class="hljs-attribute">provide</span>: &#123; // 作用：将注入的变量提供给它的所有子组件。<br>    name: <span class="hljs-string">&#x27;Jack&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>子孙组件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  inject: [<span class="hljs-string">&#x27;name&#x27;</span>], <span class="hljs-comment">// 获取 provide 注入的变量</span><br>  mounted () &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);  <span class="hljs-comment">// Jack</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>provide 和 inject 绑定并不是可响应的。即父组件的name变化后，子组件不会跟着变，然而，如果你传入了一个响应式的对象，那么其对象的 property 仍是响应式的</strong><br>在使用 provide / inject 时通常要处理响应问题：<br>在 Vue2 中：</p><ol><li>直接provide祖先实例(this)，然后在子孙组件中注入依赖，这样就可以在后代组件中直接修改祖先组件的实例的属性。缺点是挂载的无效东西太多</li><li>使用 <a href="https://cn.vuejs.org/v2/api/#Vue-observable">Vue.observable – Vue2</a> 优化响应式 provide. (即用Vue.observable()作用到对象，将其注册为响应式)</li></ol><p>在 Vue3 中：provide 需要传递组件实例data的property时，需要将provide变为返回对象的函数。<br>Vue3 对于 provide 响应式的处理，主要通过传递一个 ref property 或 reactive 对象给 provide 来改变这种行为。而 ref 对象通过 <code>Vue.computed()</code> 创建（它接受 getter 函数并为 getter 返回的值返回一个不可变的响应式 ref 对象，或者，它可以使用一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。）。<br><a href="https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#%E8%AE%A1%E7%AE%97%E5%80%BC">Vue3文档–响应式计算和侦听</a><br><a href="https://v3.cn.vuejs.org/guide/component-provide-inject.html#%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94%E6%80%A7">Vue3文档–provide/inject</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>评论功能实现</title>
    <link href="/2021/03/28/%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/03/28/%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="评论功能实现"><a href="#评论功能实现" class="headerlink" title="评论功能实现"></a>评论功能实现</h1><h2 id="效果图展示"><a href="#效果图展示" class="headerlink" title="效果图展示"></a>效果图展示</h2><p><img src="/img/posts_img/20210328093332361_29308.png"></p><h2 id="组件结构"><a href="#组件结构" class="headerlink" title="组件结构"></a>组件结构</h2><p><strong><code>vue</code></strong></p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">├─ src<br>│  ├─ components<br>│  │  ├─ common<br>│  │  │  ├─ comment  <span class="hljs-comment">// 通用comment组件</span><br>│  │  │  │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CommentArea</span>.</span></span>vue<br>│  │  │  │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CommentBtn</span>.</span></span>vue<br>│  │  │  │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CommentCtn</span>.</span></span>vue<br>│  │  │  │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CommentItem</span>.</span></span>vue<br>│  │  │  │  └─ middle.js  <span class="hljs-comment">// 空Vue实例，作为通信中转</span><br>│  │  └─ content<br>│  │     ├─ comment<br>│  │        └─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Comment</span>.</span></span>vue  <span class="hljs-comment">// 项目comment组件</span><br>│  ├─ main.js<br>│  ├─ network  <span class="hljs-comment">// Post请求</span><br>│  │  ├─ index.js<br>│  │  └─ request.js<br>│  └─ views<br>│     ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Main</span>.</span></span>vue  <span class="hljs-comment">// 项目入口</span><br>│     └─ user<br>│        └─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserPage</span>.</span></span>vue  <span class="hljs-comment">// 组件展示页面</span><br>└─ vue.config.js<br></code></pre></div></td></tr></table></figure><p><strong><code>egg</code></strong></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">├─ app<br>│  ├─ controller<br>│  │  └─ comment.js<br>│  ├─ router.js<br>│  └─ service<br>│     └─ comment.js<br>├─ config<br>   ├─ config.default.js<br>   └─ plugin.js<br></code></pre></div></td></tr></table></figure><h2 id="数据组织结构"><a href="#数据组织结构" class="headerlink" title="数据组织结构"></a>数据组织结构</h2><p><img src="/img/posts_img/20210328114000703_19213.png"><br><img src="/img/posts_img/20210328114301998_17880.png"></p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">Comment</span>: [<br>  &#123;<br>    //主评论者<br>    reviewer: <span class="hljs-keyword">String</span>,<br>    // 被回复者<br>    responder: <span class="hljs-keyword">String</span>,<br>    <span class="hljs-built_in">date</span>: <span class="hljs-keyword">String</span>,<br>    <span class="hljs-keyword">content</span>: <span class="hljs-keyword">String</span>,<br>    <span class="hljs-keyword">index</span>: <span class="hljs-built_in">Number</span>,<br>  &#125;,&#123;&#125;,...<br>]<br></code></pre></div></td></tr></table></figure><h2 id="总体设计思路"><a href="#总体设计思路" class="headerlink" title="总体设计思路"></a>总体设计思路</h2><ol><li><code>CommentArea.vue</code>: 未输入任何内容时，<code>&lt;textarea&gt;</code>显示默认提示文本信息，点击发布弹出全局对话框“发布内容不能为空！”。输入内容并点击发布，将信息展示到 <code>CommentItem.vue</code> 中，并写入数据库。写入成功则弹出全局对话框“评论发布成功,已同步到数据库~”，写入失败弹出全局对话框“数据库写入失败”。点击”发布”或“清空”按钮均会删除<code>&lt;textarea&gt;</code>中的文本信息，并重新聚焦。</li><li><code>CommentItem.vue</code>: 展示评论信息，目前仅支持二级评论。主评论无缩进，子评论缩进并更改为回复模式。更换至回复模式的方法：点击想要评论的发布者姓名，在发布评论功能栏中提示“正在回复xxx”字样后，输入评论并发布即可。评论展示区设置了滚动条，当评论数量超出区域展示范围时，显示滚动条，在设计过程中，本组件自动在发布评论后将滚动条聚焦到底部。</li><li><code>egg</code>: 前端发起get请求时，egg读取数据库所有评论并返回前端，在页面展示；前端发起post请求时，将评论信息通过data传输给后端，后端接收后写入数据库内。</li></ol><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p>此处只针对本人在组件开发时遇到的一些问题或个人认为重要的点进行讲解。不对代码做一一解读，最后会贴出本项目所有代码，以供参考。<br>代码解读顺序按照一次完整的评论流程进行：</p><h3 id="数据请求与传递"><a href="#数据请求与传递" class="headerlink" title="数据请求与传递"></a>数据请求与传递</h3><p><strong><code>Comment.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">CommentCtn</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:comment</span>=<span class="hljs-string">&quot;comment&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:curClient</span>=<span class="hljs-string">&quot;curClient&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:replyClient</span>=<span class="hljs-string">&quot;replyClient&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> CommentCtn <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/common/comment/CommentCtn&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; commentRequest &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/network&quot;</span>;</span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;Comment&quot;</span>,</span><br>  components: &#123;<br>    CommentCtn,<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      width: <span class="hljs-string">&quot;600px&quot;</span>,</span><br><span class="javascript">      height: <span class="hljs-string">&quot;700px&quot;</span>,</span><br><span class="javascript">      curClient: <span class="hljs-string">&quot;WangJT&quot;</span>,</span><br><span class="javascript">      replyClient: <span class="hljs-string">&quot;xxx&quot;</span>,</span><br>      comment: [],<br>    &#125;;<br>  &#125;,<br><span class="javascript">  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-comment">// (imp)基于响应式的数据请求:通过逐个添加入数组(arr.push),保证Vue对数据的响应</span></span><br><span class="javascript">    <span class="hljs-comment">// 不能用 comment = [xxx], 相当于修改了指向, 将Vue初始化时对数组添加的watcher覆盖了</span></span><br><span class="javascript">    <span class="hljs-comment">// 若没有响应式, 则需要在 &lt;CommentCtn&gt; 组件内添加 $watch 方法监听 comment (之前在用的方法,现在找到原因了)</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> comments = <span class="hljs-keyword">await</span> commentRequest();</span><br><span class="javascript">    comments.map(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.comment.push(obj);</span><br>    &#125;);<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>重点：</strong><br>在初始渲染时，我们需要get请求数据库内已存储的评论，并将它传递给组件进行渲染。但由于get请求是异步操作，还未传入数据，<code>&lt;Comment&gt;</code>组件就渲染完成了，不当的操作会导致评论渲染不成功。主要原因和解决关键在于Vue的<strong>响应机制</strong>。(可先看下面关于Vue响应式系统的讲解)<br>方案一：<br>言归正传，此处我们在初始化实例前声明了响应式propety – <code>comment:[]</code>，此时任何向 <code>comment</code> 添加数据的行为有可能触发响应，注意是有可能：<code>this.comment = [new array]</code>就不会触发。因此，我们要保证请求到数据(一个数组)后，通过遍历的方式通过<code>arr.push()</code>逐个添加到评论内，从而触发响应式，进行实时渲染。<br>方案二：<br>若我们执意用<code>this.comment = [new array]</code>来替换已被添加至响应式系统里的数组时(替换了就相当于将数组从响应式系统中移除，又重新赋给了变量一个新的数组地址，不再具有响应式)，我们需要通过<code>this.$watch</code>手动监测<code>coment</code>数组的变化，并实时渲染。<br><strong>以下为Vue官方文档<a href="https://cn.vuejs.org/v2/guide/reactivity.html#ad">深入响应式原理</a>的原话：</strong><br>当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。也就是说如果你添加一个新的 property，并对其后续做改动将不会触发任何视图的更新。 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值。<br><strong>更深层次理解：</strong><br> 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <strong><code>data</code></strong> 选项，Vue 将遍历此对象所有的 property，并使用 <code>Object.defineProperty</code> 把这些 property 全部转为 <code>getter/setter</code>。这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。<br> <img src="/img/posts_img/20210328101142163_15568.png"><br><strong>Vue响应式系统的限制：</strong><br>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。<br>对于对象：<br>Vue 无法检测 property 的添加或移除(只能检测修改)。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。<br>解决方法：<br>(逐个添加属性)<br><code>Vue.set(object, propertyName, value)</code><br><code>vm.$set(object, propertyName, value)</code><br>(添加多条属性)<br><code>this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;)</code></p><p>对于数组：<br>Vue 不能检测以下数组的变动：</p><ol><li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><p>解决方法：<br><code>Vue.set(vm.items, indexOfItem, newValue)</code><br><code>arr.splice()</code><br><code>arr.push()</code><br>… 等数组原生内建方法</p><h3 id="初始渲染"><a href="#初始渲染" class="headerlink" title="初始渲染"></a>初始渲染</h3><p><strong><code>CommentCtn</code></strong></p><figure class="highlight handlebars"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;comment-container&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; width, height &#125;&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>评论<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 无评论时展示 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;emptyComment&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>暂无评论，请发表第一条评论吧<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span></span><br><span class="xml">      <span class="hljs-comment">&lt;!-- 评论展示区 --&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;comment-list&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- 遍历主评论,子评论在内部判断 --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, idx) in mainComments&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;idx&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">CommentItem</span></span></span><br><span class="xml">            :allComments=&quot;comment&quot;</span><br><span class="xml">            :comment=&quot;item&quot;</span><br><span class="xml">            :index=&quot;idx&quot;</span><br><span class="xml">            @replyComment=&quot;replyComment&quot;</span><br><span class="xml">          /&gt;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>发表评论<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 发表评论区 --&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 若回复评论，则显示 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;curSelect&quot;</span>&gt;</span>正在回复 </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">curSelect</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">CommentArea</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">CommentBtn</span> @<span class="hljs-attr">addComment</span>=<span class="hljs-string">&quot;addComment&quot;</span> /&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import CommentItem from &quot;@/components/common/comment/CommentItem&quot;;</span><br><span class="xml">import CommentArea from &quot;@/components/common/comment/CommentArea&quot;;</span><br><span class="xml">import CommentBtn from &quot;@/components/common/comment/CommentBtn&quot;;</span><br><span class="xml">import &#123; commentPost &#125; from &quot;@/network&quot;;</span><br><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;CommentCtn&quot;,</span><br><span class="xml">  components: &#123;</span><br><span class="xml">    CommentItem,</span><br><span class="xml">    CommentArea,</span><br><span class="xml">    CommentBtn,</span><br><span class="xml">  &#125;,</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      selectComment: -1,</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    /*</span><br><span class="xml">      &#123;</span><br><span class="xml">        reviewer:String,</span><br><span class="xml">        responder:String,</span><br><span class="xml">        date:String,</span><br><span class="xml">        content:String,</span><br><span class="xml">        index:Number</span><br><span class="xml">      &#125; []</span><br><span class="xml">    */</span><br><span class="xml">    //  评论列表</span><br><span class="xml">    comment: Array,</span><br><span class="xml">    curClient: String,</span><br><span class="xml">    replyClient: String,</span><br><span class="xml">    width: &#123;</span><br><span class="xml">      type: String,</span><br><span class="xml">      default: &quot;600px&quot;,</span><br><span class="xml">    &#125;,</span><br><span class="xml">    height: &#123;</span><br><span class="xml">      type: String,</span><br><span class="xml">      default: &quot;700px&quot;,</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;,</span><br><span class="xml">  computed: &#123;</span><br><span class="xml">    // 判断评论是否为空,为空则显示占位文本</span><br><span class="xml">    emptyComment() &#123;</span><br><span class="xml">      return !this.comment.length;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    // 通过选中项的idx与主评论的idx匹配,确定选择项的被回复者ID(目前只支持二级评论)</span><br><span class="xml">    curSelect() &#123;</span><br><span class="xml">      if (this.selectComment !== -1) &#123;</span><br><span class="xml">        // (imp)对象数组常用处理方法</span><br><span class="xml">        return this.mainComments.find((obj) =&gt; &#123;</span><br><span class="xml">          return obj.index === this.selectComment;</span><br><span class="xml">        &#125;).reviewer;</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    // 主评论</span><br><span class="xml">    mainComments() &#123;</span><br><span class="xml">      // (imp)对象数组常用处理方法</span><br><span class="xml">      return this.comment.filter((obj) =&gt; &#123;</span><br><span class="xml">        return obj.responder == &quot;undefined&quot;;</span><br><span class="xml">      &#125;);</span><br><span class="xml">    &#125;,</span><br><span class="xml">    mainCommentsNum() &#123;</span><br><span class="xml">      return this.comment.filter((obj) =&gt; &#123;</span><br><span class="xml">        return obj.responder == &quot;undefined&quot;;</span><br><span class="xml">      &#125;).length;</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;,</span><br><span class="xml">  methods: &#123;</span><br><span class="xml">    // 日期转换(Date对象转字符串)</span><br><span class="xml">    dateTransform(date) &#123;</span><br><span class="xml">      let y = date.getFullYear();</span><br><span class="xml">      let m = date.getMonth() + 1;</span><br><span class="xml">      m = m <span class="hljs-tag">&lt; <span class="hljs-attr">10</span> ? &quot;<span class="hljs-attr">0</span>&quot; + <span class="hljs-attr">m</span> <span class="hljs-attr">:</span> <span class="hljs-attr">m</span>;</span></span><br><span class="xml">      let d = date.getDate();</span><br><span class="xml">      d = d <span class="hljs-tag">&lt; <span class="hljs-attr">10</span> ? &quot;<span class="hljs-attr">0</span>&quot; + <span class="hljs-attr">d</span> <span class="hljs-attr">:</span> <span class="hljs-attr">d</span>;</span></span><br><span class="xml">      let h = date.getHours();</span><br><span class="xml">      let minute = date.getMinutes();</span><br><span class="xml">      minute = minute <span class="hljs-tag">&lt; <span class="hljs-attr">10</span> ? &quot;<span class="hljs-attr">0</span>&quot; + <span class="hljs-attr">minute</span> <span class="hljs-attr">:</span> <span class="hljs-attr">minute</span>;</span></span><br><span class="xml">      let second = date.getSeconds();</span><br><span class="xml">      second = minute <span class="hljs-tag">&lt; <span class="hljs-attr">10</span> ? &quot;<span class="hljs-attr">0</span>&quot; + <span class="hljs-attr">second</span> <span class="hljs-attr">:</span> <span class="hljs-attr">second</span>;</span></span><br><span class="xml">      return y + &quot;-&quot; + m + &quot;-&quot; + d + &quot; &quot; + h + &quot;:&quot; + minute + &quot;:&quot; + second;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    addComment(content) &#123;</span><br><span class="xml">      if (this.selectComment === -1) &#123;</span><br><span class="xml">        // 添加主评论</span><br><span class="xml">        const mainComment = &#123;</span><br><span class="xml">          reviewer: this.curClient,</span><br><span class="xml">          responder: &quot;undefined&quot;,</span><br><span class="xml">          date: this.dateTransform(new Date()),</span><br><span class="xml">          content,</span><br><span class="xml">          index: this.mainCommentsNum,</span><br><span class="xml">        &#125;;</span><br><span class="xml">        // (imp)通过arr.push()更新comment列表,Vue会响应式更新</span><br><span class="xml">        this.comment.push(mainComment);</span><br><span class="xml">        commentPost(mainComment).then((res) =&gt; &#123;</span><br><span class="xml">          if (res) &#123;</span><br><span class="xml">            this.$Message.info(&quot;评论发布成功,已同步到数据库~&quot;);</span><br><span class="xml">          &#125; else &#123;</span><br><span class="xml">            this.$Message.info(&quot;数据库写入失败&quot;);</span><br><span class="xml">          &#125;</span><br><span class="xml">        &#125;);</span><br><span class="xml">      &#125; else &#123;</span><br><span class="xml">        // 添加子评论</span><br><span class="xml">        const subComment = &#123;</span><br><span class="xml">          reviewer: this.replyClient,</span><br><span class="xml">          responder: this.comment.find(</span><br><span class="xml">            (obj) =&gt; obj.index === this.selectComment</span><br><span class="xml">          ).reviewer,</span><br><span class="xml">          date: this.dateTransform(new Date()),</span><br><span class="xml">          content,</span><br><span class="xml">          index: this.selectComment,</span><br><span class="xml">        &#125;;</span><br><span class="xml">        this.comment.push(subComment);</span><br><span class="xml">        this.selectComment = -1;</span><br><span class="xml">        // 提交到数据库</span><br><span class="xml">        commentPost(subComment).then((res) =&gt; &#123;</span><br><span class="xml">          if (res) &#123;</span><br><span class="xml">            this.$Message.info(&quot;评论发布成功,已同步到数据库~&quot;);</span><br><span class="xml">          &#125; else &#123;</span><br><span class="xml">            this.$Message.info(&quot;数据库写入失败&quot;);</span><br><span class="xml">          &#125;</span><br><span class="xml">        &#125;);</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    // (imp)自动聚焦评论区底部</span><br><span class="xml">    setScrollBottom() &#123;</span><br><span class="xml">      let event = document.getElementById(&quot;comment-list&quot;);</span><br><span class="xml">      event.scrollTop = event.scrollHeight;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    replyComment(selectIdx) &#123;</span><br><span class="xml">      this.selectComment = selectIdx;</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;,</span><br><span class="xml">  // (imp)组件内watch侦听模式</span><br><span class="xml">  watch: &#123;</span><br><span class="xml">    // 监听评论，评论发生变化，拉动滚动条到最底端</span><br><span class="xml">    comment: &#123;</span><br><span class="xml">      // (imp)this指向问题:</span><br><span class="xml">      // function() &#123;&#125; 内 this 取决于上下文调用环境；</span><br><span class="xml">      // 箭头函数没有 this，取最近上层块级作用域；点符号调用中，取点符号前对象</span><br><span class="xml">      handler: function () &#123;</span><br><span class="xml">        // 此处要用零延时setTimeout将滚动条重置滞后，确保响应系统更新后，再计算滚动条高度</span><br><span class="xml">        // 若不用，滚动条停留在最新一条评论的前一条上方</span><br><span class="xml">        setTimeout(() =&gt; &#123;</span><br><span class="xml">          this.setScrollBottom();</span><br><span class="xml">        &#125;, 0);</span><br><span class="xml">      &#125;,</span><br><span class="xml">      // 监听深层嵌套</span><br><span class="xml">      deep: true,</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;,</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">...</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><p><strong>重点：</strong><br>一：处理对象数组的常用方法(map,filter,find,findIdx)<br>遍历所有元素并对各元素执行回调，所有回调结果返回组成新数组<br><code>map&lt;U&gt;(callbackfn: (value: T, index: number, array: T[]) =&gt; U, thisArg?: any): U[];</code><br>遍历所有元素并对各元素执行回调，回调返回boolean值，若为true，则将该参与遍历的元素添加至新数组<br><code>filter(predicate: (value: T, index: number, array: T[]) =&gt; unknown, thisArg?: any): T[];</code><br>遍历所有元素并对各元素执行回调，回调返回boolean值，若为true，则返回该元素并停止遍历<br><code>arr.find(callback[, thisArg])</code><br>遍历所有元素并对各元素执行回调，回调返回boolean值，若为true，则返回该元素索引并停止遍历<br><code>arr.findIdx(callback[, thisArg])</code></p><p>二：Vue 的 watch 侦听模式<br>官方文档：<br><a href="https://cn.vuejs.org/v2/api/#watch">组件内watch侦听</a><br><a href="https://cn.vuejs.org/v2/api/#vm-watch">全局$watch侦听</a><br>组件内写法(本质上是调用了全局$watch)：<br>watch是一个对象类型，接收 String 类型作为 key，其可以是需要观察的字符串或者表达式，值是对应回调函数 | 方法名 | 包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个 property。<br><strong>值得注意的是，watch内回调函数不要用箭头函数，因为箭头函数this绑定了父级块作用域上下文，而不是明确指向vue实例。此处用普通函数，普通函数this绑定调用上下文，watch内函数被vue实例调用，因此this始终指向vue实例</strong></p><figure class="highlight qml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs qml"><span class="hljs-attribute">watch</span>: &#123;<br>  [<span class="hljs-attribute">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">Function</span> | <span class="hljs-built_in">Object</span> | <span class="hljs-built_in">Array</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>实例：</p><figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">watch: &#123;<br>  // <span class="hljs-number">1</span>.若key为正常字符串，可省略引号；回调函数默认接收且仅接收两个参数(侦听目标新值，侦听目标原值)<br>  abc: function(newValue,oldValue) <span class="hljs-meta">&#123;...&#125;</span>,<br>  // <span class="hljs-number">2</span>.可用<span class="hljs-type">ES6</span>语法改写为：<br>  abc(newValue,oldValue) <span class="hljs-meta">&#123;...&#125;</span>,<br>  // <span class="hljs-number">3</span>.直接传入已定义方法的方法名<br>  b: &#x27;someMethod&#x27;,<br>  // <span class="hljs-number">4</span>.特殊字符串需要加上引号<br>  &#x27;$store.state.xxx&#x27;(newValue,oldValue)<span class="hljs-meta">&#123;...&#125;</span>,<br>  // <span class="hljs-number">5</span>.表达式(参照js计算属性使用)<br>  [&#x27;abc&#x27;+&#x27;edf&#x27;](newValue,oldValue)<span class="hljs-meta">&#123;...&#125;</span>,<br>  // <span class="hljs-number">6</span>.包含选项的对象&#123;handler: (newValue:<span class="hljs-built_in">any</span>, oldValue:<span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>, deep: boolean, immediate: boolean&#125;<br>  a:&#123;<br>    handler: function(newValue, oldValue) <span class="hljs-meta">&#123;...&#125;</span>,<br>    // 回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深<br>    deep: <span class="hljs-literal">true</span>,<br>    // 回调将会在侦听开始之后被立即调用<br>    immediate: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  // <span class="hljs-number">7</span>.若传入回调数组，它们会被逐一调用<br>  e: [<br>    &#x27;handle1&#x27;,<br>    function handle2 (val, oldVal) &#123; /* ... */ &#125;,<br>    &#123;<br>      handler: function handle3 (val, oldVal) &#123; /* ... */ &#125;,<br>      /* ... */<br>    &#125;<br>  ],<br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://cn.vuejs.org/v2/api/#vm-watch">全局$watch</a>：<br>参照官方文档，与组件内大致相同，<code>vm.$watch</code>分成三部分，其中侦听目标可以是<code>string | Function</code>，回调函数可以是<code>Function | Object</code>，配置参数传入<code>Object</code>，属性为<code>deep &amp; immediate</code>。此外 <code>vm.$watch</code> 还返回一个函数<code>unwatch: Function</code>，调用<code>unwatch</code>可以结束相应<code>vm.$watch</code>的侦听(类似于setTimeout &amp; clearTimeout)</p><h3 id="中转EventBus：实现兄弟通信，跨级通信"><a href="#中转EventBus：实现兄弟通信，跨级通信" class="headerlink" title="中转EventBus：实现兄弟通信，跨级通信"></a>中转EventBus：实现兄弟通信，跨级通信</h3><p><strong><code>CommentArea.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span></span><br><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;comment-textarea&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">autofocus</span></span><br><span class="hljs-tag">    <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请发表您的看法 ...&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span></span><br><span class="hljs-tag">  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> Middle <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./middle&quot;</span>;</span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;CommentArea&quot;</span>,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      value: <span class="hljs-string">&quot;&quot;</span>,</span><br>    &#125;;<br>  &#125;,<br>  watch: &#123;<br><span class="javascript">    <span class="hljs-comment">// (imp)利用中转EventBus实现兄弟组件通信,跨级组件通信</span></span><br><span class="javascript">    <span class="hljs-comment">// 本质: new 一个空 Vue 实例,向它内部添加事件发送和事件监听</span></span><br><span class="javascript">    <span class="hljs-comment">// vm.$emit()发送,vm.$on()监听并执行回调</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">value</span>(<span class="hljs-params">newValue, oldValue</span>)</span> &#123;</span><br><span class="javascript">      Middle.$emit(<span class="hljs-string">&quot;textChange&quot;</span>, newValue);</span><br>    &#125;,<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-comment">// (imp)回调的监听可在组件创建的一开始就开启</span></span><br><span class="javascript">    Middle.$on(<span class="hljs-string">&quot;clearContent&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.value = <span class="hljs-string">&quot;&quot;</span>;</span><br>    &#125;);<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong><code>CommentBtn.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row-display btn-bar&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;clear&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>清空<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>发布<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> Middle <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./middle&quot;</span>;</span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;CommentBtn&quot;</span>,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      content: <span class="hljs-string">&quot;&quot;</span>,</span><br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">submit</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-comment">// this -&gt; 当前组件 vm</span></span><br><span class="javascript">      <span class="hljs-comment">// console.log(this);</span></span><br><span class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.content) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;addComment&quot;</span>, <span class="hljs-built_in">this</span>.content);</span><br><span class="javascript">        Middle.$emit(<span class="hljs-string">&quot;clearContent&quot;</span>);</span><br><span class="javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$Message.info(<span class="hljs-string">&#x27;发布内容不能为空！&#x27;</span>)</span><br>      &#125;<br><span class="javascript">      <span class="hljs-comment">// 点击发布后，重新聚焦到textarea</span></span><br><span class="javascript">      <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;comment-textarea&#x27;</span>).focus();</span><br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      Middle.$emit(<span class="hljs-string">&quot;clearContent&quot;</span>);</span><br>    &#125;,<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-comment">// 监听事件并回调在组件创建阶段开启</span></span><br><span class="javascript">    Middle.$on(<span class="hljs-string">&quot;textChange&quot;</span>, <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;</span><br><span class="javascript">      <span class="hljs-comment">// (imp)中转Vue实例的this指向:</span></span><br><span class="javascript">      <span class="hljs-comment">// 此处 this -&gt; Middle (vm)，Middle 作为中转，this 取决上下文？ 所以 this -&gt; 当前组件 vm ？</span></span><br><span class="javascript">      <span class="hljs-comment">// console.log(this);</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.content = value;</span><br>    &#125;);<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong><code>middle.js</code></strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-regexp">//</span> 作为中转站，承担发送事件$emit(传参)，监听事件$<span class="hljs-literal">on</span>并处罚回调的作用<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vue();<br></code></pre></div></td></tr></table></figure><p>重点：<br>在通用组件编写中，我们碰到兄弟通讯，跨级通讯，往往需要多级父子传递过程，比较麻烦。为了组件的复用性，又不能使用vuex全局管理。此处提出了一种方法：通过空Vue实例实现数据传递。<br>具体操作：</p><ol><li>新建 js 文件，new 一个 Vue 实例并导出</li><li>在需要发送事件的地方导入 js，通过 <code>vm.$emit()</code> 方法传递参数 <a href="https://cn.vuejs.org/v2/api/#vm-emit">vm.$emit()</a></li><li>在需要接收参数的地方导入 js，通过 <code>vm.$on</code> 方法监听事件并触发回调 <a href="https://cn.vuejs.org/v2/api/#vm-on">vm.$on</a></li></ol><p>该方式的好处在于，新建了一个“可自由放置位置”的中转站，代替了通过父组件(甚至更多上层组件)进行传值的问题。我们只需要在传递数据的源头和接受数据的尽头引入中转站即可。<br><strong>疑问：</strong><br>我们实例化了一个新的Vue对象，其内部 this 指向承接上下文吗？以<code>CommentBtn.vue</code>为例，this 指向点符号前对象，即 Middle，但 Middle 作为空 Vue 实例，应该不存在 <code>this.content</code> 才对，但实际上打印出 this 发现，this 与当前组件 <code>&lt;CommentBtn&gt;</code> 相同。猜测：可能空Vue实例没有挂载到某节点，因此this从上下文获取。</p><hr><h4 id="2021-04-02-更新"><a href="#2021-04-02-更新" class="headerlink" title="2021-04-02 更新"></a>2021-04-02 更新</h4><p>关于上述 eventBus this 指向的疑问, 有如下解释:<br>虽然 emit 和 on 都在一个全局的 Vue 实例进行的, 但是基于箭头函数 this 指向取决于定义时上层块级作用域.<br>因此通过分析可知, 此时 on 的回调是在相应的组件中定义的 (使用箭头函数,那么回调函数中的 this 就是组件), 而 bus 则充当了一个挺有趣的中间人</p><h2 id="评论功能代码"><a href="#评论功能代码" class="headerlink" title="评论功能代码"></a>评论功能代码</h2><p>见 <a href="https://github.com/jtwang7/vue-project">vue-project</a> &amp; <a href="https://github.com/jtwang7/vue-project-egg">vue-project-egg</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Egg</tag>
      
      <tag>MySQL</tag>
      
      <tag>Vue</tag>
      
      <tag>axios</tag>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
      <tag>前后端联调</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue侦听功能(watch)</title>
    <link href="/2021/03/22/Vue%E4%BE%A6%E5%90%AC(watch)/"/>
    <url>/2021/03/22/Vue%E4%BE%A6%E5%90%AC(watch)/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue侦听-watch"><a href="#Vue侦听-watch" class="headerlink" title="Vue侦听(watch)"></a>Vue侦听(watch)</h1><p><a href="https://cn.vuejs.org/v2/api/#watch">vue(watch)官方文档</a></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;LayoutFrame&quot;</span>,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      isCollapsed: <span class="hljs-literal">false</span>,</span><br>    &#125;;<br>  &#125;,<br>  watch: &#123;<br><span class="javascript">    <span class="hljs-string">&quot;$route.path&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue, oldValue</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(newValue);</span><br><span class="javascript">      <span class="hljs-comment">// js 中数组取末尾不能用索引-1，因为不支持该写法。</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.curActiveName = newValue;</span><br>    &#125;,<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>重点：</p><ol><li>watch 接收对象作为属性值</li><li>对象内类型：<code>&#123; [key: string]: string | Function | Object | Array &#125;</code> 即 key 传入的是字符串，属性值有四种(字符串，函数，对象，数组)</li><li>watch 侦听的目标(target)作为 key 值，后面的回调函数在目标发生状态改变时触发，接收 <code>(newValue, oldValue)</code>，其中 newValue 为新状态值， oldValue 为旧状态值。</li><li>watch 可以侦听 store ，router，route 等全局实例，和监听普通变量一样，同样不需要加 this。</li></ol><h1 id="JS-数组拼接技巧"><a href="#JS-数组拼接技巧" class="headerlink" title="JS 数组拼接技巧"></a>JS 数组拼接技巧</h1><p>通常会遇到以下应用场景：<br>对某一数组内的值进行处理，并返回新的数组。此时我们可以用 <code>arr.map(()=&gt;&#123;&#125;)</code> 来实现，<br>但当<code>arr.map(()=&gt;&#123;&#125;)</code> 内部返回数组时，我们希望将数组整合成一个数组，可采用如下方式：</p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript">[].concat.apply([],arr.map(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>   ...<br>   <span class="hljs-keyword">return</span> xxx<br>&#125;))<br></code></pre></div></td></tr></table></figure><p><code>[].concat</code> 为数组拼接，<code>.apply()</code>表示对其回调函数返回值都应用<code>.concat()</code>方法，<code>.apply([],callback())</code>第一个参数为this指向，此处指向<code>[]</code>空数组，即定义初始值。</p><h1 id="html-a标签禁用跳转功能"><a href="#html-a标签禁用跳转功能" class="headerlink" title="html a标签禁用跳转功能"></a>html a标签禁用跳转功能</h1><p><code>&lt;a&gt;</code>标签除了作为跳转标签外，还可以包裹文本等元素，使之具有点击的功能(即鼠标放在文本上，显示点击图标)。<br>但包裹的文本，我们通常不希望其具备跳转的功能，因此，我们可以通过：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:void(0)&quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>取消其跳转的功能</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue项目登录功能实现</title>
    <link href="/2021/03/21/Vue%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/03/21/Vue%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue登录功能实现"><a href="#Vue登录功能实现" class="headerlink" title="Vue登录功能实现"></a>Vue登录功能实现</h1><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>vue + vue-router + iviewUI + egg.js</p><h2 id="登录页面制作"><a href="#登录页面制作" class="headerlink" title="登录页面制作"></a>登录页面制作</h2><p><img src="/img/posts_img/20210321104031010_1796.png"></p><p><strong><code>Login.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login-container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login-body&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>账户登录<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">LoginBar</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:icon</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#icon-user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:input</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">Input</span></span><br><span class="hljs-tag">            <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;account&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Account ...&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200px; padding-bottom: 15px&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-style&quot;</span></span><br><span class="hljs-tag">          /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">LoginBar</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">LoginBar</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:icon</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">&quot;#icon-password&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:input</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">Input</span></span><br><span class="hljs-tag">            <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;password&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">password</span></span><br><span class="hljs-tag">            <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Password ...&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200px; padding-bottom: 10px&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-style&quot;</span></span><br><span class="hljs-tag">          /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">LoginBar</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">LoginBtn</span> <span class="hljs-attr">:account</span>=<span class="hljs-string">&quot;account&quot;</span> <span class="hljs-attr">:password</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;@/assets/login/iconfont.js&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> LoginBar <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./LoginBar&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> LoginBtn <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./LoginBtn&#x27;</span></span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;Login&quot;</span>,</span><br>  components: &#123;<br>    LoginBar,<br>    LoginBtn,<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      account: <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="javascript">      password: <span class="hljs-string">&quot;&quot;</span>,</span><br>    &#125;;<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="css"><span class="hljs-comment">/* style scoped 包裹样式只能在该组件内使用 */</span></span><br><span class="css"><span class="hljs-selector-id">#login-container</span> &#123;</span><br>  position: absolute;<br>  width: 100%;<br>  height: 100%;<br>  top: 0;<br>  left: 0;<br>  z-index: -1;<br><span class="css">  <span class="hljs-comment">/* style内引入图片不能用@ */</span></span><br>  background-image: url(&quot;../../../assets/login-background.png&quot;);<br>  background-size: 100%;<br>&#125;<br><br><span class="css"><span class="hljs-selector-class">.login-body</span> &#123;</span><br>  margin-top: 20vh;<br>  margin-left: 20vw;<br>  margin-right: 20vw;<br>  height: 200px;<br><br>  display: flex;<br>  flex-direction: column;<br>  justify-content: space-around;<br>  align-items: center;<br>&#125;<br><br><span class="css"><span class="hljs-selector-class">.login-body</span> <span class="hljs-selector-class">.title</span> &#123;</span><br>  color: white;<br>  font-weight: bolder;<br>  font-size: 2em;<br>  margin-bottom: 20px;<br>&#125;<br><br><span class="css"><span class="hljs-comment">/* iconfont 下载的图标通过 font-size 调大小 */</span></span><br><span class="css"><span class="hljs-selector-class">.login-body</span> <span class="hljs-selector-class">.icon</span> &#123;</span><br>  font-size: 30px;<br>  margin-right: 10px;<br>&#125;<br><br><span class="css"><span class="hljs-selector-class">.login-body</span> <span class="hljs-selector-class">.input-style</span> &#123;</span><br>    margin-right: 2vw;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-comment">/* 全局CSS样式 */</span></span><br><span class="css"><span class="hljs-selector-class">.icon</span> &#123;</span><br>  width: 1em;<br>  height: 1em;<br><span class="css">  <span class="hljs-selector-tag">vertical-align</span>: <span class="hljs-selector-tag">-0</span><span class="hljs-selector-class">.15em</span>;</span><br>  fill: currentColor;<br>  overflow: hidden;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong><code>LoginBar.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login-bar&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;input&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name:<span class="hljs-string">&#x27;LoginBar&#x27;</span></span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scopoed</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.login-bar</span> &#123;</span><br>  display: flex;<br>  justify-content: space-around;<br>  align-items: center;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="技术点总结："><a href="#技术点总结：" class="headerlink" title="技术点总结："></a>技术点总结：</h3><p>css 样式篇：</p><ol><li><code>&lt;style scoped&gt;</code> 管理当前组件内CSS样式，<code>&lt;style&gt;</code> 管理全局CSS样式。</li><li><code>&lt;style&gt;</code> 内外部引入 CSS 样式通过：<code>@import &#39;../../../xxx.css&#39;</code>，注意此处必须为 <code>&#39;../../&#39;</code> 路径，不能为 <code>@/xx/xx/</code>，踩坑的地方是程序编译时会加载成<code>./@/xxx/xxx/</code>路径。</li><li>iconfont 图标库下载的图标，大小可以通过<code>font-size</code>调整。</li><li>iconfont Symbol 类图标使用 (可参考下载文件中的<code>demo_index.html</code>)：在 <code>&lt;script&gt;</code> 中引入 <code>&#39;iconfont.js&#39;</code> 文件，根据样例代码在模板中引用即可。</li></ol><p>组件篇：</p><ol><li><code>&lt;LoginBar&gt;</code> 是自定义的预留插槽组件。</li><li><code>&lt;LoginBtn&gt;</code> 是封装的登录按钮(讲业务逻辑时贴代码)。</li><li><code>&lt;Input&gt;</code>是<a href="https://www.iviewui.com/">iviewui</a>的封装组件，按照官方文档使用即可。</li></ol><h2 id="主应用“登录-注册”按钮制作"><a href="#主应用“登录-注册”按钮制作" class="headerlink" title="主应用“登录/注册”按钮制作"></a>主应用“登录/注册”按钮制作</h2><p><img src="/img/posts_img/20210321105417697_12639.png"></p><p><strong><code>NoLogged.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;no-logged&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isLogged&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- mouseover.native --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 监听原生事件时，需要通过.native修饰符 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 自定义事件官方文档：https://cn.vuejs.org/v2/guide/components-custom-events.html --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;sign&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;signHover ? &#x27;text-active-style&#x27; : &#x27;text-style&#x27;&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">mouseover.native</span>=<span class="hljs-string">&quot;signHover = true&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">mouseout.native</span>=<span class="hljs-string">&quot;signHover = false&quot;</span></span><br><span class="hljs-tag">      &gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span></span><br><span class="hljs-tag">    &gt;</span><br>    /<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;reg&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;regHover ? &#x27;text-active-style&#x27; : &#x27;text-style&#x27;&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">mouseover.native</span>=<span class="hljs-string">&quot;regHover = true&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">mouseout.native</span>=<span class="hljs-string">&quot;regHover = false&quot;</span></span><br><span class="hljs-tag">      &gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span></span><br><span class="hljs-tag">    &gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;NoLogged&quot;</span>,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      signHover: <span class="hljs-literal">false</span>,</span><br><span class="javascript">      regHover: <span class="hljs-literal">false</span>,</span><br>    &#125;;<br>  &#125;,<br>  props: &#123;<br>    sign: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;&quot;</span>,</span><br>    &#125;,<br>    reg: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;&quot;</span>,</span><br>    &#125;,<br>    isLogged: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">Boolean</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-literal">true</span>,</span><br>    &#125;,<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-selector-id">#no-logged</span> &#123;</span><br>  color: white;<br>&#125;<br><br><span class="css"><span class="hljs-selector-id">#no-logged</span> <span class="hljs-selector-class">.text-style</span> &#123;</span><br>  color: white;<br>&#125;<br><br><span class="css"><span class="hljs-selector-id">#no-logged</span> <span class="hljs-selector-class">.text-active-style</span> &#123;</span><br>  color: rgb(250, 150, 133);<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="技术点总结：-1"><a href="#技术点总结：-1" class="headerlink" title="技术点总结："></a>技术点总结：</h3><p>此处用 <code>&lt;router-link&gt;</code> 组件监听和实现路由跳转 (编程式路由也可以实现)。</p><p><strong>业务逻辑：</strong></p><ol><li>点击登录或注册，实现路由跳转(此处暂时只实现了登陆页面的跳转)。</li><li>样式修改：当鼠标移动到登录或注册上时，通过监听原生事件动态修改样式。</li></ol><p><strong>重点：</strong></p><ol><li>vue 监听原生事件(mouseover, keyup, …)时，需要通过 <code>.native</code> 修饰符。详情参考官方文档：<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html">自定义事件</a></li><li>动态改变样式(两种方法)：vue的<a href="https://cn.vuejs.org/v2/guide/class-and-style.html#%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95">动态class绑定</a><code>:class=&quot;&#123;&#39;styleName1&#39;:isActived, &#39;styleName2&#39;:!isActived&#125;&quot;</code> 或者通过三元运算符<code>:class=&quot;isActived?&#39;styleName1&#39;:&#39;styleName2&#39;&quot;</code></li></ol><h2 id="主应用登陆成功后“用户头像”展示"><a href="#主应用登陆成功后“用户头像”展示" class="headerlink" title="主应用登陆成功后“用户头像”展示"></a>主应用登陆成功后“用户头像”展示</h2><p><img src="/img/posts_img/20210321110943778_9692.png"></p><p><strong><code>Logged.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Dropdown</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isLogged&quot;</span> @<span class="hljs-attr">on-click</span>=<span class="hljs-string">&quot;click&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:void(0)&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;avatar-container&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../../../assets/userAvatar.png&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;ios-arrow-down&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:white;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Icon</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">DropdownMenu</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">DropdownItem</span>&gt;</span>个人中心<span class="hljs-tag">&lt;/<span class="hljs-name">DropdownItem</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">DropdownItem</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">DropdownItem</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">DropdownItem</span> <span class="hljs-attr">disabled</span>&gt;</span>权限管理<span class="hljs-tag">&lt;/<span class="hljs-name">DropdownItem</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">DropdownItem</span> <span class="hljs-attr">divided</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;signout&quot;</span>&gt;</span>退出登录<span class="hljs-tag">&lt;/<span class="hljs-name">DropdownItem</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">DropdownMenu</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Dropdown</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;Logged&quot;</span>,</span><br>  props: &#123;<br>    isLogged: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">Boolean</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-literal">false</span>,</span><br>    &#125;,<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">click</span>(<span class="hljs-params">name</span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">name === <span class="hljs-string">&#x27;signout&#x27;</span></span>)</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">this</span>.$router.replace(<span class="hljs-string">&#x27;/main/gaode/tourist&#x27;</span>);</span><br>          &#125;<br>      &#125;<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br>img &#123;<br>  width: 100%;<br>&#125;<br><br><span class="css"><span class="hljs-selector-class">.avatar-container</span> &#123;</span><br>  border-radius: 50%;<br>  width: 40px;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="技术点总结：-2"><a href="#技术点总结：-2" class="headerlink" title="技术点总结："></a>技术点总结：</h3><p>css 样式篇：</p><ol><li><code>img &#123;&#125;</code> 对所有 img 标签进行样式管理。</li><li>图片样式裁剪为圆形的方法：在 img 标签内定义样式 <code>border-radius: 50%</code>。</li></ol><p>组件篇：</p><ol><li>下拉菜单采用 <a href="https://www.iviewui.com/components/dropdown">Dropdown</a> 。</li></ol><p>业务逻辑篇：</p><ol><li>监听下拉菜单内的点击事件<code>on-click</code> (详见官方文档API)，当点击<strong>退出登录</strong>时，通过编程式路由跳转到游客界面(即<strong>登录/注册</strong>)。</li></ol><h2 id="“登录-注册”与“用户头像”切换"><a href="#“登录-注册”与“用户头像”切换" class="headerlink" title="“登录/注册”与“用户头像”切换"></a>“登录/注册”与“用户头像”切换</h2><p><strong><code>Sign.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sign&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Logged</span> <span class="hljs-attr">:isLogged</span>=<span class="hljs-string">&#x27;Logged&#x27;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">NoLogged</span> <span class="hljs-attr">:isLogged</span>=<span class="hljs-string">&#x27;!Logged&#x27;</span> <span class="hljs-attr">sign</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">reg</span>=<span class="hljs-string">&quot;/login&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> Logged <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Logged&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">import</span> NoLogged <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./NoLogged&#x27;</span></span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;Sign&quot;</span>,</span><br>  components: &#123;<br>    Logged,<br>    NoLogged,<br>  &#125;,<br>  computed: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">Logged</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.$route.params.id);</span><br><span class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$route.params.id === <span class="hljs-string">&#x27;tourist&#x27;</span>) &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-selector-id">#sign</span> &#123;</span><br>  margin-left: 30px;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="技术点总结：-3"><a href="#技术点总结：-3" class="headerlink" title="技术点总结："></a>技术点总结：</h3><p><strong>计算属性 + 路由传参</strong><br>通过计算属性判断当前路由：<br>若路由 parmas 动态传参值为 <code>tourist</code>，则“登录/注册”的 <code>v-if=true</code>；<br>若路由 parmas 动态传参值为 <code>用户id</code>，则“用户头像”的 <code>v-if=true</code>；</p><h2 id="登录按钮及其业务逻辑"><a href="#登录按钮及其业务逻辑" class="headerlink" title="登录按钮及其业务逻辑"></a>登录按钮及其业务逻辑</h2><p><strong><code>LoginBtn.vue</code></strong></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;circle&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sign&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- .stop 修饰符阻止事件冒泡 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;log-in&quot;</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;sign&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; login &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/network/login&quot;</span>;</span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;LoginBtn&quot;</span>,</span><br>  props: &#123;<br>    account: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;&quot;</span>,</span><br>    &#125;,<br>    password: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;&quot;</span>,</span><br>    &#125;,<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">sign</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.account) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$Message.info(<span class="hljs-string">&quot;请输入用户名...&quot;</span>);</span><br><span class="javascript">        <span class="hljs-comment">// 中断该方法继续进行，否则还会进行请求</span></span><br><span class="javascript">        <span class="hljs-keyword">return</span>;</span><br><span class="javascript">      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.password) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$Message.info(<span class="hljs-string">&quot;请输入密码...&quot;</span>);</span><br><span class="javascript">        <span class="hljs-keyword">return</span>;</span><br>      &#125;<br><br><span class="javascript">      <span class="hljs-comment">// 需要设置拦截器！！否则请求的是axios包装的值</span></span><br><span class="javascript">      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> login(&#123;</span><br><span class="javascript">        account: <span class="hljs-built_in">this</span>.account,</span><br><span class="javascript">        password: <span class="hljs-built_in">this</span>.password,</span><br>      &#125;);<br><br><span class="javascript">      <span class="hljs-keyword">if</span> (res === <span class="hljs-string">&#x27;success&#x27;</span>) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$router.replace(<span class="hljs-string">`/main/gaode/<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.account&#125;</span>`</span>);</span><br><span class="javascript">      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res === <span class="hljs-string">&#x27;refused&#x27;</span>) &#123;</span><br><span class="javascript">        <span class="hljs-comment">// iviewUI的方法，不是Vue内部的</span></span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$Message.info(<span class="hljs-string">&quot;密码错误！请重新登录...&quot;</span>);</span><br><span class="javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$Message.info(<span class="hljs-string">&quot;用户名不存在...&quot;</span>);</span><br>      &#125;<br>    &#125;,<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.circle</span> &#123;</span><br>  width: 100px;<br>  height: 100px;<br>  background: rgb(248, 143, 74);<br>  -moz-border-radius: 50px;<br>  -webkit-border-radius: 50px;<br>  border-radius: 50px;<br><br>  display: flex;<br>  justify-content: center;<br>  align-items: center;<br><br>  margin-top: 20px;<br>&#125;<br><br><span class="css"><span class="hljs-selector-class">.log-in</span> &#123;</span><br>  font-weight: bolder;<br>  font-size: 2em;<br>  display: block;<br><br>  color: rgb(119, 119, 143);<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="技术点总结：-4"><a href="#技术点总结：-4" class="headerlink" title="技术点总结："></a>技术点总结：</h3><ol><li><code>.stop</code> 修饰符阻止事件冒泡：此例中，子组件和父组件都监听了click事件，当子组件监听到click事件后，由于事件冒泡，父组件也会重复响应。通过<code>.stop</code>修饰符可以解决该问题。</li><li><code>this.Message.info(&#39;xxx&#39;)</code>为 <a href="https://www.iviewui.com/components/message">iviewui 的全局提示事件</a>，非 vue 自带。</li><li>判断是否登陆成功的业务逻辑：若未输入用户名，提示(且中断函数) =&gt; 若未输入密码，提示(且中断函数)；若上述完成，向后端发送请求，后端判断后返回数据，若成功则返回<code>success</code>，失败返回<code>refused</code>，用户名不存在返回<code>empty</code>，前端异步等待接收结果后，作进一步判断(<code>success</code>:编程式路由跳转，<code>refused || empty</code>:全局提示)</li></ol><h2 id="egg-js后端业务逻辑"><a href="#egg-js后端业务逻辑" class="headerlink" title="egg.js后端业务逻辑"></a>egg.js后端业务逻辑</h2><h3 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Egg.Application&#125;</span> <span class="hljs-variable">app</span></span> - egg application</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router/map&#x27;</span>)(app);<br>  <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router/account&#x27;</span>)(app);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>技术点总结：</strong><br>此处对路由做了管理，具体路由分类放至创建的<code>router</code>文件夹下，通过CommonJS模块导入方法<code>require()</code>引入。各路由文件返回的是方法且接受<code>app</code>参数，因此 require 请求后得到的结果当作方法使用。</p><h3 id="router-account-js"><a href="#router-account-js" class="headerlink" title="/router/account.js"></a>/router/account.js</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; router, controller &#125; = app;<br>    <span class="hljs-comment">// 用户账号路由</span><br>    router.post(<span class="hljs-string">&#x27;/login&#x27;</span>,controller.getAccount.verify);<br>&#125;;<br></code></pre></div></td></tr></table></figure><p><strong>技术点总结：</strong><br>导出Post路由，路径指向<code>/login</code>，调用 controller 对象内挂载的 getAccount 实例的 verify (异步)方法。</p><h3 id="controller-getAccount-js"><a href="#controller-getAccount-js" class="headerlink" title="/controller/getAccount.js"></a>/controller/getAccount.js</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> Controller = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;egg&#x27;</span>).Controller;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetAccountController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">verify</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123; ctx &#125; = <span class="hljs-built_in">this</span><br>        ctx.body = <span class="hljs-keyword">await</span> ctx.service.account.verify()<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = GetAccountController;<br></code></pre></div></td></tr></table></figure><p><strong>技术点总结：</strong><br>从 <code>egg.Controller</code> 中导入 Controller 类，继承该基类，类内定义方法：等待 <code>service.accout.verify()</code> 完成并将值返回给 <code>ctx.body</code> 暴露到响应体内传给前端。记住导出该类。</p><h3 id="service-account-js"><a href="#service-account-js" class="headerlink" title="/service/account.js"></a>/service/account.js</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> Service = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;egg&#x27;</span>).Service;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">verify</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123; ctx, app &#125; = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">// body: &#123;account:&#x27;xxx&#x27;,password:&#x27;yyy&#x27;&#125;</span><br>        <span class="hljs-keyword">const</span> &#123; account, password &#125; = ctx.request.body<br>        <span class="hljs-comment">// 数据库若没有用户则返回 []</span><br>        <span class="hljs-comment">// 数据库存在用户，返回形如 [ RowDataPacket &#123; id: 1, user: &#x27;admin&#x27;, password: &#x27;123456&#x27; &#125; ]</span><br>        <span class="hljs-keyword">const</span> target = <span class="hljs-keyword">await</span> app.mysql.select(<span class="hljs-string">&#x27;account&#x27;</span>, &#123;<br>            where: &#123;<br>                user: account,<br>            &#125;<br>        &#125;)<br>        <span class="hljs-keyword">if</span> (target.length !== <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (target[<span class="hljs-number">0</span>].password === password) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;success&#x27;</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;refused&#x27;</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;empty&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = AccountService;<br></code></pre></div></td></tr></table></figure><p><strong>技术点总结：</strong><br><code>/service</code>主要管理数据库一类的操作，此处业务逻辑：从前端请求(post)的body中读取账户密码，通过账户在数据库内查找用户，若存在该用户，返回形如 <code>[ RowDataPacket &#123; id: 1, user: &#39;admin&#39;, password: &#39;123456&#39; &#125; ]</code>的数组，若不存在则返回空数组<code>[]</code>，之后再验证密码即可。<br>注意：egg.js 中默认开启了 csrf 安全防护，请参考<a href="https://eggjs.org/zh-cn/basics/router.html">官方文档</a>，在<code>config/config.default.js</code>中关闭。</p><h2 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h2><p>采用 DBeaver 可视化管理数据库：<br>新建表 - 新建列 - 添加数据 - 设置约束(主键)<br><img src="/img/posts_img/20210321115010709_24364.png"></p><h2 id="前端-Post-请求及路由配置"><a href="#前端-Post-请求及路由配置" class="headerlink" title="前端 Post 请求及路由配置"></a>前端 Post 请求及路由配置</h2><h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><p><strong><code>/network/index.js</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> basePost = <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> instance = axios.create(&#123;<br>        baseURL: <span class="hljs-string">&#x27;http://127.0.0.1:7001&#x27;</span>,<br>        method: <span class="hljs-string">&#x27;post&#x27;</span>,<br>        timeout: <span class="hljs-number">5000</span>,<br>    &#125;)<br><br>    instance.interceptors.response.use(<br>        res =&gt; &#123;<br>            <span class="hljs-keyword">return</span> res.data<br>        &#125;,<br>        err =&gt; &#123;<br>            <span class="hljs-built_in">console</span>.log(err);<br>        &#125;)<br><br>    <span class="hljs-keyword">return</span> instance(config)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>技术点总结：</strong><br>统一封装基础 post 请求配置，并设置响应拦截器，用于过滤 axios 对响应结果的包装。</p><p><strong><code>/network/login.js</code></strong></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">import &#123; basePost &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index&#x27;</span><br><br><span class="hljs-builtin-name">export</span> const login = (config) =&gt; &#123;<br>    const &#123; account, password &#125; = config;<br>    return basePost(&#123;<br>        url: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>        data: &#123;<br>            account,<br>            password,<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>技术点总结：</strong><br>独立封装符合当前业务逻辑的 post 请求，返回一个 Promise 对象(axios实例本身就是 Promise 对象，当获得响应结果后，可以通过该 Promise 执行后续处理操作)。</p><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br>Vue.use(VueRouter)<br><br><span class="hljs-comment">// 应用页面</span><br><span class="hljs-keyword">const</span> MainRoute = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/Main&#x27;</span>)<br><span class="hljs-comment">// main-地图路由</span><br><span class="hljs-keyword">const</span> GaodeRoute = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/common/map/EchartsGaode&#x27;</span>);<br><span class="hljs-keyword">const</span> MapboxRoute = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/common/map/Mapbox&#x27;</span>);<br><br><span class="hljs-comment">// 登陆页面</span><br><span class="hljs-keyword">const</span> LoginRoute = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/common/login/Login&#x27;</span>);<br><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    path: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    redirect: <span class="hljs-string">&#x27;/main/gaode/tourist&#x27;</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-comment">// 应用页面</span><br>    path: <span class="hljs-string">&#x27;/main&#x27;</span>,<br>    component: MainRoute,<br>    children: [<br>      &#123;<br>        path: <span class="hljs-string">&#x27;gaode/:id&#x27;</span>,<br>        component: GaodeRoute,<br>      &#125;,<br>      &#123;<br>        path: <span class="hljs-string">&#x27;mapbox&#x27;</span>,<br>        component: MapboxRoute,<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-comment">// 登陆页面</span><br>    path: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>    component: LoginRoute,<br>  &#125;,<br>]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  mode: <span class="hljs-string">&#x27;history&#x27;</span>,<br>  base: process.env.BASE_URL,<br>  routes<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br><br></code></pre></div></td></tr></table></figure><p><strong>技术点总结：</strong><br>路由代码包括了主应用界面的路由配置和登陆页面的路由配置。主页面组件<code>&lt;Main /&gt;</code>和登陆界面组件<code>&lt;Login /&gt;</code>均放在项目入口组件<code>&lt;App /&gt;</code>下，通过<code>&lt;router-view&gt;</code>展示。<br>注意：<code>&lt;Main /&gt;</code> 和 <code>&lt;Login /&gt;</code>是同级关系，这样可以实现整体页面的刷新(及发生路由跳转时，登陆页面整体替换主页面)，而<code>&lt;Main /&gt;</code>组件内的路由跳转要写在其子级路径，如代码所示。</p><h4 id="项目入口组件-App-vue"><a href="#项目入口组件-App-vue" class="headerlink" title="项目入口组件 App.vue"></a>项目入口组件 App.vue</h4><figure class="highlight xquery"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default </span><span class="xquery">&#123;</span><br><span class="xquery"> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="xquery">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></div></td></tr></table></figure><p>此处<code>&lt;router-view&gt;</code>展示的是<code>&lt;Main /&gt;</code> 和 <code>&lt;Login /&gt;</code>，及最顶层的路由关系。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Egg</tag>
      
      <tag>MySQL</tag>
      
      <tag>Vue</tag>
      
      <tag>前后端联调</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js - vue-router</title>
    <link href="/2021/03/18/Vue-Router/"/>
    <url>/2021/03/18/Vue-Router/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h1><p>vue-router 学习比较系统全面，因此直接拿 vue 项目练习和讲解，此项目主要包含了 vue-router 的使用以及一些辅助的页面组件。<br>项目主要的结构如下(主要业务逻辑代码在src路径下)：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs stylus">learnvuerouter<br>├─ .gitignore<br>├─ babel<span class="hljs-selector-class">.config</span>.js<br>├─ package-lock.json<br>├─ package.json<br>├─ public<br>│  ├─ favicon.ico<br>│  └─ index.html<br>├─ README.md<br>├─ src<br>│  ├─ App.vue<br>│  ├─ assets  <span class="hljs-comment">//静态资源</span><br>│  │  └─ logo.png<br>│  ├─ components  <span class="hljs-comment">//组件</span><br>│  │  ├─ HelloWorld.vue<br>│  │  ├─ Info.vue<br>│  │  ├─ News.vue<br>│  │  ├─ Profile.vue<br>│  │  └─ User.vue<br>│  ├─ main<span class="hljs-selector-class">.js</span>  <span class="hljs-comment">//项目入口文件(Vue实例)</span><br>│  ├─ router  <span class="hljs-comment">//路由</span><br>│  │  └─ index<span class="hljs-selector-class">.js</span>  <span class="hljs-comment">//路由入口文件</span><br>│  └─ views<br>│     ├─ About.vue<br>│     └─ Home.vue<br>└─ 路由学习.txt<br></code></pre></td></tr></table></figure><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="Part1-vue-router-安装及引用"><a href="#Part1-vue-router-安装及引用" class="headerlink" title="Part1: vue-router 安装及引用"></a>Part1: vue-router 安装及引用</h3><p>Vue框架在安装的时候会提示开发者是否选择vue-router库，若选择则在项目生成过程中自动安装vue-router库，并提供相应的示例代码。若没有在项目初始化时安装vue-router，可以通过npm或yarn命令安装。<br>安装：<code>npm install --save vue-router</code><br>引用：<br><code>ES6 - import VueRouter from &#39;vue-router&#39;</code><br><code>CommonJs - const VueRouter = require(&#39;vue-router&#39;)</code><br><strong>注意：vue-router在开发和发布使用时均会使用，为了在<code>package.json</code>中添加相应的依赖，安装时请务必加上<code>--save</code></strong><br><a href="https://router.vuejs.org/zh/">Vue-Router官方中文文档</a></p><h3 id="Part2-vue-router-在项目目录结构中的存放位置"><a href="#Part2-vue-router-在项目目录结构中的存放位置" class="headerlink" title="Part2: vue-router 在项目目录结构中的存放位置"></a>Part2: vue-router 在项目目录结构中的存放位置</h3><p>在Vue项目内，开发人员一般将业务逻辑写在<code>/src</code>路径下，其中<code>/components</code>主要用于存放项目组件，<code>/views</code>存放整体页面视图，<code>/assets</code>存放静态资源，<code>/router</code>则主要存放路由配置。<br>注：项目结构内文件名并不是固定的，但是在行业内已经形成不成文规范，建议遵循此规范合理规划项目目录结构。</p><p>vue-router 文件夹路径：<code>/src/router</code><br>vue-router 入口文件：<code>/src/router/index.js</code><br>注：入口文件一般写为<code>index.js</code>，这是因为 webpack 在编译文件路径时，默认可以省略 <code>/index.js</code> 以及 <code>/node_modules</code>两个路径(可在webpack配置内更改)。因此引用vue-router时，一般简写为<code>/src/router</code>即可。</p><h3 id="Part3-vue-router的正式讲解"><a href="#Part3-vue-router的正式讲解" class="headerlink" title="Part3: vue-router的正式讲解"></a>Part3: vue-router的正式讲解</h3><h4 id="step1-引用-amp-插件注册-amp-挂载"><a href="#step1-引用-amp-插件注册-amp-挂载" class="headerlink" title="step1: 引用&amp;插件注册&amp;挂载"></a>step1: 引用&amp;插件注册&amp;挂载</h4><p>vue-router作为一个库，一个插件，在使用前必须被Vue项目引用和注册。<br><strong>注：所有Vue插件在使用前都需要经过<code>Vue.use()</code>注册安装</strong><br>具体步骤如下：<br><code>/src/router/index.js</code>路由入口文件下</p><ol><li>引入 vue-router</li><li><code>Vue.use()</code>注册安装插件</li><li>实例化路由 (常用参数有 routes, mode 等，属性名称均固定，不能随意设置)</li><li>导出路由</li></ol><p><code>/src/index.js</code>项目入口文件下</p><ol><li>引入创建的路由实例router</li><li>在Vue实例下挂载router路由实例</li></ol><p><strong>完整代码：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-regexp">/src/</span>router/index.js(路由入口文件)<br>import Vue from <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-regexp">//</span> step1: 引入vue-router<br>import VueRouter from <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-regexp">//</span> Vue.use() 当使用插件时都需要使用 Vue.use()<br><span class="hljs-regexp">//</span> step2：Vue.use(插件)<br>Vue.use(VueRouter)<br><br><span class="hljs-regexp">//</span> step3: 实例化router路由<br>const router = new VueRouter(&#123;<br>    routes,<br>    mode: <span class="hljs-string">&#x27;history&#x27;</span><br>&#125;)<br><br><span class="hljs-regexp">//</span> step4: 导出路由实例<br>export default router<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-regexp">/src/m</span>ain.js(项目入口文件)<br>import Vue from <span class="hljs-string">&#x27;vue&#x27;</span><br>import App from <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-regexp">//</span> step1: 导入router实例，/index.js 可以省略<br>import router from <span class="hljs-string">&#x27;./router&#x27;</span><br><br><span class="hljs-regexp">//</span> 产品提示，在发布阶段改为true<br>Vue.config.productionTip = false<br><br>new Vue(&#123;<br><span class="hljs-regexp">//</span> step2: 将router实例传入 Vue 实例进行挂载(此处用了ES6字面量增强写法)<br>  router,<br>  render: h =&gt; h(App)<br>&#125;).<span class="hljs-variable">$mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><span class="hljs-regexp">//</span> <span class="hljs-variable">$mount</span>() &lt;=&gt; el: <span class="hljs-string">&#x27;xxx&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="step2-路由数组配置"><a href="#step2-路由数组配置" class="headerlink" title="step2: 路由数组配置"></a>step2: 路由数组配置</h4><p>我们已经有了一个router实例(有且只有一个)，基础配置如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-keyword">base</span>: process.env.BASE_URL,<br>  mode: <span class="hljs-string">&#x27;history&#x27;</span>,<br>  routes,<br>&#125;)<br></code></pre></td></tr></table></figure><p>可以看到，配置参数中有一项 <code>routes</code>，我们需要在里面配置路由和组件间的映射关系。<br>由于路由和组件的映射有多组，因此 <code>routes</code> 属性接收一个 <code>Array</code> 数组类型，本文后续将其称为路由数组。</p><p>路由数组往往包含了复杂的映射关系，我们一般将其单独声明一个变量存储，然后通过ES6字面量增强的写法配置到 router 实例中。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 不要忘记引入组件<br>import Home from <span class="hljs-string">&#x27;@/components/Home.vue&#x27;</span><br><br>const routes = [<br>  <span class="hljs-regexp">//</span> 路由重定向<br>  &#123;<br>    path: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    redirect: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-regexp">//</span> path 相对路径<br>    path: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    <span class="hljs-regexp">//</span> component 路径对应跳转的组件<br>    component: Home,<br>    name: <span class="hljs-string">&#x27;Home&#x27;</span>,<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><p>路由数组接收<strong>对象</strong>表示映射关系。<br>上述代码为基本的路由数组配置，包括了路由重定向以及路由和组件的映射：</p><h5 id="路由和组件映射关系配置"><a href="#路由和组件映射关系配置" class="headerlink" title="路由和组件映射关系配置"></a>路由和组件映射关系配置</h5><p>常用属性(属性名Vue规定，不能随意更改)：</p><ol><li>path: 路由相对路径。<code>&#39;/&#39;</code>表示根路径，一般为<code>http://localhost:8080/</code></li><li>component: 路由跳转的组件</li><li>name: 路由标识名</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Home.vue&#x27;</span><br><br>//示例：路径跳转到<span class="hljs-string">&#x27;/home&#x27;</span>时，展示Home组件(要将组件导入，否则路由配置不知道Home是什么)<br>&#123;<br>    <span class="hljs-type">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    component: Home,<br>    <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h5><p>路由重定向常用属性：</p><ol><li>path: 路由相对路径</li><li>redirect: 路由重定向的目标路径</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 示例：当路径为<span class="hljs-string">&#x27;/&#x27;</span>时，自动重定向(跳转)到<span class="hljs-string">&#x27;/home&#x27;</span>路径<br>&#123;<br>    path: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    redirect: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>&#125;,<br></code></pre></td></tr></table></figure><h5 id="路由进阶配置——懒加载"><a href="#路由进阶配置——懒加载" class="headerlink" title="路由进阶配置——懒加载"></a>路由进阶配置——懒加载</h5><p><strong>路由懒加载</strong><br>定义：实现了不同路由组件的分割，当路由被访问时才加载对应组件。<br>实现：当发生路由跳转时，调用箭头函数，触发import，导入文件，而非在index.js开始就import组件。</p><p>普通路由加载方式：在最开始就 import 组件</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Home.vue&#x27;</span><br><br>&#123;<br>    <span class="hljs-type">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>    component: Home,<br>    <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>路由懒加载方式</strong>：当发生路由跳转时导入文件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">&#123;<br>    path: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>    name: <span class="hljs-string">&#x27;About&#x27;</span>,<br>    <span class="hljs-regexp">//</span> route level code-splitting<br>    <span class="hljs-regexp">//</span> <span class="hljs-built_in">this</span> generates a separate chunk (about.[hash].js) <span class="hljs-keyword">for</span> <span class="hljs-built_in">this</span> route<br>    <span class="hljs-regexp">//</span> which <span class="hljs-keyword">is</span> lazy-loaded <span class="hljs-keyword">when</span> the route <span class="hljs-keyword">is</span> visited.<br>    component: <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/About.vue&#x27;</span>),<br>&#125;,<br></code></pre></td></tr></table></figure><p><strong>路由懒加载管理</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">建议将路由懒加载单独提取赋值，方便管理<br>const About = () =&gt; import(<span class="hljs-string">&#x27;../views/About.vue&#x27;</span>)<br>const<span class="hljs-built_in"> User </span>= () =&gt; import(<span class="hljs-string">&#x27;../components/User.vue&#x27;</span>)<br>const News = () =&gt; import(<span class="hljs-string">&#x27;../components/News.vue&#x27;</span>)<br>const <span class="hljs-builtin-name">Info</span> = () =&gt; import(<span class="hljs-string">&#x27;../components/Info.vue&#x27;</span>)<br>const<span class="hljs-built_in"> Profile </span>= () =&gt; import(<span class="hljs-string">&#x27;../components/Profile.vue&#x27;</span>)<br><br><span class="hljs-built_in">..</span>.<br><br>&#123;<br>    path: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>    name: <span class="hljs-string">&#x27;About&#x27;</span>,<br>    component: About,<br>&#125;,<br></code></pre></td></tr></table></figure><h5 id="动态路由配置"><a href="#动态路由配置" class="headerlink" title="动态路由配置"></a>动态路由配置</h5><p>在路由跳转过程中，我们往往需要传递某些信息给路由跳转后的组件。<br>动态路由配置可以<strong>让 url 携带一些配置参数进行传递</strong>，主要为 <code>params</code> 和 <code>query</code> 两种方式。<br>作用：路由切换时，传递参数。</p><p><strong><code>params</code>动态路由配置：</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const User = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/User.vue&#x27;</span>)<br><br>...<br><br>&#123;<br>    <span class="hljs-regexp">//</span> params: path 配置时需要事先通过<span class="hljs-string">&#x27;/:xxx&#x27;</span>预留params位置<br>    path: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<br>    component: User,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>params</code>参数接收：</strong><br>params 传递的参数可通过挂载在 Vue 实例下的全局 route 的 params 属性获取：<br><code>this.$route.parmas.id</code></p><p><strong><code>query</code>动态路由配置：</strong><br>query 配置路由时，不需要 <code>/:xxx</code> 预留位置，而是在 url 中添加 <code>xxx=aaa&amp;yyy=bbb</code> 传递参数。<br>query 传参格式参考：<br>协议头://主机名:端口号?query<br><code>http://localhost:8080?name=wjt&amp;age=18</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const Profile = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Profile.vue&#x27;</span>)<br><br>...<br><br>&#123;<br>    <span class="hljs-regexp">//</span> query 动态传参：path 配置普通形式<br>    path: <span class="hljs-string">&#x27;/profile&#x27;</span>,<br>    component: Profile,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>query</code>参数接收：</strong><br>query 传递的参数可通过挂载在 Vue 实例下的全局 route 的 query 属性获取：<br><code>this.$route.query</code><br>获取的是对象类型，形如<code>&#123;name:&#39;wjt&#39;,age:18&#125;</code></p><h5 id="嵌套路由配置"><a href="#嵌套路由配置" class="headerlink" title="嵌套路由配置"></a>嵌套路由配置</h5><p>当路由跳转组件内还有路由和组件的映射关系时，需要在当前路由内配置嵌套路由。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>    <span class="hljs-attribute">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>    name: <span class="hljs-string">&#x27;About&#x27;</span>,<br>    component: About,<br>    // 嵌套路由<br>    children: [<br>      &#123;<br>        // 此处不需要加 <span class="hljs-string">&#x27;/&#x27;</span>，加<span class="hljs-string">&#x27;/&#x27;</span>表示根路径，即 localhost 之后的路径。<br>        // 此处承接父级 <span class="hljs-string">&#x27;/about&#x27;</span>，嵌套路由会自动拼接为 <span class="hljs-string">&#x27;/about/news&#x27;</span><br>        path: <span class="hljs-string">&#x27;news&#x27;</span>,<br>        component: News,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attribute">path</span>: <span class="hljs-string">&#x27;info&#x27;</span>,<br>        component: Info,<br>      &#125;,<br>    ],<br>&#125;,<br></code></pre></td></tr></table></figure><p>嵌套路由配置同普通路由配置相同，唯一要注意的是<strong>嵌套路由在相应路由内通过<code>children</code>属性配置</strong>，由于子路由也是路由，因此**<code>children</code> 属性接收的也是数组类型，数组内为子路由对象**。</p><h4 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h4><p>导航守卫主要用于<strong>监听路由的创建/跳转等，并执行回调函数</strong>。类似于Vue的生命周期。<br>导航守卫根据作用域不同可以分为：</p><ol><li>全局导航守卫</li><li>路由独享守卫</li><li>组件守卫</li></ol><p>本文主要介绍全局导航守卫，让读者了解导航守卫大致的作用以及使用方式，具体细节以及其余守卫请参考Vue-Router官方文档。</p><p>全局导航守卫：作用于全局，内部又根据执行回调的节点不同分为前置守卫，后置守卫等等</p><p><strong>前置守卫</strong> (通过router实例的beforeEach()方法执行)<br><code>xxx.beforeEach()</code>: 在路由跳转前自动执行自定义操作。(监听全局的路由跳转)<br><code>.beforeEach()</code> 是 router 实例的方法，<strong>接收函数作为参数</strong>。其<strong>回调函数中又包含三个参数</strong>：</p><ol><li>to: 跳转的目的路由, 源码内 to 是 route 类型，取数据方法同 $route.xxx</li><li>from: 跳转前的路由, 源码内 from 是 route 类型，取数据方法同 $route.xxx</li><li>next: <strong>next()，必须要调用，否则不能执行下一步</strong>。</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    <span class="hljs-regexp">//</span> params: path 配置时需要事先通过<span class="hljs-string">&#x27;/:xxx&#x27;</span>预留params位置<br>    path: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<br>    <span class="hljs-regexp">//</span> component: User,<br>    component: User,<br>    meta: &#123;<br>      title: <span class="hljs-string">&#x27;用户&#x27;</span>,<br>    &#125;,<br>&#125;,<br><br>...<br><br><span class="hljs-regexp">//</span> 此处前置守卫作用是：发生路由跳转前，获取源路由(to指向的路由)的meta属性中的title值。<br><span class="hljs-regexp">//</span> 此时 to 实际上就是源路由的 route 实例(注意是route实例，不是router实例)<br>router.beforeEach((to, from, <span class="hljs-keyword">next</span>) =&gt; &#123;<br>  document.title = to.meta.title;<br>  <span class="hljs-regexp">//</span> <span class="hljs-keyword">next</span>()内部还能传入参数，具体功能参考 Vue-router 官网<br>  <span class="hljs-keyword">next</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>后置钩子(守卫)</strong><br><code>.afterEach()</code>: 在路由跳转后自动执行自定义操作。(监听全局的路由跳转)<br><code>.afterEach()</code> 是 router 实例的方法，<strong>接收函数作为参数</strong>。其<strong>回调函数中又包含两个参数</strong>：</p><ol><li>to: 跳转的目的路由, 源码内 to 是 route 类型，取数据方法同 $route.xxx</li><li>from: 跳转前的路由, 源码内 from 是 route 类型，取数据方法同 $route.xxx</li></ol><p>!!!注意 .afterEach() 没有next: 因为路由已经跳转完成，不需要进行其他操作，因此没有 next() 函数。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">router.afterEach(<span class="hljs-function"><span class="hljs-params">(to, <span class="hljs-keyword">from</span>)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--------------&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>vue-router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js - vuex</title>
    <link href="/2021/03/18/Vue-vuex/"/>
    <url>/2021/03/18/Vue-vuex/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-vuex"><a href="#Vue-vuex" class="headerlink" title="Vue-vuex"></a>Vue-vuex</h1><p>本文通过练习项目来整体梳理Vue中vuex的组织结构以及使用方式。</p><h2 id="文章组织结构"><a href="#文章组织结构" class="headerlink" title="文章组织结构"></a>文章组织结构</h2><ol><li>项目结构</li><li>vuex 安装 | 引入 | 挂载</li><li>vuex</li><li>vuex 分离管理</li></ol><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs stylus">learnvuex<br>├─ .browserslistrc<br>├─ <span class="hljs-selector-class">.eslintrc</span>.js<br>├─ .gitignore<br>├─ babel<span class="hljs-selector-class">.config</span>.js<br>├─ package-lock.json<br>├─ package.json<br>├─ public<br>│  ├─ favicon.ico<br>│  └─ index.html<br>├─ README.md<br>└─ src<br>   ├─ App.vue<br>   ├─ assets<br>   │  └─ logo.png<br>   ├─ components<br>   │  ├─ OrgCounter.vue<br>   │  ├─ PCCounter.vue<br>   │  └─ VuexCounter.vue<br>   ├─ main<span class="hljs-selector-class">.js</span>  <span class="hljs-comment">//项目入口文件(Vue实例)</span><br>   └─ store  <span class="hljs-comment">//vuex文件夹</span><br>      ├─ actions.js<br>      ├─ getters.js<br>      ├─ index copy.js<br>      ├─ index<span class="hljs-selector-class">.js</span>  <span class="hljs-comment">//vuex入口文件</span><br>      ├─ modules<br>      │  └─ moduleA.js<br>      ├─ mutations-types.js<br>      └─ mutations.js<br></code></pre></td></tr></table></figure><h2 id="Vuex-安装-引入-挂载"><a href="#Vuex-安装-引入-挂载" class="headerlink" title="Vuex 安装 | 引入 | 挂载"></a>Vuex 安装 | 引入 | 挂载</h2><ol><li>npm 安装 vuex: <code>npm install vuex --save</code></li><li>引入 vuex 模块，注册vuex插件: </li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">// /store/index.js</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><br>Vue.use(Vuex);<br></code></pre></td></tr></table></figure><ol start="3"><li>vuex 实例化</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">const store = new Vuex.Store(&#123;<br>  state:&#123;&#125;,<br>  mutations: &#123;&#125;,<br>  actions: &#123;&#125;,<br>  getters: &#123;&#125;,<br>  modules: &#123;&#125;,<br>&#125;)<br><br><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>store;<br></code></pre></td></tr></table></figure><ol start="4"><li>在项目入口文件的Vue实例中挂载 store 实例</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/index&#x27;</span><br><br>Vue.config.productionTip = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  store,<br>  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>作用</strong>：存放多界面共享的数据，同时将其添加到Vue的响应式系统。</p><blockquote><p>注！在 Vuex 中初始化的数据会被添加进入 Vue 的响应式系统，当其管理的数据状态发生变化时，页面也会实时渲染刷新。Vue 的响应式是十分关键和必须要重视的，有些数据更改方式若没有遵循Vue的更改规则，可能不会被响应式系统所响应。</p></blockquote><p><strong>存储路径</strong>：项目中 vuex 往往存放在名为 <code>store</code> 的文件夹内，并以 index.js 作为 vuex 的入口文件。</p><h3 id="store-实例"><a href="#store-实例" class="headerlink" title="store 实例"></a>store 实例</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> store = new Vuex.Store(&#123;<br>  <span class="hljs-keyword">state</span>:&#123;&#125;,<br>  mutations: &#123;&#125;,<br>  actions: &#123;&#125;,<br>  getters: &#123;&#125;,<br>  modules: &#123;&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>vuex 创建实例调用的是 <code>Vuex</code> 的 <code>Store</code> 方法！！！</strong>这也是为什么将vuex的存储路径文件夹取名为store的原因。<br>在 store 实例下，包含5个配置项属性(属性名由Vuex规定，不能随意修改)：</p><ol><li>state: 存放全局共享和管理的状态变量</li><li>mutations: 定义同步操作的函数。(注：mutations 内定义的函数必须为同步函数，且 mutations 往往是对 state 中状态做一系列操作，没有返回值，若在mutations的定义函数中返回值，最终调用mutations内方法时，接收的值将会是undefined)</li><li>actions: 定义异步操作的函数。所有放在 store 实例中管理的异步操作都要定义在 actions 中，并且通过<code>ctx.commit()</code>注册mutations内的方法来执行异步操作状态落定后的一系列同步处理操作。</li><li>getters: 类似vue的computed计算属性，对 state 内的状态变量做一定的预处理后再将其返回，getters 内定义函数调用时也同 computed 一样，以属性的方式调用。(mutations 内方法无法返回值，若有返回值的需求，可以考虑在 getters 内定义)</li><li>modules: Vuex 创建 state 时就指定它为单一状态树。这也决定了我们只能创建一个 store 仓库。尽管 Vuex 有且仅能存在一个 store，它内部仍能通过 modules 进行代码分离。</li></ol><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>作用：存储”共享变量”<br>属性值：接收 Object 对象类型，对象内声明并初始化变量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">state:</span> &#123;<br>    <span class="hljs-attr">shareCount:</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">students:</span> [<br>        &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">18</span> &#125;,<br>        &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;lisi&#x27;</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">30</span> &#125;,<br>        &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">3</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;wangwu&#x27;</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">22</span> &#125;,<br>    ],<br>&#125;<span class="hljs-string">,</span><br></code></pre></td></tr></table></figure><p>组件内state使用：<br>通过挂载在全局的 store 实例获取。<br><code>$store.state.shareCount</code></p><h4 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h4><p>作用：定义”处理共享变量的同步操作”<br>属性值： 接收 Object 对象类型，对象内声明同步方法。<br><strong>方法默认传参</strong>：定义方法时默认传入两个参数且只接受这两个参数：<br>在参数中，第一参数为当前store的<code>state</code>；第二参数为mutation的载荷<code>payload</code>，用于接受传递的额外数据。</p><ol><li><code>state</code> : 对应store仓库内的state，因此mutations方法内不需要通过this.state调用共享变量</li><li><code>payload</code> : 组件在注册(后续会提及mutations在组件中的使用)时，需要传递的参数通过 payload 传递。若只传一个参数，则 payload 及等价于该参数，若传递多个参数，则需要用 <code>&#123;&#125;</code> 包裹成对象赋值给 payload。</li></ol><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pf">mutations: &#123;<br>    addCount(<span class="hljs-keyword">state</span>) &#123;<br>        <span class="hljs-keyword">state</span>.shareCount++;<br>    &#125;,<br>    subCount(<span class="hljs-keyword">state</span>) &#123;<br>        <span class="hljs-keyword">state</span>.shareCount--;<br>    &#125;,<br>    // mutations 中定义的函数可以看作两部分：<br>    // <span class="hljs-number">1</span>.type(事件类型)： 即 addFiveCount<br>    // <span class="hljs-number">2</span>.回调函数：即(<span class="hljs-keyword">state</span>,payload) &#123;...&#125;<br>    [ADDFIVECOUNT](<span class="hljs-keyword">state</span>, payload) &#123;<br>        <span class="hljs-keyword">state</span>.shareCount += payload<br>    &#125;,<br>    [ADDMEMBERINFO](<span class="hljs-keyword">state</span>, payload) &#123;<br>        // Vuex 创建 <span class="hljs-keyword">state</span> 时初始化的值被添加到 Vue 的响应式系统中<br>        // 通过类似于 xx = xxx 等后续添加不能添加至响应式系统，因此页面不会更改。<br>        // 需要运用一些 Vue 支持响应式的方法或者 Vue.<span class="hljs-built_in">set</span>()  Vue.delete() 对数据进行更新操作<br><br>        // <span class="hljs-keyword">state</span>.students.push(payload)<br>        Vue.<span class="hljs-built_in">set</span>(<span class="hljs-keyword">state</span>.students, <span class="hljs-keyword">state</span>.students.length, payload)<br>        // Vue.<span class="hljs-built_in">set</span>(第一参数:传入需要改变的对象, 第二参数:(Number:传入需要发生改变的位置索引 | String: 传入key), 第三参数:(传入更新的数据))<br>    &#125;,<br>    [SUBMEMBERINFO](<span class="hljs-keyword">state</span>) &#123;<br>        Vue.delete(<span class="hljs-keyword">state</span>.students, <span class="hljs-number">1</span>)<br>    &#125;,<br>&#125;,<br></code></pre></td></tr></table></figure><h5 id="mutations-在组件内的使用"><a href="#mutations-在组件内的使用" class="headerlink" title="mutations 在组件内的使用"></a>mutations 在组件内的使用</h5><p>在组件中，需要定义一个函数，在该函数内通过<code>$store.commit(&#39;xxx&#39;, a)</code>注册 store 的 mutations 方法。<br>当存在多个传参时，通过 <code>&#123;&#125;</code> 包裹传值：<code>$store.commit(&#39;xx&#39;,&#123;a:2,b:4&#125;)</code></p><h5 id="39-string-39"><a href="#39-string-39" class="headerlink" title="[&#39;string&#39;]() {}"></a><code>[&#39;string&#39;]() &#123;&#125;</code></h5><p>在 mutations 中定义的函数可以视为两部分：</p><ol><li>type(事件类型)： 即函数名(String类型)</li><li>回调函数：即函数参数 + 函数体</li></ol><p>理解mutations内函数的这两部分后，我们可以讲下 store 中函数的一般规范写法：<br>即用 <code>[ADDFIVECOUNT](state, payload) &#123;...&#125;</code> 代替 <code>addFiveCount(state, payload) &#123;...&#125;</code><br>完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123; ADDCOUNT &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mutations-types&#x27;</span><br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  ...<br>  mutations: &#123;<br>    [ADDCOUNT](state,payload) &#123;<br>      ...<br>    &#125;<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// mutations-types.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ADDCOUNT = <span class="hljs-string">&#x27;addCount&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这么做的<strong>原因</strong>：<br>为防止书写错误引发一系列问题,通常将mutations的事件类型(type)赋给常量，后续调用 mutations 内的方法时,引用常量名而非变量名。 这样做的好处在于,若常量书写错误,可以很直观地从错误提示中找到。<br><strong>重点：</strong><br>在导出这些事件类型常量后,在使用时需要对其进行调用.<br>注: 方法可以写成如下形式:<br><code>[&#39;string-text&#39;]()&#123;...&#125;</code><br>因此,调用这些常量时, 不能直接写 ADDCOUNT() {},而应该写成 <a href>ADDCOUNT</a>{}<br>这也是之前为什么强调 mutations 方法可以分为 1.事件类型 2.回调函数  两个部分.</p><h5 id="从-mutations-理解-Vue-的响应式系统"><a href="#从-mutations-理解-Vue-的响应式系统" class="headerlink" title="从 mutations 理解 Vue 的响应式系统"></a>从 mutations 理解 Vue 的响应式系统</h5><p>本文一开始就提及，Vuex 在创建 state 时，就将所有初始化的值添加到 Vue 的响应式系统中了。在状态管理过程中，若这些初始化的值发生了变化，页面可以实时的做出相应的改变。这便是 Vue 的响应式体现。但是在某些情况下，用错误的方法改变值可能触发不了 Vue 的响应式。</p><p>以对象为例：<br>若在 state 中声明了对象<code>obj = &#123;num:2&#125;</code>，后续对该对象进行添加/删除或更改等操作时，若通过<code>obj.age = 18</code>等类似操作添加属性，Vue 的响应式系统是不会触发的。但是！若初始化的变量是个值 <code>aaa = 1</code>，那么通过<code>aaa = 4</code>是可以被响应式系统监测的！why?</p><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html">Vue 官方文档</a> 解释了这点：<br><strong>检测变化的注意事项：</strong><br>由于 JavaScript 的限制，<strong>Vue 不能检测数组和对象的变化</strong>。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。<br><strong>对于对象</strong><br>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> <span class="hljs-keyword">vm</span> = <span class="hljs-keyword">new</span> Vue(&#123;<br>  dat<span class="hljs-variable">a:</span>&#123;<br>    <span class="hljs-variable">a:1</span><br>  &#125;<br>&#125;)<br>// `<span class="hljs-keyword">vm</span>.<span class="hljs-keyword">a</span>` 是响应式的<br><br><span class="hljs-keyword">vm</span>.<span class="hljs-keyword">b</span> = <span class="hljs-number">2</span><br>// `<span class="hljs-keyword">vm</span>.<span class="hljs-keyword">b</span>` 是非响应式的<br></code></pre></td></tr></table></figure><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Vue.<span class="hljs-keyword">set</span>(vm.someObject, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// 还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名</span><br><span class="hljs-keyword">this</span>.$<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>.someObject,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><strong>对于数组</strong><br>Vue 不能检测以下数组的变动：</p><ol><li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><p>解决方法：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// Vue.set</span><br>Vue.<span class="hljs-keyword">set</span>(vm.items, indexOfItem, <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)<br>vm.$<span class="hljs-keyword">set</span>(vm.items, indexOfItem, <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)<br><br><span class="hljs-comment">// Array.prototype.splice</span><br>vm.items.splice(indexOfItem, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)<br></code></pre></td></tr></table></figure><p>由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值(即要提前声明和初始化变量，不能在Vue实例创建完成后添加)。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">[ADDMEMBERINFO](<span class="hljs-keyword">state</span>, payload) &#123;<br>    // <br>    // 通过类似于 xx = xxx 等后续添加不能添加至响应式系统，因此页面不会更改。<br>    // 需要运用一些 Vue 支持响应式的方法或者 Vue.<span class="hljs-built_in">set</span>()  Vue.delete() 对数据进行更新操作<br><br>    // <span class="hljs-keyword">state</span>.students.push(payload)<br>    Vue.<span class="hljs-built_in">set</span>(<span class="hljs-keyword">state</span>.students, <span class="hljs-keyword">state</span>.students.length, payload)<br>    // Vue.<span class="hljs-built_in">set</span>(第一参数:传入需要改变的对象, 第二参数:(Number:传入需要发生改变的位置索引 | String: 传入key), 第三参数:(传入更新的数据))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4><p>作用：定义”异步操作”<br>属性值： 接收 Object 对象类型，对象内声明异步方法。<br><strong>方法默认传参</strong>：定义方法时默认传入两个参数且只接受这两个参数：<br>在参数中，第一参数为<code>ctx</code>；第二参数为载荷<code>payload</code>，用于接受传递的额外数据。<br>**<code>ctx</code>**: context，意思是上下文，功能同 store 类似。<br>context 与 store 区别主要在<code>modules</code>中:<br>context 针对上下文,若在 modules 中，context 只能调用 modules 内的 state,而不能直接调用 store 的 state<br>context 和 store 都是对象,但在modules中, context 中还包括了 rootState, rootGetters等. 而在store中的 context 则不包括,这就是上下文的体现.</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">actions: &#123;<br>    asyncChangeName(context, payload) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span>=&gt;</span>&#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>                context.commit(<span class="hljs-string">&#x27;changeName&#x27;</span>,payload)<br>            &#125;,<span class="hljs-number">2000</span>)<br>            resolve()<br>        &#125;)<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h5 id="actions-在组件内的使用"><a href="#actions-在组件内的使用" class="headerlink" title="actions 在组件内的使用"></a>actions 在组件内的使用</h5><p><strong>!!! 异步操作包裹在 actions 方法内. 但异步操作中的同步操作放在 mutations 中,通过 <code>context.commit</code> 进行提交. 调用异步操作时,通过 <code>$store.dispatch()</code> 进行注册</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在组件内</span><br>methods: &#123;<br>  <span class="hljs-function"><span class="hljs-title">aaa</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;xxx&#x27;</span>,&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 在store - actions内</span><br>actions: &#123;<br>  <span class="hljs-function"><span class="hljs-title">xxx</span>(<span class="hljs-params">ctx, payload</span>)</span> &#123;<br>    <span class="hljs-comment">//异步操作</span><br>    ctx.commit(<span class="hljs-string">&#x27;yyy&#x27;</span>, res)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 在store - mutations内</span><br>mutations: &#123;<br>  <span class="hljs-function"><span class="hljs-title">yyy</span>(<span class="hljs-params">state,payload</span>)</span> &#123;<br>    <span class="hljs-comment">//接收actions异步操作的返回值，执行同步操作</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="异步操作的Promise包装"><a href="#异步操作的Promise包装" class="headerlink" title="异步操作的Promise包装"></a>异步操作的Promise包装</h5><p>异步操作可以用 Promise 进行包装,进而分离异步代码和后续处理代码，将异步操作封装后返回一个Promise,后续dispatch注册时就会得到Promise对象,进而接收resolve()传递的内部值做后续处理.</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">updateInfo(context, payload) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            context.commit(SUBMEMBERINFO);<br>            resolve(payload);<br>        &#125;, <span class="hljs-number">2000</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h4><p>作用：存放”共享变量预处理操作(相似于计算属性，也以属性方式调用)”<br>属性值： 接收 Object 对象类型。<br><strong>方法默认传参</strong>：定义方法时默认传入两个参数且只接受这两个参数：<br>在参数中，第一参数为<code>state</code>；第二参数为<code>getters</code>，可以通过 getters 调用当前已有的 getters 内部属性。<br>可以发现，在getters中没有payload参数，即我们不可以像mutations和actions一样传递参数。实际上getters作为共享变量的预处理操作，本身也没有接收参数的必要。但若要实现动态预处理变量，我们也可以通过一定的方法实现：<strong>函数封装</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pf">// getters: <br>    getters: &#123;<br>        stuFilter: <span class="hljs-keyword">state</span> =&gt; &#123;<br>            return <span class="hljs-keyword">state</span>.students.filter((value) =&gt; (value.age &gt; <span class="hljs-number">20</span>));<br>        &#125;,<br>        stuNum: (<span class="hljs-keyword">state</span>, getters) =&gt; &#123;<br>            return getters.stuFilter.length;<br>        &#125;,<br>        // 若要动态传入额外数据，则要用函数进行封装。<br>        dymStuFilter: <span class="hljs-keyword">state</span> =&gt; &#123;<br>            return (age) =&gt; &#123;<br>                // 注意此处不需要传入<span class="hljs-keyword">state</span>，因为该箭头函数在 (<span class="hljs-keyword">state</span>)=&gt;&#123;&#125; 的函数作用域内。<br>                return <span class="hljs-keyword">state</span>.students.filter((value) =&gt; (value.age &gt; age))<br>            &#125;<br>        &#125;<br>    &#125;,<br></code></pre></td></tr></table></figure><h5 id="getters-在组件内的使用"><a href="#getters-在组件内的使用" class="headerlink" title="getters 在组件内的使用"></a>getters 在组件内的使用</h5><p>getters 的使用方式同 state 使用类似，通过 <code>$store.getters.xxx</code> 获取暴露出的getter。<br>若 getters 内定义了动态传参，则通过 <code>$store.getters.xxx</code> 得到的是一个函数，我们可以在函数后加入参数，例如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$store.getters.dymStuFilter</span>(<span class="hljs-name">18</span>)&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>其中 <code>$store.getters.dymStuFilter</code> 是 getters 的一般调用方法，此时该值实际为形如 <code>(age)=&gt;&#123;&#125;</code> 的函数，之后根据函数的使用方法 <code>xxx(18)</code>传入参数就可以了。</p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><p>作用：对store进一步进行分离<br>属性值： 接收 Object 对象类型，对象内定义模块属性名和属性值，属性值内部配置项同store一样。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  // modules内<span class="hljs-keyword">state</span>调用方式: <span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.a.xxx<br>  // 解释: modules 中的<span class="hljs-keyword">state</span>在编译后,会以对象的形式添加到 store 的 <span class="hljs-keyword">state</span> 中<br>  <span class="hljs-keyword">state</span>:&#123;&#125;,<br><br>  // modules内mutations调用方式与store内mutations调用方式相同<br>  mutations: &#123;&#125;,<br><br>  // 调用方法同store内的actions<br>  actions: &#123;&#125;,<br><br>  // modules内getters调用方式与store内getters调用方式类似<br>  // modules内getters与store内getters存在的不同在于,<br>  // modules内的getters方法存在第三个参数 rootState, 其可以访问和调用 store 内的 <span class="hljs-keyword">state</span><br>  getters: &#123;&#125;,<br><br>  modules: &#123;&#125;,<br>&#125;<br><br>modules: &#123;<br>  a: moduleA,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Vuex-抽离管理"><a href="#Vuex-抽离管理" class="headerlink" title="Vuex 抽离管理"></a>Vuex 抽离管理</h2><p>至此，我们已经学习了vuex的一些基础。在项目中，光依靠 <code>/store/index.js</code> 存放大量的代码是不易于管理的。我们通常还需要对<code>index.js</code>内的代码做一些抽离。<br>抽离原则：<br>state 抽离到变量保存，仍存放于 index.js 中<br>其余各项按照属性名建立响应的 js 文件存储，同样将主要配置抽离成变量保存。<br>抽离的目录结构如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">store  <span class="hljs-regexp">//</span>vuex文件夹<br>  ├─ actions.js <span class="hljs-regexp">//</span> 管理actions<br>  ├─ getters.js  <span class="hljs-regexp">//</span> 管理getters<br>  ├─ index.js  <span class="hljs-regexp">//</span> vuex入口文件，管理state<br>  ├─ modules  <span class="hljs-regexp">//</span>管理modules<br>  │  └─ moduleA.js<br>  ├─ mutations-types.js  <span class="hljs-regexp">//</span> 存放常量变量名<br>  └─ mutations.js  <span class="hljs-regexp">//</span> 管理mutations<br></code></pre></td></tr></table></figure><h3 id="完整代码-抽离后"><a href="#完整代码-抽离后" class="headerlink" title="完整代码(抽离后)"></a>完整代码(抽离后)</h3><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">import</span> Vue from <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> Vuex from <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><br><span class="hljs-comment">// 抽离的文件记住要导入</span><br><span class="hljs-keyword">import</span> mutations from <span class="hljs-string">&#x27;./mutations&#x27;</span><br><span class="hljs-keyword">import</span> actions from <span class="hljs-string">&#x27;./actions&#x27;</span><br><span class="hljs-keyword">import</span> getters from <span class="hljs-string">&#x27;./getters&#x27;</span><br><span class="hljs-keyword">import</span> moduleA from <span class="hljs-string">&#x27;./modules/moduleA&#x27;</span><br><br>Vue.use(Vuex);<br><br><span class="hljs-comment">// state 单独抽离成变量，放在 index.js 中管理</span><br>const state = &#123;<br>    <span class="hljs-symbol">shareCount:</span> <span class="hljs-number">0</span>,<br>    <span class="hljs-symbol">students:</span> [<br>        &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">18</span> &#125;,<br>        &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">2</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;lisi&#x27;</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">30</span> &#125;,<br>        &#123; <span class="hljs-attr">id:</span> <span class="hljs-number">3</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;wangwu&#x27;</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">22</span> &#125;,<br>    ],<br>&#125;<br><br>const store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>    state,<br>    mutations,<br>    getters,<br>    actions,<br>    <span class="hljs-symbol">modules:</span> &#123;<br>        <span class="hljs-symbol">a:</span> moduleA,<br>    &#125;<br>&#125;);<br><br>export <span class="hljs-keyword">default</span> store;<br><br><br><span class="hljs-comment">// store文件夹通常要进行抽离</span><br><span class="hljs-comment">// 其中 store 的 state 抽离成变量保存在 index.js 中</span><br><span class="hljs-comment">// 其余部分均抽离成文件模块,并通过导出导入简化 index.js</span><br></code></pre></td></tr></table></figure><h4 id="mutations-amp-mutations-types"><a href="#mutations-amp-mutations-types" class="headerlink" title="mutations &amp; mutations-types"></a>mutations &amp; mutations-types</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ADDCOUNT = <span class="hljs-string">&#x27;addCount&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SUBCOUNT = <span class="hljs-string">&#x27;subCount&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ADDFIVECOUNT = <span class="hljs-string">&#x27;addFiveCount&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ADDMEMBERINFO = <span class="hljs-string">&#x27;addMemberInfo&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SUBMEMBERINFO = <span class="hljs-string">&#x27;subMemberInfo&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pf">import Vue <span class="hljs-keyword">from</span> &#x27;vue&#x27;<br>import &#123; ADDCOUNT, SUBCOUNT, ADDFIVECOUNT, ADDMEMBERINFO, SUBMEMBERINFO &#125; <span class="hljs-keyword">from</span> &#x27;./mutations-types&#x27;<br><br><br>export <span class="hljs-keyword">default</span> &#123;<br>    [ADDCOUNT](<span class="hljs-keyword">state</span>) &#123;<br>        <span class="hljs-keyword">state</span>.shareCount++;<br>    &#125;,<br>    [SUBCOUNT](<span class="hljs-keyword">state</span>) &#123;<br>        <span class="hljs-keyword">state</span>.shareCount--;<br>    &#125;,<br>    [ADDFIVECOUNT](<span class="hljs-keyword">state</span>, payload) &#123;<br>        <span class="hljs-keyword">state</span>.shareCount += payload<br>    &#125;,<br>    [ADDMEMBERINFO](<span class="hljs-keyword">state</span>, payload) &#123;<br>        Vue.<span class="hljs-built_in">set</span>(<span class="hljs-keyword">state</span>.students, <span class="hljs-keyword">state</span>.students.length, payload)<br>    &#125;,<br>    [SUBMEMBERINFO](<span class="hljs-keyword">state</span>) &#123;<br>        Vue.delete(<span class="hljs-keyword">state</span>.students, <span class="hljs-number">1</span>)<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="actions-1"><a href="#actions-1" class="headerlink" title="actions"></a>actions</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> &#123;SUBMEMBERINFO&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mutations-types&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    updateInfo(context, payload) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                context.commit(SUBMEMBERINFO);<br>                resolve(payload);<br>            &#125;, <span class="hljs-number">2000</span>)<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="modules-1"><a href="#modules-1" class="headerlink" title="modules"></a>modules</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pf">import Vue <span class="hljs-keyword">from</span> &#x27;vue&#x27;<br><br>export <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-keyword">state</span>: &#123;<br>        name: &#x27;jim&#x27;<br>    &#125;,<br>    mutations: &#123;<br>        changeName(<span class="hljs-keyword">state</span>,payload) &#123;<br>            Vue.<span class="hljs-built_in">set</span>(<span class="hljs-keyword">state</span>, &#x27;name&#x27;, payload)<br>        &#125;<br>    &#125;,<br>    getters: &#123;<br>        fullName(<span class="hljs-keyword">state</span>) &#123;<br>            return lastName =&gt; <span class="hljs-keyword">state</span>.name + lastName;<br>        &#125;,<br>        fullName2(<span class="hljs-keyword">state</span>,getters,rootState) &#123;<br>            return lastName =&gt; getters.fullName(lastName) + rootState.shareCount<br>        &#125;<br>    &#125;,<br>    actions: &#123;<br>        asyncChangeName(context, payload) &#123;<br>            return new Promise((resolve)=&gt;&#123;<br>                <span class="hljs-built_in">set</span>Timeout(()=&gt;&#123;<br>                    context.commit(&#x27;changeName&#x27;,payload)<br>                &#125;,<span class="hljs-number">2000</span>)<br>                resolve()<br>            &#125;)<br>        &#125;<br>    &#125;,<br>    modules: &#123;&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getters-1"><a href="#getters-1" class="headerlink" title="getters"></a>getters</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pf">export <span class="hljs-keyword">default</span> &#123;<br>    stuFilter: <span class="hljs-keyword">state</span> =&gt; &#123;<br>        return <span class="hljs-keyword">state</span>.students.filter((value) =&gt; (value.age &gt; <span class="hljs-number">20</span>));<br>    &#125;,<br>    stuNum: (<span class="hljs-keyword">state</span>, getters) =&gt; &#123;<br>        return getters.stuFilter.length;<br>    &#125;,<br>    dymStuFilter: <span class="hljs-keyword">state</span> =&gt; &#123;<br>        return (age) =&gt; &#123;<br>            return <span class="hljs-keyword">state</span>.students.filter((value) =&gt; (value.age &gt; age))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>vuex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github快速访问</title>
    <link href="/2021/03/14/github%E5%8A%A0%E9%80%9F%E6%8F%92%E4%BB%B6/"/>
    <url>/2021/03/14/github%E5%8A%A0%E9%80%9F%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 试试笔者的生日？" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a1da53eb599493872ecd1d265241d8f6de4dba60a500cb9346494d883757c1d1">bda6ad0d5f606e7055c23f770369041fc566bf063be9d0864f3ead6d04288c1b00cb2417140c65d130534ca65582eee0b1201c1c69e51008bb935c96208dea06067c461841d8db1a66ec30d3ef01ceab6e189f3811ffc9102e848efd61e71b5e6b9da11d9abcf79e7c25a42b476714aa3e03f0993ccc427830c3e9567c57eb57eee097c6af0c903b1cd8a21ec00c4658fc5d50eec27c0f556f31656fc9fb2174baca141877ef4a9efcf68a222baaccc12993ac8208312801d78d657a224d3e6cb61a7a8a60bdc60dabe975ee26b09534b288d1d298dd1797252d8c00e6edcd0c357272e4f67e7ef7c27c0ebe4e5cad0e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github链接本地与远程仓库</title>
    <link href="/2021/03/14/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2021/03/14/%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 试试笔者的生日？" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f554b4bddbc413a2b4bd27eba2615880f61856a8f8819b2c1d1d50e31f90ddb3">bda6ad0d5f606e7055c23f770369041fc566bf063be9d0864f3ead6d04288c1ba42ce149d4d43abe88c7d07a07df3082b3c9f1848241aad16d61f1ab8cc94760be5b7654c10e5b2ec1d37665316a5a75787cad714dbe8381112aa94677c652f9096d42b4750797cb3f4e7e97dfe22b0016ebb9d04a2db2fbb3262e1f5455429810ae228667fb522964ff23d264fb681fa2c3fd7815a712d3424d556e7635806e2c123bdcd11f5231300f4eedc6df40337a0d7f0504255aeaa0feaecd1fca6a7cedf0aa788a66ed0835ccec95b05b4b356b0a562508ab81fd7f56da702af0809324b5257ca294dbd542d900146f5952cdebf059ebcb57fcecd1db0012c43fdf5f9a9ade76ed3e1b7187ea4129070977ac10dd19b8a831f6552bd11cddbf98d2780e85932c84062ce2b36af4cdee29d7cd4a069127b7460a0796a71375951ebc28cc2044aa32b39991b37ee98da5aebfd6ba2a24bc947f357bc41d88d28b4abe7db04aabe54cdb5adff7ce2c8fc424e8fe9e6cba01bf2708681d8989d3d56c8ba3431b708240bc650a748966ad539ab6654dd728eb6f11fbd9f78355fa7491e6f12c2187454494e65b443835c4b2236b951a9f705f1b4cbe51d841302a103c28b885eb0fe53bb75717a2f236ae248f5f6b2a96eafe3b0a757ac2d7831ec79e7ac8a16c846082c3e65d4347aef7f9771a0cf16685a3c805a5ee520b6cb1901f3dc298afe5ea37d6d3cdcf47fd588222c9ba877d861c964591944949924f0e95c6df0c9cc2468e16d5858355371b468170689780e1728184aaf7fa0b8d428c2ac5006e5023f21b3b0dba2db368067dad4b16ddd71873df2032f66df262113df5b72ddc07eb7fcc3e901f3940b4d75a3bf213bfe9f8603e6a610df8b5512b22a08f88c629cf9f05dfd4f88edc72ca26bbaf599f89f1b18f8ffc219bf24a5a2c8515ea26cc078db3d324c380eea9455c157769754c4f52f6b4e0fee98ae555bcc75e65eea45c7ab7bbce7b6d3e0ed417e786d6923b871978e084e1d62d108e1bf4001abb1919bed4175a6ebbd93f4e85d728b85bf5cdbe443fe7a528b06353c9917d9e858a5fa0fc5d49d48427bfd29634bcea9801644cb3f3d6da6c19ca6640e13d3a2ea1084a206fbd53dcc9b0188525833f9b5ae26381df3dfa7c9662d8a4addbfd708eb91859bfe78fba758d7e0eb13d0f43a9d206a0721084dd8165e29f44aa04259df05e1fa7ddbfd6c705afa2c7959c2384e2bface50f2fc02789e644963dcd82ea07992498c4767b6c0bc895257be9cb11fc5a3e310e1dbafc6a1a8853bd5043e39100fb366c6b8707bf8cb8ea62453739793761c76b71878a1ee5643a040bdd6443b225aafc1322cd295a971193ac10d4de6871f2e07d42eb7b7449595ac088227ab4dc917f4fa2916ad96edcf3832dced496eabd53d3c976f08d781671eb43b5f25cf3144902cacbe5a86b7ebadd35670cf2d62497079a14c0e9c601cab75d15fa9e77aa8b96fd3de2c98ff1f2da96a17e36e721e6a236610f32df903196df5d326b46a1d5fe9eed2746ed646c67dca6897d7964eb54b18f4b54e49ce45531975fcd2d96046f7ed5e3ec39e527287a8a688222c886f62fc03cff8ef82b191158bc0b40505730b6f70c75caf38ec665007acd30e5ea105726bf41638ce26ecce3427937e710d58832cb5d6d46c4fed468a4ab86b75ea965a40d8c78498a357d5caca3f155c5cac6e394199ba1ce9a08666bfbb8585eb7d6873c139348c4c4e4cbb8596a6b268a2d918c1b923a4e3d1574d0b9e8b115e7a1de1442f50315a5700cc10e059e39f44a3903fb792cc54d8787f60b74b182497052f95cd42aa161aa53ca524be8f39a6efbc8e4fffc9096a9de0bc0b4744af974da494caa047455f120daede0128456376dcfe37eb9bc84db80b379b71741d9b75b869f2b2c8626a48eed0d72dae69a3f757f68e9f35a550a234769b43e22c6e9714a836fef1140d063db637597d23c9459519027d59e95762e96f67c066623312558dc578a021a2566a0dbd3354d6968a2a70c13c870635af8d1700d9a0fbfbba3c0a72c94be7317655754327a0be48ea04d1e0e99ff220fa70ba417094c89aca40f59c69bd307785d187286ccb877e15aff51bcc187f5beee64de5313d510130c2094627fc5ab066977a599f7b1976e47cf3024b24610e29e1f1631bd3c8242c285304cb7cec3c3f547660fd2bcf5686ddfde9715ec85dcf04e12f4515930ecaf01692553bb26b31c4036607ec19db0191fc92457d05c1e3a8d88ac110d642d7088a7138924e1e8774bf2214df0ed0c0c309b4eb9f9415dff7a10d830640927021611f6af30da2566377b7f361df81a76f6102e939246841a516bd29270ff20fecadd59df4ac5a22f0a276bf478dad9a2cd77c4ada8c1f3e2127742180433f35f5952cfe70580850462b532684c58f232e7ed5a5e650a8b7640c2115922b696511c3b73c2b7025fc8f0ed3c696eb7e1b49b97731dd2c9ec1cc9b676a370d195f21a76a48483908881509ca0a99849328b47b8f602e6f6a482eb67e9b960c435e20a61f930043ab365320054957f6dd4b1695e05025340252a2de8119452918beadd94e0c3596173066cc792fb42a88ea839489cc0b885f6c3173357ab4ff6de5fa6dcdae0e70c123aeb7a7f65244df5343d5ded98ef877d20f3058696d6f9e1f33d8eac24e21cf8cd63c668493f6c9f02b7baf673510c3153b7b163ff05c5b0c416b67d793ef5d26226c725c981af4f94504f35aef8fa2ccde3d4e57930296107758651a428283821887a2914c541b5749c6a39e5472559d8c7e78bff2c92f886e02467c811214ea7edc5d8846c85f5fc9a1aad5451aa9d804de8e633bab5b2734b2d9c422e417f373e420bf58bca6f728ee8f8b691679245d4e4b5de38c3190271f3c518753f34f1c4cfdd0a10e6f144b429e30413c049399c8babefb0285663f0de9279294e7d552e9ae382981eac64e8bf7e14712d6adf4618734573a4e59a2261877667b02f9bb6c54b22de4524282beb1044f42eacd58c31093f9bf140295557af36fe22e84dabe81a3514ab3b19e7a4d6ed0e630a61fbb690f13fc1b10bee6ce409f4f011898a9c319faafbfe4cb76929bc982a410a72c3a7c3c1ee72a1e0f3ca66a20b26ef1e9af5ad5315412810d89d413c0b789a5bdbc28d6b6eca56012c88b97d4fff3cafe4ca5a418c7de9259a4f3c750e1b7f119133637af7370221501329ec37a997961d153baec335b2c29e01aff3a6c3770b852428ac0966d738170b1910bde09f36808a1ea9b6b8be8f5c25434785439937cc7ace350b740c70682195f38e12eeb80c268347f5b4873cb357dd6c97a905ed61540c3e9fb4621ad50708506a41d76a0be44660a94a2fcdccfc46493d1f2f48cdc2bf88a74d61293849b205339123f100a1a5f3741413317fe5cf865a88311d95ef956c8055f4889f0cbfd3f05328f2bcbbaeb7ee84770f3366ea2721c3c77f7ecd3ec373b8a53b80e6e856aa1309c322a485d91554076149f0835cf2102328470d518a13aaafeb6fc38e84cf0aebc6b500e20ece643c84a1738060ea0de2d9e7b9d405b6029b4dbd860d82570b980136d3139cd6c2c707792c011e7eb272f2e635826794369834ec2b5b9bd05106bda0e8a786afbed995ad77cd8754f7d14475c11d187e5cefaad27ac79a0895a8e22dc83860b50f7a567159e47b9772a67161404783f77ccdf5ac48211e0f23eb6b38514999feadc76487483aeaa1b2c8f98b1fc1c8c51e9a3942b90308ed1390b00f1bd546cbc8b86c96f77c9a7d45706f7ab92692777e17b97cf506f7aca131e5906fb684d46e0b3eede53d38a3804db14f27a615bb305eea27c859bdaddba5aaf7768c4b9b6ed1ff96c55799133ad5ad5711f5b4f26449348860a46cb7a63f40f17c469b3603ffe01ae28756094b5a0f4e2aa47bea359d2b6f2d54312655fb2bcc772e39e33739c7bd798844250d6a9a092c7f7dcbb079f5a9098ec7aca85b8e9668d50514b7d98664af2de1d904233e23cf2707c6dfdb188b766bbc046290c50ae49de8fe7ed47d850070d00bfd1311929ed44e16bc7d2e4f26c2a98ca5342224a763848986169ee95508a9167db3b7f5ba0d531f5022d17defe551b47324fb92296f3a8cc54e76459fa807326eee4fc83b80eea21115bf3aa40fddfbc9c0294af905f36fee6dc65312355e7c7eac316eb22740032494408051de50d935a7d57d54f093d87637efb16c7c7fefc0a84888756c0ff66cfbadf9088aa8e6bf247a7fdca3089975c66616a654a357e83208443c1742ae8c25b441c3f0f12fcaeef3e5547c71ea35516cc958355de90fb57d36f451bb19f0b42293487cde5242ceca1a78c8a9633b4eedadc25eb7c5994ae4cdc9679f1bb846d952dd9b88dffcb0a1671379ab5d4790d7aea721e00c66bf47a7085cb8464a3672ae2417da9bdb4c374768ff92b8e8999917f1fbc72dc9d9eaa887bc4f400d1ece4f8c31f61c79de5fb6a285ab89609c30a45304f560c601e2663112cd57dfad48b0f849c75026c4a2511141b36dca5e5fe9af07f91f5efb0017f010fa348814030bef27420d7f16dcc90f0629faacb7e80cb7e3abb3fcb6d1feed3b2b711585dd67129ad38ce07f9d10fd4f82e765bb06af0164dc68e643d1eed8c5254e557085bb23657949fe1d51e436db3d442922dd1718366cd1fd029947361b84a499b3b9467f2d239760c990ac74d82c4a59072a251d03ce5d0fb64d7b31a0c894c3bbbb96849c357f5af62080ecbe6c87274b6096714efcc35c5c11dc59a677ba1cec1483df395d20706ff42e3b9b88fe583748eb1430eb52cad7f486ac5d7e41991135c85548eac0d84e423839846c1915aed37b731254cd519d6c112300075b224698a431e552de47fd44762c9d31e7314d5f11e990853aa6bfb921d27642d5131dc51096d39cb389e040074c16cd0370869e44d878682d5d46627499bf5eff9e394b735d320b05d5b8e49ac7941cc14c496edb6794afe3d3667c05bcaf604496b17fd0dd8354195748ca0b588dcf2be91fcacd78aea24414bfba75d444a7ec8634fcfc40c6d7979cc25aaeee777ec1ba085fae0219fa2677daedb1290412e066e0246a3ed402adfb594c93a9aeeef6f18cd4c9e4c59f25212d836709c754b1686cf63875455ffd3a1f78525b93d5c0ed024908820a1fa7a9e413f19bb214dcf3837f0adc18dc11e5e7b9addf6d008a9f7bbde573aad4d588a2891f0798aa1b06a3b120aa6a81cca1ad4e5a3e55ce5c32c0873a15b76196c2de64c8858f30a6dcfd3e2b7559fb0d7a127007ac55979235956ce0cd9cb4c19f514d1734b1d297a82172b5ad59e3668b8d7459ed552f73b8fb88c3aedb684424e7717c720f317e17c3ee3b871564bbc33baf478d4f1c6396d9bdbeaf8aa73da2181b4cc8d4985dce6257ac23ebfe6a73e1376a05e85b2654f95b77cb028acbb72b762007eba0e2ac8f4ac8de7341f69d93cbabddc8430427822a1648cb69c16a193eeae70adfec5db4b8e50046077f3163d52ce583c351345680791c42fa4a2ee7b8886fc6a52701ba8d182d11273a1f71cad89f6f22df8e49945385edb430c2ad3ab05c2e1a77f88a7848f36a8aa8980690919ab503006fc15c0c87a2c0395f09df0da16c967f8fa2fe9afa5bb6ae9251fc01bf506a5b8e6505f00452107d3fe6b75cd99904b8861a485fc765b02534dac8dac19c4dad8d4e1ace25f4bd57c245b480953a1cfec2ea8c0ea64dd234de219f5e67a2df4f55e14047e0e0760ce19a5807d6a4a2c1081e575ef396f4548f281b3cd3ab0b094d48d0413167e727da98f34bd02841146d25548a60467374786c0124f85341ce971b5b2e240239c2adf1c561758a4e1a5b35fecacd57f93987d30cc0d502bf4b0f1670198113b565193b6923e7691b45493c369d7f0f16f4d1bbb81d3542437c06e5807684b8fe8d25253d83f3a943a7c8ad31fd8375c0a86e8c31152d5ebd09e460d385a71d60ecc55523e2d6349351ff4b122b5e799100796e278cfc303b668335b6e9fc0fdc39f3139b5b2cfef239925519a3c8551ae2f01f34d34ed7e958558be39bda9797ce0ce3eee48c06bfe4f44b62b1faad1d923c79ad881f5edc2e1cdfb7308f853954945b91b633b8aac4d2955486569ea4920ab296789716a3da5dad4e41d85e8095224757bfc56dee1b5f14aa1efb57e053740cad286cd7191fedd3cb8c965cf0fd1e66045c1497910c5a9cd1676154fbf5a7e50de85c4571a6f9d9df087be2231fd04313f16a2fa1949e114c24bd60d547bc8585f49dc2f09870237022452f87766e7793020556dcb442265a2b2a4e7caf7bbc197ade03904e6d2856a0e64d28d22f9cd9e1900ef8de0f698c17644e450a9a728990e27c38011f12be1da97623be1f023e8fcbec32f3ccac67f171467ae433f85d2d1c639de4df3cf97eb57245d449de97d0a16c4ff8d6c091f3d979ec2ddf38665c6ed84d1133d6ea78a419df25ad5ad2b8091f83cfffb4ba58c786427b0349be2dac5550d63c74688ce67b4a9357e82af343414b58aa40e387d9edd1ba9e50ccdb9990c96ac4a8faf7eaf41cff44de3b6d0ec41c04a89c1f07c48eec4773f9789db4c009a5d6dffdd6ff205fd3b50e8d6a06b3f24d58f3d62723ab3279087afd0eeaf992ccffafc9665d114bf21635290a0206a2374d0c7d2f3593c8ab54c72751e6a6f421e7e36092f08c3f3bdb73bc36afd06684ec4d8779e7089c08a681a5add590bdc7e8bf34e9842cf491c2cdd79cdcd1837d7d06f4b971927300cfe2a663bc51eeb7a84856b2ebcdfd70b14b4c56cd63aea0d2a7b274c1442fd89b10381e7e169f564b0869b49f8ca367764026f756292c1949bba173dd9510c72277db7d0e8a3e8327e7749a882c9b40515dbc85cd43e0e350ddcf7577bb3d3978be144e24150711f60649fbc673a7120d0e62619e7d09b751c72b1772f9b54704fbb4a041cdba242baceee05a43a82edcfbb61a960cd79a9635df8008459d474537cf25f93d0068a6721e4eb037844221d883d389865962752c6b1127eae708879b4d2f4fc599e4ae3c1b20b2fbe6d24a56a5946a8fa83efcf926e4459bb1a5fb837bbef57038cb6e9bfc32c7e9f3a79dc871481f543f744e3ef96935a1b1cff42d5758723f575dfc6b4642eb08fad3b638fa7f057574237126874c478bb02f885a1d71b527d97c7169e738ff826226b9ee541bb97266079493526e4f576160f8e01def59266e55d20ded405127665a22c65f428cce5d6b98f137c2e09067ab3f04b37ad8bc8cc20f63b9f38a67a86a16be98b38623d8d7c1bebbf885cc5e34a47891783934f66a8cbe2ceeaceb8c1f2f75b2f6f80da249821a62a0d2049a370981e84b9ff9332288c25b55dba1e17b6bf0f4b450e45b31867d42e5792b75b621d54cc76141bb7c7469aa4910489971bbbd3c37aef0234d2f9017ed732ecd7e18f28d03e048ecfd2190b436a87421303eece6da0046dcc800a78b59a5140d61252b03a8e07161784f2c31196ff2b119463fcb008aa69e786b8a2a65e867513563696220cf4d72c05c768a25652bdbca219e2598cd358c647a7eb9fd4484a28b9865ada1edc09291f54e3d6bd604b6bf60ede83a39b835c9ad93d82a745b1df75201949157a7b7e1f2bae2a4368521c78cddbec133e5afdd79a3c915a2fa4b2079c25e4968743921ebf6c486734b1384ef619f6fa4290b07e7459dd6198344a6ffe621aef81e1ce727e0a1d049e0343c1970b074124d3776e41c652ba09a56600de0d161190792cc24b989e1f3ec3859e05b6c50aaa9b508fcb8e3a3ab125cf2fecf721c55d232a1d483d95bf796ef50a9eef959aec7c27986e0caf19c5324db4a69bee178fb586a596a3d576b6005dd5e5214d58f11a9c149a579136e81ed27f5633f96321e33ffa32bf49c0b6e460c6f9959b63c0615c5bb230ba849cec82de1c78457ba94f1c7f167daec8e5085e611721f3a36153a3d79b423e2b2ab63e41d9bda8b3003a9efccb10ac4308493853a4ad3553469809af9e859724046dd01158aa83219bf9e361f62f67bd5c6ba2e12de8482950d617eb633d8f96c528f5c3f47da13168e0c2222d18d3dfda1682ae1d4bac214f0aac4c627395a3891c1e0786b8c4c146ea5f18ecdb9f3173f6de49f999545f9f3c782f35fb65a2c2b8f4a98dd2ec929e53a50af97797f0565e93de2b9a7286933b3fdcf2389c291ae4156575eba351ccff627480696fa7a7c81909d06453a442275bdd5a0d3a6c95bf927660a265a8b0d0adb416011db45fb04187e27b61b71fd4c2f892cecd047cba263e048d7dc8ddefcea0de9b0c6534a2e13d62061e32c1d40316147bce2d8d1cb21ef5687609ae9219c91b9c825bbf1d5d3a2332568e2689fc69e6df4c72045c547579ceeba4ca725cb3d97e92dec2210bd9d603b1a2ac0d277269cc7aedd4ec474918d537595a89e3183eea7f86719b38bd1e9764a4bb25ccbd05443b38a5a136c9f8b5ca5b16654a396fe67264648092b8e41d31e7750c1e0aa514d243c2c7493297dbd6624be096dc5a430f5bfa65988e4a0b84142ecbcdc5ba1824e0edfc754b9ca715a837304b29b43511ca1b0862b4565c9e6e49cc0d7d7918487b5a7a4f0113319ac0b98f629f0c007417cd4b3d10a4800f169163736cdc249fa23be74d57e91e53615d68f1f59b7de7daeb8651103aabaefabf0955c7b89e1827fc55f384007570dd702b8a5ee803c49253573f6216182d9bc7e92c415e624792be8a7dcb888d5a0a30fc1c8efdfb7e8c37ad4b73fd131cada6e64a9413d9c8f88cd47e1a6503a46409b259bdcb57c14f170837ec5300d89dffc7f79c2758d3f944f56e7ec1d2aab939d6a2c79454ef85440d28bd9dfad4cc03444701be60688db54dfbf641124437f2a62b290bd145653ba9d2ab45231d6d478f3fe28a9a0a55a0a6d5b0f011d943c6f931bb8d64aad8603cecbefe0d6a11375bf531f87760a172d5bb4ca8aff341269f912c1505c0d8532f1525ef5b3c3a747f951e7b80d73e2aec6ecd0578165c00c1dce644bb44a9c765427da18c72a37e1f3305aca8da0ae540acde49ed1ccae85ff346f4ae12c9c23bfa35f5332f0a967558090daa2a9ed506da74f3b01eec685e15cf72a44c8eaab07bef4b4b4f0cb546ca386f005c7c8abcb0b49a184cefef3139f8c6794d8c2fe00d4eab9b0f9780e4643e988b827205203cf1bc6d88b8cd9accfc000df3f49f190d79c17cef0c256d82602219be3d1b9ce7ad408ee00cf4d309cd53b4cebf8c62823a855b4a44659986ee3b491b27f3ffc07942bf069b4e88437a786e2a877f621589c3091298f07db5f6331eb95ff21491130628adc8c846f46af5c72da65592d8164123361ab0806869e90fb8093822efe850b6e6ad318d32d1672f86219f1374b227565518b2f2bf49d8b8660659fd57ba912e27e4e6cfe2838813718bb3a66ea8471a3130295ad1feeee196b86112c3cb25519036604cc17cffda72101cc28ba15d95a8d5c979dc268961e02a83049b6b289b638841a7e5f094d5fa8756290cd2c195adae189e40970ac42b51af17b1b28e3b7a414ddb2655bbbe4b87896cd4f68fdc6c0d98e3d42c05528f624f198b4abad9b3fceb617f34ece9425b73ecab69bfc29dea8c1f661131ca6a28d2249b76781e3eb58ee5fc361d8b18006a39acca45aae0d01d233815b851607fbf6e2afb986d0ef3628e0b02c2cf43f2abf449e97d51a5deb393bad549967f4222a1d2942d26f0b0fb852589c1f5caa8a53ad645589082bc4ea09ec000e9e69424444da42bd046366c3e4e162d1a99193b2c02e57f6aea47de049b24cb94ecc93179f3f6efe0ed549f5a66c8cc89d0069558219a638149718f144db3a4859c693e790fdcd9dabe5b76591c4209c2c3f3f5478bd510fd533562ba5145d86bba3fa93a95d4696b2b4c8e6f4a8868a00f3faf67b899a091aae9a08e43f96fa7e4fca0486b2a2b64ed29cc429f350c03d03e6d1207d7a40d7131704b6760f608704f296153dfa09c3670b3e0ad8b8039a1143a7d79040f2de0dc922603a8cbaf923c46907d6f8c9c69cbb4c9bbebbbf5f56e8726d99e6781790d8884daabe01dcf00388ee51193763ed53616d4d1d5949cc7d936b99b74ccf424ee7f6400472f59b924cb8616a46e21f6d3bd279e2a7e330cdb830431f9dd0e8f4464c95ebf58839b3489f7c2656c28f1813937b20076be50bef1aeebd8eaee50e4dfeadf374dad68136f905f1ebc0ab3b94b710075317d1e15bd33ed6061345583a18af9b497f0dae99f0575d6c90790ebe4b931f419877ecfedca71a35235de16eefa02efbe4596f87f00f8a196dede31867c0d10e3821c6fae789a82bf89c2083ca9f23fe2e6bc7b3da0eb847f573aa84d3faf0035b1a65815359948c8c59670d9a97a93a1e7afa6019d521b025bc2491dfc5b362fea66548eca4a719b95fcfc2cac14cb2d1f4d2373421f3c6cc7ab339dc7f9a6a3982075e4b4a0d3669c315ff353a988f94f794441760b35a88e726ebb883d37af077f8da4769f7eec7d54f00e6098b1c5a5bcaad71b1c86b88e7accdd6aedada027e7912601b444f4bf728ecf40d478936c7dcff7deba6819dd065b2bef410d974213b6532d6cc9981ae8ca48a63fc59105df1f10a12014f2e96aec882f378f8889b908065a778c5a3f2ed7072016bc825b43ce09ab046ac6f492185f27a7f304f4d1ad03f3e1b6b563d616960fc8559de0762ccedc096f0051ef3f46257fb7911906097a019b0b3ce737899b05153f35bd4e9cd7573b02aa9f6a973c64a9330731a1ca41052a8a2bae087eb92a08d82882c44fcaf773de250dc0998459e3e232ce358636f28d57884f329d4ed3dcab007812f8fe5c9fb7c578743dc3c355071b5c0677f1eaf8a6554e7a7b7ba13f615c5d48e85e973ffb35f11aa2726a93c783c436075bbe763526c8cfba2b54b860eff95981af86fe768165143e366fae7546881717c41d4c9c18c3cd597e79f69a9a537dcbc8de9afcdd1b3a9e390f14026fd39e7e2a7421fb6b54a19ad46b141c04a71485417d9aa725662792b03a40eff7f1c5e0c5d0f70e5d6e93b7eef698130535e3d24d5aba57a3c3094ba840ba1aa02cf301e377da47f3190cdca5304590693a9a39147232b4671b906502d805d15d5751b9475606c5f5ce1b3aa54da04eb90a5999d1193e1706602d6dcf0a0c64d3ff3834a1c7babd5bcec3a9da4ee1c78b86e2e2545943a85368f847e04f16e6b6488e350d08633dacbb83ab321f3d6aab7786974bea5fd2f473699ddacabe4e22c4c3c81f78007072adda507747b8d7ec43fccd0e55e2cdf7504d68a6f36f051efb3cc55e25ef30cb1e8435ea3b6d97efaf315876098ee90b72a938c3e9fea6f1ba83a86ee8fb8699751c83fe5d0da14ed75c893a58415e5e50ac0cefeb2a0f4e989473ebc1eee5bee9cfe488680cac75e1876224f3c1fe9ed009bf6d15f166319523f0bd3dcdfc544f1e6b760bb7340c1f6674a1a626e6c654264a8315593ecd4374b819c9ed3b9344932efb690ce4620d488e04aa442c663ecd610067656a5199827019a773bac4fd102e956fe39e133c0f7fc472b40a98b309f493b3ae11fb0037a18823a2b61767f59a64e0678e8a6a1fdcdda0ec155b44386877478f369a4a654788bfd852a4a4069ed4c3f478b2fb50bae9193807d9e6e635a8bf704d8e068178c378e9dfd8e0ff684b40ee5dd22cb4adb61f6b6ed7d6c4dc1c80c6022331950d0ae357a168a171155e08288733b0c293ba8667e359000622c1256b0fbb5c14827092683b7aab0955370a2a68769e40353365d28798a01b55ca11b49023c64b2cd2305aff90a5f489583105404ba631d09bc155b8296a5c822e151b02c2f6cbf932a71ebf42e5a0dd17e8e2bded263002f6772427439deddda4695c623a1a35f8179ecc30edf677739a6964c062e515c4cbb5f076283b13234bee51463251ad78cebbc9afef5ed3ce24e4c770ce51f989b08fe72dbd8c83e528df847870baf70bcd0c6d6323f7a52d517a62a5c4e22ffdccad93e00a35316bc0c115ae6ce7e3eac09086cbe50c4a05115f20e3994ad6c22f9086b8ad22d4bdeb009d619034976c7d2300bc4b98b42078f6c45f889d3adc5c143b234aa9e2afaca81e00865bfa627d1ca59eb2698cdd9b0eddd4a398b32bd33a9a4a52c32a65b284a4be297d0ac9178757766b956c4a4807e0255e5403c1f9e054edd7b5389f568cd6dd8aadbaf0378f108f39ded64219ebc75953bff08a6e4689f5ecba53804165d77a4f6d0fa01ed3febd27c73b466a5b1f380a6d63fd6eb480ee3bd622aa85fa4066ec8677cd706e152e5e06dc3068fc94d39db9df5f026b67ed0a1e41a086abc3ce09fa655a91a46161f7aa895af671ae11d99fd0c66869460bf38281103db35110769891d6a456ba28394d3063bb1d8041d9b3f7abe48e0ad37193d6463f59af55225065981158df501057cf1c87b4e530c57f4aeb8d3f4ac1f1db1001c3dae2f11bda6f5ea522381cee95adc71508d4868049620bab0f8357470b239d239413dc12b3676276b14d7123bf1752288dbfde49ff6fd4127ad4c78c4859d7476a265e468b05664300ceeb250b4a197ad629f6442ab28740750a41b4df081cd2b065f0abdffe60b69b73ce5ca559e770050759bb5dc9882222a7b4c9a0deba31688b72686f8951d49be1249ddff89dc5b6576a5ea6b6238a89f286bcd4cb337ee2bf8f6ef75779098a84a50735844fb5efc8df84eab4c34bc7cd03a52d1ac4dae7e6de58747c742b2ac037404c8998109eaf86b87f96ea41b2a82fe05c0d3ab768a883e0e6085b07c8dcd2770f83477f198855cbb338bbaacd0b2249b5d3d24e79e48a11b209478fe21c7915765f23f8aefb06e5f99a82b6fef21a2e82cd26043ec205bc0c83a72ed50ffc9ecefee29159aa7d7e7f82032fa2701d226aed19dd3a1c5aadf64db064d5bce1b53271a2dbb2c4df1aaad684551c0d7ba999ee917a4f549423f0c6cba46764ccfb5646ef1d3793d9275191afb153472323f4d8326ccb20164083cb119e547f5607897c28b961ca01e15b1f61022e3eaa56d89724109ecf58953661948925a4e12b32726c1353a64ff6b20a0da718632ebbb61d2cb637bb1fe000ac93edf4a08b198347bcbb96b6d154846224ee0f3ff5cd4bcec87f7498a61728d32e6f9a323abc84e9eb2d3a060649b11a3908ce7543a4c89e1088f90dcbdf3143dc3731466bcc8a422f88549a07aaa840b016763439847c86335b49ea686cb98f4ff2b1a17c6c468be086f8550b7ca5f972b2595427755e214aed54b0fe59d95189fa74cdb20e6f4baec2b76a4aa5d88bf6d72c2072e65c4a218abb0bc02af94c686d9a1033494fb304f09ec3ce3385249aa2c3d13881626c347d99a4473ee9ea86afde7d51c71d07eac874826e062563f0e32a68290a786c123d27da782b4dfaba6b3d8b075a823c61f31b08355aee4ab239a9bf04915327afd3fbfd5e1ba83df0326721f8d06ecb2feae8f92a86751f23ae3430e6a321d727bb03c779311e3f34133e7f674aa52ae968168feb7cf004f6fe48023ea71512d9145494dfbb51b490f251c3a3dde36a330d138a5c7016c184a5d4935f3f322179106943c00d17366270d0327fcb53a05c49c0b5bf62cd16352a616d32efbefe762525992348c82e46751c203f0a664903c09064fb814d45fdb5a049a395ef3307addce74a662ed35054268c2043c1bf9267e4b9109d833d0ba37cf35108d50ed98cf18a66e727b945fb7ea5b3bd6efcbb8f5cae340f5f9ab54d46e0c3aad8d3d52cf991b8aad324f3b2938d2da94d7162d42986e1ffc943953869d8adf2992af2537a5f8053029921ed32e0dfbad483c5d0bcf3555f070f1339a065f0e60a90f6c279ccdc57ee0ef8fcf1d96be96e7015015ca309b66e510bee627e7874156fe7bc1e918251b65b091ee5b9b6c3d7f55cb5fc2ecf7548c4185e8628f035a5b898f3145781c65bcdd00f361d7b58515b1e36bbfdaaa1d644126a3dae20bafc837785e611fbc1381cf5057cf4f0889c3677ebc899a5f4dda9bcb698fc27a0be92c7d878522a3cdc1d095fd1102cec207bcc2fc45839b4ded946656063f54f8708d2a7dbc09f0d446bec16fe666a3860703397d91d7455f1dda04c92d76268a2718b2a551cda047f0a9d3ab8401f3acbce4d218e69ca92cbb2e3d9301d4a5377a45f134e09eed1301f1a2cacc87c14118ca7c2781848bb3e78bcf0daedd97f0bc553c88923df2fef92fb514d8652e48a561bf80e82dd2c387a7f4380017c525da91075dd9a984acc99cfb4cf2a1ec7cd087367f6d7274ae9de74ac85098a0fcf77343ebf58e26d2b5393a7c7669d547bc10ae2e5650218960f8712ce573fe1abaa004361f654d92f6d9c3cbc3065942a5e4799811a76440624e9e6a469bc9c052e20a8fab801273f6c0559b4b833b1f74724000a555c7f8c9912aa8b70aa6309a723e3235bb020980d3736a6dec44507c8753849c0f697aeed341643195103c0d9043dc400107d605806dd7c65421eb8981af232c4d1b941400ef60e77cfc092b47d9210cb2439d7913237d21ff45ee8ee9f6e53492a9c4dad238705051ab7e1a71321e97ebc1a29f23465c55bd5c577e2f5b42676485bb59f446f286149fe0181144caa1ce4dc61ccd756cad714005fda377b5bae1360abcd1b4d17d48c0a19f3dd45d5ed4d700db344cd2ba48c381b18f2bbee1354b23b076e0a1fac48605f570d7e40dab9126cabe3ff7f265bd1e9555fa15ed0cf9a3863a6c87c493a6816d667a05a38e9f965bfd3dbb2cb16148b98be2a6822e384a6bc4e39c6258c33805bc44fbd03a019aaac96028d3992ea0ef24a171f6ebd6da93eb692e0b4087c17fcce736238039a4e8ac6de427475b7d6a06da8741a687cba26f7d4d3b7ba4fec684477256c0d80e663ff4577499f8150a3faecdd2c59f946a33f4e886328321c815ec3bd243f2f23418cb5774fefd0cd0c8aeaa7c1d208423cd12967bde5c42b976a20119808f2932fa3f4c2ffde1b26a6109b2a83b5104dbab35b0d4b5b671adbb1d9510e2a3612541f0410efbe55f4a51841072dabb5aca0c730bd08a7a6f13828b48bbd4bbf8a9026de350b53aeaa82bbee5fb178fc6e1e5d2d910e22ab9bb57b64a973970b9140e9a31668dd928823f84399912c95a5aa02458ebc069e48c287d229a4fab66d55c75ec7b3b794c25b4986b61d1ec14ea9c270dce58fe99c7ec3ae2d312772f14ee0600a14c3747ff7f404078502bc5dc97d897da9f2709eaf6799c702781a56305de107e13501188c63653df1939c52156f1206723b872020dfa921fc71a07d69020b310e06be9b94c26776d8cf779731d3a42c8954c1aa88bd87495da387d514b55ea93ee77a6ffb370fbf2a76de03a6fcb697b7f05df8a17fc7ef865c4ac4e000a1eb47c8c2c6544bba605a6f64777db35614aed0c69ebff79e2f6ae73daf9a88004ddfde564e59c2b2344ff4e4f733cee3df2b0df35134ffcd1162f8a4d33b93be1395ab1f8beed5ef03503e3cc57606169a925ae9650363100fbce08910804912905eef940c80c4d91033d53e8aff9fcd153a9a8c056ca359a41750d8b8dff0dbb11cb1e3dd476495786eaffc28543c6e217f80bd54bc093961fb6369269e20d90c8679355be207c1ef0cd9174d32123cbfec6248ee1055a7ccfc28148ea832c50ed798047a7f0b1b09964b04397bd27b4e7c21e6f3887920d62c347bba85dc9be38771a15ba6ba03e0ac5991b830bf6fdeac2652ba84f8dcbcae6e0fd18888fd71ada6977e9905ecc1ec6583f16afbcb24fe4e5507ab294530bc0c2078198e17adb75d6384dced19ce21983248a97165509b665f333c6b1872f913218f4ec07d560bcefcbc41b6872e252d7a7c3884172e46f51f355fbe05d8384d8f3b12d51f12044acb1dd974c3737e5a7902d2a8c5da5049877b4a7243bb122fdba9dbc29551495ca09d102783465780b91ffa1915f570337eb8c3a419de11ac28f1f2d0c38189fd0d5425ff6504e1915be93616e8c27fefa96790ff00083adfc80a3ed0226d82bdf8e2ba3ffaac70e82f73e5404645c871bd597423d2484e06f467abbc8729b37317e7a8fa7e67b40e437567f5c36abee96cc604246b8f14528d16135ea600be2d3eef74b1ed76aebca5a980acc803a8a6e6ffee9d31329c922761e7a75c2bd4fbe211a06cf11d8733c48de33a4c0e0fbeccf50223555de4b8643762fcac7915b1ec02bc0f54efec6ad7845e7a1b43fcca71925819df74b74fbd1a6a813b6b78f45e1268342eef7c8037637c60fddce2e367b83e172ec80037bd09afdbd0341a40883daf8e5188555fb3b3f9af2aea9c119057f07238f3764623b8b2b87f318e9cee96c5fe335047c4376553bc1f98e186f1636b25857cd22313536c8ce31489923e1e07e003903b95ef658bbfec9e67f9514eb8f2b84e233b1ac56345cc8b72335eef24ab32ad9a3ae4c03af966939c185b432d3398120cf2e3f6eb506b3fcb6246e2b088577b34768024a00d7b45e678a6ce80fa25ab9493ef7c308fcbb4329a9a4598acfc648093824c09671a486e105a78ac1712797f56149381c0cbd032729a51ca69d628a023f4eb8f81311ec9d223061522c1e03b7a723a4f39f9c6ed0d8b6d4accbe556aadea48111057d7aa7326ca8560b50cdd9a0f6ae822b35c6b9c633ef9d0673ed76b78de132f3c14efb2dc2db4805b258518ccf21dd183d71876ca3de027388dfe41bcb1784bb66bac51cf2b2c5af585cc517d1dad9a0a4ad27ec229e7f55fcc7bd5e38f38a191f43ad4fce1d8e2199c3640e3fdbd84bf52278f7d97267a35c721135549303422838d225191b7f8ae5be99ce55f6ea8535ce</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客提交失败</title>
    <link href="/2021/03/13/Hexo%E5%8D%9A%E5%AE%A2deploy%E9%81%87%E5%88%B0%E9%93%BE%E6%8E%A5github%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/13/Hexo%E5%8D%9A%E5%AE%A2deploy%E9%81%87%E5%88%B0%E9%93%BE%E6%8E%A5github%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客deploy遇到链接github失败的问题"><a href="#Hexo博客deploy遇到链接github失败的问题" class="headerlink" title="Hexo博客deploy遇到链接github失败的问题"></a>Hexo博客deploy遇到链接github失败的问题</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> http<span class="hljs-variable">.proxy</span> http:<span class="hljs-comment">//127.0.0.1:1080</span><br><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> https<span class="hljs-variable">.proxy</span> https:<span class="hljs-comment">//127.0.0.1:1080</span><br><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> --unset http<span class="hljs-variable">.proxy</span><br><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> --unset https<span class="hljs-variable">.proxy</span><br></code></pre></td></tr></table></figure><p>执行一遍上述代码<br>接着执行如下代码</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">clean</span><br><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><br><span class="hljs-attr">hexo</span> <span class="hljs-string">d</span><br></code></pre></td></tr></table></figure><p>完成！</p><h2 id="2021-3-16-更新"><a href="#2021-3-16-更新" class="headerlink" title="2021/3/16 更新"></a>2021/3/16 更新</h2><p>通过DevSidecar插件代理git：<br>从gitee下载DevSidecar: <a href="https://gitee.com/docmirror/dev-sidecar/releases">DevSidecar</a><br>安装插件<br>启动所有服务</p><p>记住你的代理端口：<br>加速服务 - 基本设置 - 代理端口</p><p>git 下运行下述两行代码：记得将代理端口(我为1181)换为你的代理端口<br>git config –global http.proxy <a href="http://127.0.0.1:1181/">http://127.0.0.1:1181</a></p><p>git config –global https.proxy <a href="https://127.0.0.1:1181/">https://127.0.0.1:1181</a></p><p>然后就可快乐的 git push 了</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Egg官方文档阅读笔记：Egg.js内置基础对象</title>
    <link href="/2021/03/13/Egg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%9AEgg%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/03/13/Egg%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%9AEgg%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Egg官方文档阅读笔记：Egg内置对象"><a href="#Egg官方文档阅读笔记：Egg内置对象" class="headerlink" title="Egg官方文档阅读笔记：Egg内置对象"></a>Egg官方文档阅读笔记：Egg内置对象</h1><h2 id="Egg-js-框架内的内置基础对象"><a href="#Egg-js-框架内的内置基础对象" class="headerlink" title="Egg.js 框架内的内置基础对象"></a>Egg.js 框架内的内置基础对象</h2><ol><li>Application</li><li>Context</li><li>Request</li><li>Response</li><li>Controller</li><li>Service</li><li>Helper</li><li>Config</li><li>Logger</li></ol><p>1-4的内置对象继承于Koa，5-9为Egg.js框架扩展封装的一些对象<br>本文介绍常用的内置对象，其余内置对象可参考<a href="https://eggjs.org/zh-cn/basics/objects.html">Egg.js官方文档(框架内置基础对象)</a></p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>Application 继承自 Koa.Application，是<strong>全局应用对象</strong>，其意味着：<br><strong>在一个应用中，只会实例化一个</strong>，在它上面<strong>可以挂载全局的方法和对象</strong>，同时可以在插件或者应用中<strong>扩展 Application 对象</strong>。(全局/唯一/可操作)</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Application 对象几乎可以在编写应用时的<strong>任何一个地方获取</strong><br>常用的获取方式：</p><ol><li>export 暴露函数时获取 Application 对象<br>被框架<strong>Loader加载</strong>的文件(一般常用路径下的文件，例如Controller，Service，Schedule 等路径文件都被Loader加载)在<strong>暴露函数</strong>时，其函数被 Loader 调用，此时就会<strong>传入 app 对象作为参数</strong>：<br><code>module.exports = app =&gt; &#123;...&#125;</code></li><li>通过继承类的实例访问 Application 对象<br>在继承于 Controller, Service 等基类的实例中，可以通过 <code>this.app</code> 访问到 Application 对象。<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// app/controller/user.js</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>  async fetch() &#123;<br>    <span class="hljs-keyword">this</span>.ctx.body = <span class="hljs-keyword">this</span>.app.cache.get(<span class="hljs-keyword">this</span>.ctx.query.id);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>在 Context 对象上，可以通过 <code>ctx.app</code> 访问 Application 对象<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// app/controller/user.js</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>  async fetch() &#123;<br>    <span class="hljs-keyword">this</span>.ctx.body = <span class="hljs-keyword">this</span>.ctx.app.cache.get(<span class="hljs-keyword">this</span>.ctx.query.id);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context 继承自 Koa.Context，是一个<strong>请求级别的对象</strong>，其意味着：<br>框架将会在<strong>每次发生用户请求时实例化一个 Context 对象</strong>，对象<strong>封装</strong>这次用户请求的信息，同时提供(暴露)许多方法来获取请求参数或者设置响应信息。<br>此外，框架内的 Service 会全部挂载到 Context 实例上，一些插件也会将一些其他的方法和对象挂载到它上面（egg-sequelize 会将所有的 model 挂载在 Context 上）。</p><h3 id="获取方式-1"><a href="#获取方式-1" class="headerlink" title="获取方式"></a>获取方式</h3><p>Context 实例获取方式一般是在 Middleware, Controller 以及 Service 中。此外还有一些 Context 实例的获取(如在未发生请求时，匿名创建Context实例等)不做详述。</p><ol><li>Controller 中获取 Context 实例<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// app/controller/user.js</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>  async fetch() &#123;<br>    <span class="hljs-keyword">this</span>.ctx.body = <span class="hljs-keyword">this</span>.ctx.app.cache.get(<span class="hljs-keyword">this</span>.ctx.query.id);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>Service 中获取 Context 实例 (同在 Controller 中获取)</li><li>Middleware 中获取 Context 实例 (同Koa框架在中间件中获取 Context 对象的方式)<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali">// Koa v2<br>async function middleware(ctx, next) &#123;<br>  // ctx is<span class="hljs-built_in"> instance </span>of Context<br>  console.log(ctx.query);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Request-amp-Response"><a href="#Request-amp-Response" class="headerlink" title="Request &amp; Response"></a>Request &amp; Response</h2><p>Request 继承自 Koa.Request ，是一个请求级别的对象。封装了 Node.js 原生的 HTTP Request 对象，同时提供(暴露)了一些方法，用于获取 HTTP 请求常用参数。</p><p>Response 继承自 Koa.Response ，是一个请求级别的对象。封装了 Node.js 原生的 HTTP Response 对象，同时提供(暴露)了一些方法，用于设置 HTTP 响应。</p><h3 id="获取方式-2"><a href="#获取方式-2" class="headerlink" title="获取方式"></a>获取方式</h3><p>在 Context 实例上获取当前请求的 Request(ctx.request) 和 Response(ctx.response) 实例。(因为 Context 本身也是请求发生时被框架实例化的)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// app/controller/user.js</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>  async fetch() &#123;<br>    const &#123; app, ctx &#125; = <span class="hljs-keyword">this</span>;<br>    const id = ctx.request.query.id;<br>    ctx.response.body = app.cache.get(id);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>Controller 对象是 Egg.js 框架提供的一个基类，该基类有以下属性(注意基类中有ctx,app等，这也解释了ctx,app等实例可以从基类中获取的原因)：</p><ol><li>ctx - 当前请求的 Context 实例。</li><li>app - 应用的 Application 实例。</li><li>config - 应用的配置。</li><li>service - 应用所有的 service。</li><li>logger - 为当前 controller 封装的 logger 对象。</li></ol><h3 id="Controller-基类的继承与引用"><a href="#Controller-基类的继承与引用" class="headerlink" title="Controller 基类的继承与引用"></a>Controller 基类的继承与引用</h3><p><strong>方法一：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 从 egg 上获取（推荐）</span><br>const <span class="hljs-type">Controller</span> = require(<span class="hljs-symbol">&#x27;eg</span>g&#x27;).<span class="hljs-type">Controller</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>  <span class="hljs-comment">// implement</span><br>&#125;<br>module.exports = <span class="hljs-type">UserController</span>;<br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 从 app 实例上获取</span><br>module.exports = app =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">app</span>.<span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-comment">// implement</span><br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service 对象是 Egg.js 框架提供的一个基类，其基类属性和访问方式和 Controller 基类一致：</p><ol><li>ctx - 当前请求的 Context 实例。</li><li>app - 应用的 Application 实例。</li><li>config - 应用的配置。</li><li>service - 应用所有的 service。</li><li>logger - 为当前 controller 封装的 logger 对象。</li></ol><h3 id="Service-基类的继承与引用"><a href="#Service-基类的继承与引用" class="headerlink" title="Service 基类的继承与引用"></a>Service 基类的继承与引用</h3><p><strong>方式一：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 从 egg 上获取（推荐）</span><br>const <span class="hljs-type">Service</span> = require(<span class="hljs-symbol">&#x27;eg</span>g&#x27;).<span class="hljs-type">Service</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br>  <span class="hljs-comment">// implement</span><br>&#125;<br>module.exports = <span class="hljs-type">UserService</span>;<br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 从 app 实例上获取</span><br>module.exports = app =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">app</span>.<span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-comment">// implement</span><br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Helper"><a href="#Helper" class="headerlink" title="Helper"></a>Helper</h2><p>Helper 作用: 将一些可复用的函数抽离在 helper.js 里面成为一个独立的函数。<br>Helper 自身是一个类，有和 Controller 基类一样的属性，它也会在每次请求时进行实例化，因此 <strong>Helper 上的所有函数也能获取到当前请求相关的上下文信息</strong>。</p><h3 id="获取方式-3"><a href="#获取方式-3" class="headerlink" title="获取方式"></a>获取方式</h3><p>在 Context 的实例上获取到当前请求的 Helper(ctx.helper) 实例。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// app/controller/user.js</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>  async fetch() &#123;<br>    const &#123; app, ctx &#125; = <span class="hljs-keyword">this</span>;<br>    const id = ctx.query.id;<br>    const user = app.cache.get(id);<br>    ctx.body = ctx.helper.formatUser(user);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="helper-js-中方法定义"><a href="#helper-js-中方法定义" class="headerlink" title="helper.js 中方法定义"></a>helper.js 中方法定义</h3><p>通过框架扩展的形式来自定义 helper 方法，例如上述<code>ctx.helper.formatUser()</code><br>框架拓展：框架会把 <code>app/extend/helper.js</code> 中定义的对象与内置 helper 的 prototype 对象进行合并，在处理请求时会基于扩展后的 prototype 生成 helper 对象。(即将自定义 helper 对象合并到框架内置 helper 对象内，生成新的扩展 helper 对象)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app/extend/helper.js</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-function"><span class="hljs-title">formatUser</span>(<span class="hljs-params">user</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> only(user, [ <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;phone&#x27;</span> ]);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：Helper 是个类，我们抽离的可复用方法是通过<code>app/extend/helper.js</code> 中的模块打包为对象导出后，遵循框架扩展的原则与内置helper对象合并得到的。需要通过 helper 对象访问内部自定义方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内置对象间的引用看似复杂，实际上都大同小异：<br>从<strong>获取方式</strong>上对它们做了相应的总结</p><p><strong>通过类内this获取：</strong></p><ol><li>对于从Koa继承的对象(app,ctx)，Egg的扩展内置对象均对其做了封装，即在类内都能直接通过this获取。</li><li>从Koa继承的(request,response)请求级别对象，本身就被Koa的(ctx)对象调用，因此在Egg的其他内置对象类也可以通过ctx调用request,response。</li></ol><p><strong>各内置对象间的调用：</strong></p><ol><li>ctx 可以通过 <code>ctx.app</code> 返回 app 对象的引用</li><li>ctx 上可挂载 service 和一些插件即配置信息</li></ol><p><strong>其他方式：</strong></p><ol><li>exports暴露函数时传参：所有被Loader加载的文件暴露函数时，均会默认传入 app 对象作为参数</li><li>中间件定义时，默认传入ctx对象作为参数</li></ol><p>总体来说，app(全局对象) 和 ctx(每次请求均被实例化) 几乎是全局存在的，在其他内置对象内可通过this调用，app 可被 ctx 返回，app 可在exports函数时作为参数传入，ctx 可作为中间件参数传入。request/response 通过 ctx 调用。Controller 和 Service 均包含五大属性(ctx,app,config,service,logger)，此外Service全部会被挂载在 ctx 对象上，通过 ctx 对象也可以访问 service。</p>]]></content>
    
    
    <categories>
      
      <category>Egg</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Egg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识 Egg.js</title>
    <link href="/2021/03/13/Egg%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8/"/>
    <url>/2021/03/13/Egg%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Egg初级入门"><a href="#Egg初级入门" class="headerlink" title="Egg初级入门"></a>Egg初级入门</h1><p>参考文章：</p><ol><li><a href="https://juejin.cn/post/6844903718106693646">Egg.js 基本使用</a></li><li><a href="https://juejin.cn/post/6844903716777099278">Egg.js 源码分析-项目启动</a></li><li><a href="https://juejin.cn/post/6844904081689952269">Egg.js 项目结构</a></li></ol><h2 id="Egg-js-安装"><a href="#Egg-js-安装" class="headerlink" title="Egg.js 安装"></a>Egg.js 安装</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>根据<a href="https://eggjs.org/zh-cn/intro/quickstart.html">Egg.js官方文档</a>快速创建项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir 自定义项目名 &amp;&amp; <span class="hljs-built_in">cd</span> 自定义项目名</span><br><span class="hljs-meta">$</span><span class="bash"> npm init egg --<span class="hljs-built_in">type</span>=simple</span><br><span class="hljs-meta">$</span><span class="bash"> npm i</span><br></code></pre></td></tr></table></figure><p>项目创建完成后可进行初步测试，检测是否安装成功：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ npm <span class="hljs-built_in">run</span> dev<br>$ <span class="hljs-built_in">open</span> http:<span class="hljs-comment">//localhost:7001</span><br></code></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>通过<code>egg-init</code>脚手架初始化项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> npm i egg-init -g</span><br><span class="hljs-meta">$</span><span class="bash"> egg-init 自定义项目名 --<span class="hljs-built_in">type</span>=simple</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> 自定义项目名</span><br><span class="hljs-meta">$</span><span class="bash"> npm i</span><br><span class="hljs-meta">$</span><span class="bash"> npm run dev</span><br></code></pre></td></tr></table></figure><h2 id="Egg-js-项目目录结构"><a href="#Egg-js-项目目录结构" class="headerlink" title="Egg.js 项目目录结构"></a>Egg.js 项目目录结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs stylus">egg-project<br>├── package.json<br>├── app<span class="hljs-selector-class">.js</span> (可选)<br>├── agent<span class="hljs-selector-class">.js</span> (可选)<br>├── app<br>│   ├── router<span class="hljs-selector-class">.js</span> <span class="hljs-comment">// 配置路由</span><br>│   ├── controller <span class="hljs-comment">// 控制器</span><br>│        └── home.js<br>│   ├── service (可选) <span class="hljs-comment">// 服务</span><br>│        └── user.js<br>│   ├── middleware (可选) <span class="hljs-comment">// 中间件</span><br>│        └── response_time.js<br>│   ├── schedule (可选) <span class="hljs-comment">// 用于定时任务</span><br>│        └── my_task.js<br>│   ├── public (可选) <span class="hljs-comment">// 静态资源文件</span><br>│        └── reset.css<br>│   ├── view (可选) <span class="hljs-comment">// 模板视图</span><br>│        └── home.tpl<br>│   └── extend (可选) <span class="hljs-comment">// 集成功能插件</span><br>│       ├── helper<span class="hljs-selector-class">.js</span> (可选)<br>│       ├── request<span class="hljs-selector-class">.js</span> (可选)<br>│       ├── response<span class="hljs-selector-class">.js</span> (可选)<br>│       ├── context<span class="hljs-selector-class">.js</span> (可选)<br>│       ├── application<span class="hljs-selector-class">.js</span> (可选)<br>│       └── agent<span class="hljs-selector-class">.js</span> (可选)<br>├── config <span class="hljs-comment">// 必要的核心配置</span><br>│   ├── plugin<span class="hljs-selector-class">.js</span> <span class="hljs-comment">// 插件配置</span><br>│   ├── config<span class="hljs-selector-class">.default</span><span class="hljs-selector-class">.js</span> <span class="hljs-comment">// 默认基础配置</span><br>│   ├── config<span class="hljs-selector-class">.prod</span><span class="hljs-selector-class">.js</span> <span class="hljs-comment">// 生产环境</span><br>│   ├── config<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.js</span> (可选) <span class="hljs-comment">// 测试配置</span><br>│   ├── config<span class="hljs-selector-class">.local</span><span class="hljs-selector-class">.js</span> (可选) <span class="hljs-comment">// 本地配置</span><br>│   └── config<span class="hljs-selector-class">.unittest</span><span class="hljs-selector-class">.js</span> (可选) <span class="hljs-comment">// 待定 </span><br>└── test <span class="hljs-comment">// 测试需要</span><br>    ├── middleware<br>        └── response_time<span class="hljs-selector-class">.test</span>.js<br>    └── controller<br>        └── home<span class="hljs-selector-class">.test</span>.js<br></code></pre></td></tr></table></figure><p><code>app/router.js</code> 用于配置 URL 路由规则<br><code>app/controller/**</code> 用于解析用户的输入，处理后返回相应的结果(管理服务器与用户交互行为)<br><code>app/service/**</code> 用于编写业务逻辑层(操作数据库)<br><code>app/middleware/**</code> 用于编写中间件<br><code>app/public/**</code> 用于放置静态资源<br><code>app/extend/**</code> 用于框架的扩展<br><code>config/config.&#123;env&#125;.js</code> 用于编写配置文件(配置环境)<br><code>config/plugin.js</code> 用于配置需要加载的插件<br><code>test/**</code> 用于单元测试<br><code>app.js</code> 和 <code>agent.js</code> 用于自定义启动时的初始化工作</p><h2 id="Egg-路由配置"><a href="#Egg-路由配置" class="headerlink" title="Egg 路由配置"></a>Egg 路由配置</h2><p>Egg Router: 描述请求 URL 和具体承担执行动作的 Controller 的对应关系。(一个route对应Controller中的执行方法)<br>Egg 框架约定了 <code>app/router.js</code> 文件用于<strong>统一所有路由规则</strong>。通过统一的配置，可以避免路由规则逻辑散落在多个地方，从而出现未知的冲突，集中在一起我们可以更方便的来查看全局的路由规则。</p><h3 id="Router-定义和使用"><a href="#Router-定义和使用" class="headerlink" title="Router 定义和使用"></a>Router 定义和使用</h3><h4 id="app-router-js"><a href="#app-router-js" class="headerlink" title="app/router.js"></a>app/router.js</h4><p>定义 URL 路由规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app/router.js</span><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">app</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; router, controller &#125; = app;<br>    router.get(<span class="hljs-string">&#x27;/user/:id&#x27;</span>, controller.user.info);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>controller.user.info</code>是Router回调函数所指向的app的controller下面的对象。该路径可以解析为：<code>controller</code> 是<code>app</code>的一个属性对象， eggjs 会在启动的时候调用<code>this.loadController();</code>方法，去加载整个应用<code>app/controller</code>文件下的所有的js 文件， 会将文件名作为属性名称，挂载在<code>app.controller</code> 对象上，分析 <code>/controller</code> 目录下js文件，其都将继承类作为借口export(暴露)出来了，因此，可以通过<strong>类.方法名</strong>的方式使用类内方法了，连在一起就写为了形如 <code>controller.user.findAll</code> 的方式来引用Controller 下面的方法了。</p><h4 id="app-controller"><a href="#app-controller" class="headerlink" title="app/controller/**"></a>app/controller/**</h4><p>在 controller 目录下实现对应的 Controller 方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// app/controller/user.js</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    async info() &#123;<br>        const &#123;ctx&#125; = <span class="hljs-keyword">this</span>;<br>        ctx.body = &#123;<br>            name: `hello $&#123;ctx.params.id&#125;`,<br>        &#125;<br>    &#125;<br>&#125;<br><br>module.exports = <span class="hljs-type">UserController</span>;<br></code></pre></td></tr></table></figure><p>定义完路由规则和对应方法后，我们就算完成了一个最简单的Router定义。效果：用户向<code>/user/xxx</code>执行 GET 请求时，user.js 内的相应方法就会执行。</p><h4 id="组织和管理路由映射"><a href="#组织和管理路由映射" class="headerlink" title="组织和管理路由映射"></a>组织和管理路由映射</h4><p>项目中会涉及很多路由映射，若全写在 <code>app/router.js</code> 中会难以管理。我们可以根据需求做如下拆分：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// app/router.js</span><br>module.exports = <span class="hljs-keyword">app</span> =&gt; &#123;<br>    <span class="hljs-comment">// require()引入函数，接收参数。因为/router/xx.js内不自带Application对象，因此通过参数传递</span><br>    require(&#x27;./router/<span class="hljs-keyword">news</span>&#x27;)(<span class="hljs-keyword">app</span>);<br>    require(&#x27;./router/admin&#x27;)(<span class="hljs-keyword">app</span>);<br>&#125;<br><br><span class="hljs-comment">// app/router/news.js</span><br>module.exports = <span class="hljs-keyword">app</span> =&gt; &#123;<br>    <span class="hljs-keyword">app</span>.router.<span class="hljs-built_in">get</span>(&#x27;/<span class="hljs-keyword">news</span>/<span class="hljs-keyword">list</span>&#x27;, <span class="hljs-keyword">app</span>.controller.<span class="hljs-keyword">news</span>.<span class="hljs-keyword">list</span>);<br>    <span class="hljs-keyword">app</span>.router.<span class="hljs-built_in">get</span>(&#x27;/<span class="hljs-keyword">news</span>/detail&#x27;, <span class="hljs-keyword">app</span>.controller.<span class="hljs-keyword">news</span>.detail);<br>&#125;<br><br><span class="hljs-comment">// app/router/admin.js</span><br>module.exports = <span class="hljs-keyword">app</span> =&gt; &#123;<br>    <span class="hljs-keyword">app</span>.router.<span class="hljs-built_in">get</span>(&#x27;/admin/user&#x27;, <span class="hljs-keyword">app</span>.controller.admin.user);<br>    <span class="hljs-keyword">app</span>.router.<span class="hljs-built_in">get</span>(&#x27;/admin/<span class="hljs-keyword">log</span>&#x27;, <span class="hljs-keyword">app</span>.controller.admin.<span class="hljs-keyword">log</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Service-操作数据库"><a href="#Service-操作数据库" class="headerlink" title="Service 操作数据库"></a>Service 操作数据库</h3><p>若你实现好了上述代码，则已经开发好了Router 和Controller , 但是在我们的controller 中，都是静态的内容,例如上述代码中只给<code>ctx.body</code>放入了一个对象。<br>在项目中我们需要跟数据库交互，实现前后端分离，我们一般将跟数据库交互的内容，都放在Service 层。Service 的目录一般为<code>app/service</code>，在该路径下我们可以创建多个 js 文件管理不同的数据库操作。</p><h4 id="定义-Service"><a href="#定义-Service" class="headerlink" title="定义 Service"></a>定义 Service</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// app/service/user.js</span><br><br><span class="hljs-comment">// 引入egg内置的Service对象</span><br>const <span class="hljs-type">Service</span> = require(<span class="hljs-symbol">&#x27;eg</span>g&#x27;).<span class="hljs-type">Service</span>;<br><br><span class="hljs-comment">// 继承Service类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br>  async find(uid) &#123;<br>    const user = await <span class="hljs-keyword">this</span>.ctx.db.query(<span class="hljs-symbol">&#x27;select</span> * from user where uid = ?&#x27;, uid);<br>    <span class="hljs-keyword">return</span> user;<br>  &#125;<br>&#125;<br><br>module.exports = <span class="hljs-type">UserService</span>;<br></code></pre></td></tr></table></figure><h4 id="在-Controller-中使用"><a href="#在-Controller-中使用" class="headerlink" title="在 Controller 中使用"></a>在 Controller 中使用</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// app/controller/user.js</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    async info() &#123;<br>        const &#123;ctx&#125; = <span class="hljs-keyword">this</span>;<br>        ctx.body = <span class="hljs-keyword">this</span>.service.user.find();<br>    &#125;<br>&#125;<br><br>module.exports = <span class="hljs-type">UserController</span>;<br></code></pre></td></tr></table></figure><p>在Controller中调用Service类内的方法和路由调用Controller类内方法类似：<code>this.service.home.index();</code><br>注：此处也可以用 <code>this.ctx.service</code> 代替 <code>this.service</code> ，两者是等价的</p><h3 id="egg-mysql-插件访问-MySQL-数据库"><a href="#egg-mysql-插件访问-MySQL-数据库" class="headerlink" title="egg-mysql 插件访问 MySQL 数据库"></a>egg-mysql 插件访问 MySQL 数据库</h3><p>Egg.js 提供了 egg-mysql 插件来访问 MySQL 数据库。<br><strong>插件安装：</strong><br><code>$ npm i --save egg-mysql</code><br><strong>插件配置：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// config/plugin.js</span><br><span class="hljs-keyword">exports</span>.mysql = &#123;<br>  enable: <span class="hljs-keyword">true</span>,<br>  <span class="hljs-keyword">package</span>: <span class="hljs-string">&#x27;egg-mysql&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在当前版本中，<code>plugin.js</code>文件统一以对象导出，因此可以写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  mysql: &#123;<br>    enable: <span class="hljs-keyword">true</span>,<br>    <span class="hljs-keyword">package</span>: <span class="hljs-string">&#x27;egg-mysql&#x27;</span>,<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>环境配置(数据库连接信息)：</strong><br>单数据源(只访问一个MySQL数据库实例)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> config/config.default.js<br>exports.mysql = &#123;<br>  <span class="hljs-regexp">//</span> 单数据库信息配置<br>  client: &#123;<br>    <span class="hljs-regexp">//</span> host<br>    host: <span class="hljs-string">&#x27;mysql.com&#x27;</span>,<br>    <span class="hljs-regexp">//</span> 端口号<br>    port: <span class="hljs-string">&#x27;3306&#x27;</span>,<br>    <span class="hljs-regexp">//</span> 用户名<br>    user: <span class="hljs-string">&#x27;test_user&#x27;</span>,<br>    <span class="hljs-regexp">//</span> 密码<br>    password: <span class="hljs-string">&#x27;test_password&#x27;</span>,<br>    <span class="hljs-regexp">//</span> 数据库名<br>    database: <span class="hljs-string">&#x27;test&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-regexp">//</span> 是否加载到 app 上，默认开启<br>  app: true,<br>  <span class="hljs-regexp">//</span> 是否加载到 agent 上，默认关闭<br>  agent: false,<br>&#125;;<br></code></pre></td></tr></table></figure><p>当前 config.default.js 配置文件中，统一用 <code>module.exports</code> 导出对象，因此也可以写在 config 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">appInfo</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> config = <span class="hljs-built_in">exports</span> = &#123;<br>    mysql: &#123;<br>      client: &#123;<br>        <span class="hljs-comment">// host</span><br>        host: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        <span class="hljs-comment">// 端口号</span><br>        port: <span class="hljs-string">&#x27;3306&#x27;</span>,<br>        <span class="hljs-comment">// 用户名</span><br>        user: <span class="hljs-string">&#x27;root&#x27;</span>,<br>        <span class="hljs-comment">// 密码</span><br>        password: <span class="hljs-string">&#x27;root&#x27;</span>,<br>        <span class="hljs-comment">// 数据库名</span><br>        database: <span class="hljs-string">&#x27;trajsystem&#x27;</span>,<br>      &#125;,<br>      <span class="hljs-comment">// 是否加载到 app 上，默认开启</span><br>      app: <span class="hljs-literal">true</span>,<br>      <span class="hljs-comment">// 是否加载到 agent 上，默认关闭</span><br>      agent: <span class="hljs-literal">false</span>,<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// use for cookie sign key, should change to your own and keep security</span><br>  config.keys = appInfo.name + <span class="hljs-string">&#x27;_1615607271496_3440&#x27;</span>;<br><br>  <span class="hljs-comment">// add your middleware config here</span><br>  config.middleware = [];<br><br>  <span class="hljs-comment">// add your user config here</span><br>  <span class="hljs-keyword">const</span> userConfig = &#123;<br>    <span class="hljs-comment">// myAppName: &#x27;egg&#x27;,</span><br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    ...config,<br>    ...userConfig,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意此处的写法，<code>=</code>从右向左赋值，因此配置对象首先赋值给<code>exports(exports=&#123;mysql:&#123;...&#125;, ...&#125;)</code>，之后 config 在获得 exports 对象。在最后返回值的时候，用了ES6的展开语法<code>...</code>将 config 展开后抛出。按照我的理解，config 展开后应该抛出形如<code>exports.mysql</code>的形式。因此上述写法和之前将环境配置单独导出类似。</p><p><strong>单实例使用方式：</strong> <code>await app.mysql.query(sql, values);</code></p><p>多数据源(应用需要访问多个MySQL数据源)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs awk">exports.mysql = &#123;<br>  clients: &#123;<br>    <span class="hljs-regexp">//</span> clientId, 获取client实例，需要通过 app.mysql.get(<span class="hljs-string">&#x27;clientId&#x27;</span>) 获取<br>    db1: &#123;<br>      <span class="hljs-regexp">//</span> host<br>      host: <span class="hljs-string">&#x27;mysql.com&#x27;</span>,<br>      <span class="hljs-regexp">//</span> 端口号<br>      port: <span class="hljs-string">&#x27;3306&#x27;</span>,<br>      <span class="hljs-regexp">//</span> 用户名<br>      user: <span class="hljs-string">&#x27;test_user&#x27;</span>,<br>      <span class="hljs-regexp">//</span> 密码<br>      password: <span class="hljs-string">&#x27;test_password&#x27;</span>,<br>      <span class="hljs-regexp">//</span> 数据库名<br>      database: <span class="hljs-string">&#x27;test&#x27;</span>,<br>    &#125;,<br>    db2: &#123;<br>      <span class="hljs-regexp">//</span> host<br>      host: <span class="hljs-string">&#x27;mysql2.com&#x27;</span>,<br>      <span class="hljs-regexp">//</span> 端口号<br>      port: <span class="hljs-string">&#x27;3307&#x27;</span>,<br>      <span class="hljs-regexp">//</span> 用户名<br>      user: <span class="hljs-string">&#x27;test_user&#x27;</span>,<br>      <span class="hljs-regexp">//</span> 密码<br>      password: <span class="hljs-string">&#x27;test_password&#x27;</span>,<br>      <span class="hljs-regexp">//</span> 数据库名<br>      database: <span class="hljs-string">&#x27;test&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-regexp">//</span> ...<br>  &#125;,<br>  <span class="hljs-regexp">//</span> 所有数据库配置的默认值<br>  default: &#123;<br><br>  &#125;,<br><br>  <span class="hljs-regexp">//</span> 是否加载到 app 上，默认开启<br>  app: true,<br>  <span class="hljs-regexp">//</span> 是否加载到 agent 上，默认关闭<br>  agent: false,<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>多实例使用方式：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">cosnt client1 = app.mysql.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;db1&#x27;</span>);<br>await client1.query(<span class="hljs-keyword">sql</span>, <span class="hljs-keyword">values</span>);<br><br>const client2 = app.mysql.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;db2&#x27;</span>);<br>await client2.query(<span class="hljs-keyword">sql</span>, <span class="hljs-keyword">values</span>);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们完成了由Egg.js制作接口，连接数据库，并实现接口的暴露以及前后端通过接口实现数据库交互的一系列简单的操作。<br>现总结如下：</p><ol><li>定义 Router , 在 <code>app/router.js</code> 中构建路由映射</li><li>定义 Controller，在 <code>app/controller</code> 目录下，编写路由跳转后需要执行的方法。</li><li>安装 egg-mysql 插件，在 <code>config/plugin.js</code> 文件中配置插件，在环境中配置数据库的连接信息等</li><li>定义 Service，在 <code>app/service</code> 目录下维护一些与数据库有关的操作，例如 CRUD 语句等。</li><li>将 Service 中的继承类暴露，并在 Controller 中调用其内部方法。</li></ol><p>整体可概括为： Router – Controller – Service(MySQL)</p>]]></content>
    
    
    <categories>
      
      <category>Egg</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Egg</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js - axios</title>
    <link href="/2021/03/12/Vue-axios/"/>
    <url>/2021/03/12/Vue-axios/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-axios"><a href="#Vue-axios" class="headerlink" title="Vue-axios"></a>Vue-axios</h1><h2 id="Part1-axios库安装和引用"><a href="#Part1-axios库安装和引用" class="headerlink" title="Part1: axios库安装和引用"></a>Part1: axios库安装和引用</h2><p>Vue框架内不包含axios库，因为axios库本身就作为一个独立的第三方库存在并长期维护。因此，Vue框架内使用axios就有必须引入axios第三方库。<br>安装：<code>npm install --save axios</code><br>引用：<br>ES6 - <code>import axios from &#39;axios&#39;</code><br>CommonJs - <code>const axios = require(&#39;axios&#39;)</code><br><strong>注意：axios在开发和发布使用时均会使用，为了在<code>package.json</code>中添加相应的依赖，安装时请务必加上<code>--save</code></strong><br><a href="https://www.npmjs.com/package/axios">axios-npm文档</a></p><h2 id="Part2-全局axios"><a href="#Part2-全局axios" class="headerlink" title="Part2: 全局axios"></a>Part2: 全局axios</h2><p>全局axios: 未创建实例的axios对象称为全局axios</p><p><strong>测试网站：(练习时可用以下网址测试)</strong><br><code>httpbin.org</code><br><code>123.207.32.32:8000/home/multidata</code><br><code>123.207.32.32:8000/home/data?type=sell&amp;page=3</code></p><h3 id="axios-config"><a href="#axios-config" class="headerlink" title="axios({config})"></a>axios({config})</h3><p>A. axios 接收<strong>对象</strong>作为参数,<strong>在参数内做相应的配置</strong>.<br>参数配置项可参考axios官方文档，以下列出几个常用的属性：</p><ol><li>url: url地址</li><li>method: 请求方式(get | post | …) //默认值 get</li><li>params: 接收对象类型, 专门针对get请求的参数拼接(query部分)</li><li>timeout: 设定超时阈值</li><li>baseURL: 设定基础url,若设定了则 url 属性传入相对路径即可</li></ol><p>B. axios 支持 Promise, 其<strong>本身包裹并执行了网络请求(异步操作)</strong>, 通过 .then() | .catch() 等获取传递的数据进行进一步处理.</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 向httpbin.org发送get请求，并对请求成功的传递值做相应的打印</span><br><span class="hljs-selector-tag">axios</span>(&#123;<br>    <span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>,<br>    <span class="hljs-attribute">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>&#125;)<span class="hljs-selector-class">.then</span>(<br>    (res) =&gt; &#123;<br>        <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(res)<br>    &#125;<br>)<br><br><span class="hljs-comment">// url带有query传递参数的请求，query通过params传递</span><br><span class="hljs-selector-tag">axios</span>(&#123;<br>    <span class="hljs-attribute">baseURL</span>: <span class="hljs-string">&#x27;http://123.207.32.32:8000&#x27;</span>,<br>    <span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;/home/data&#x27;</span>,<br>    <span class="hljs-attribute">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attribute">params</span>: &#123;<br>        <span class="hljs-attribute">type</span>: <span class="hljs-string">&#x27;sell&#x27;</span>,<br>        <span class="hljs-attribute">page</span>: <span class="hljs-number">3</span>,<br>    &#125;<br>&#125;)<span class="hljs-selector-class">.then</span>(<br>    res =&gt; console.log(<span class="hljs-string">&#x27;baseURL&#x27;</span>,res)<br>)<br></code></pre></td></tr></table></figure><h3 id="axios-get-url-config"><a href="#axios-get-url-config" class="headerlink" title="axios.get(url, {config})"></a>axios.get(url, {config})</h3><p>axios 除了所有参数都在config对象内定义之外，还有其他的写法，例如本例指定以get方式发送网络请求。此时参数包括了 url 和其他剩余配置参数(以对象包裹)。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">// axios.<span class="hljs-built_in">get</span>(url,&#123;config&#125;)<br>axios.<span class="hljs-built_in">get</span>(<br>    <span class="hljs-string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span>,<br>    &#123;timeou<span class="hljs-variable">t:</span> <span class="hljs-number">5000</span>&#125;,<br>).then(<br>    <span class="hljs-keyword">res</span> =&gt; &#123;<br>        console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">res</span>)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><h3 id="axios-all"><a href="#axios-all" class="headerlink" title="axios.all()"></a>axios.all()</h3><p>有些网络请求是需要合并发送的，当请求存在多个且需要等待所有请求结果均返回后才落定状态(resolve | reject)，那么需要用到 axios 的 all() 方法。<br>作用：发送并发请求,所有请求均完成后执行处理程序<br>参数：接收数组作为参数,数组内接收多个请求. 与 Promise.all() 类似.<br>返回值：数组类型,包含多个请求结果对象. 若期望将数组展开,可调用 axios.spread 方法(ES6数组解构方法也可以)</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">axios</span><span class="hljs-selector-class">.all</span>([<br>    axios(&#123;<br>        <span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span>,<br>    &#125;),<br>    axios(&#123;<br>        <span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,<br>        <span class="hljs-attribute">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>        <span class="hljs-attribute">params</span>: &#123;<br>            <span class="hljs-attribute">type</span>: <span class="hljs-string">&#x27;sell&#x27;</span>,<br>            <span class="hljs-attribute">page</span>: <span class="hljs-number">3</span>,<br>        &#125;<br>    &#125;)<br>])<span class="hljs-selector-class">.then</span>(<br>    results =&gt; console.log(results)<br>)<br><br><span class="hljs-selector-tag">axios</span><span class="hljs-selector-class">.all</span>([<br>    axios(&#123;<br>        <span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span>,<br>    &#125;),<br>    axios(&#123;<br>        <span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,<br>        <span class="hljs-attribute">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>        <span class="hljs-attribute">params</span>: &#123;<br>            <span class="hljs-attribute">type</span>: <span class="hljs-string">&#x27;sell&#x27;</span>,<br>            <span class="hljs-attribute">page</span>: <span class="hljs-number">3</span>,<br>        &#125;<br>    &#125;)<br>])<span class="hljs-selector-class">.then</span>(<br>    <span class="hljs-comment">// axios.spread 使用</span><br>    axios.spread((res1, res2) =&gt; &#123;<br>        console.log(<span class="hljs-string">&#x27;spread&#x27;</span>, res1);<br>        console.log(<span class="hljs-string">&#x27;spread&#x27;</span>, res2);<br>    &#125;)<br>)<br><br><span class="hljs-selector-tag">axios</span><span class="hljs-selector-class">.all</span>([<br>    axios(&#123;<br>        <span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;http://123.207.32.32:8000/home/multidata&#x27;</span>,<br>    &#125;),<br>    axios(&#123;<br>        <span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;http://123.207.32.32:8000/home/data&#x27;</span>,<br>        <span class="hljs-attribute">method</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>        <span class="hljs-attribute">params</span>: &#123;<br>            <span class="hljs-attribute">type</span>: <span class="hljs-string">&#x27;sell&#x27;</span>,<br>            <span class="hljs-attribute">page</span>: <span class="hljs-number">3</span>,<br>        &#125;<br>    &#125;)<br>])<span class="hljs-selector-class">.then</span>(<br>    <span class="hljs-comment">// 数组解构</span><br>    ([res1, res2]) =&gt; &#123;<br>        <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;array&#x27;</span>, res1);<br>        <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;array&#x27;</span>, res2);<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><h3 id="axios-全局配置"><a href="#axios-全局配置" class="headerlink" title="axios 全局配置"></a>axios 全局配置</h3><p>语法：<code>axios.defaults.xxx = yyy</code><br>xxx 为axios的配置参数<br>举例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">axios.defaults.timeout</span> = <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><h2 id="Part3-axios实例"><a href="#Part3-axios实例" class="headerlink" title="Part3: axios实例"></a>Part3: axios实例</h2><p><strong>axios 实例创建:</strong>  <code>let aaa = axios.create(&#123;config&#125;)</code><br>局部axios实例创建时配置的 config 为初始化参数配置. 后续还可以通过给实例传递参数进行配置.<br>举例： <code>aaa(&#123;timeout:5000&#125;)</code> 在axios实例基础上，额外配置超时阈值参数。<br><strong>注意：尽量不要用全局axios, 要根据不同应用场景创建局部axios实例.</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> request = (<span class="hljs-keyword">config</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">instance</span> = axios<span class="hljs-variable">.create</span>(&#123;<br>        baseURL: &#x27;http:<span class="hljs-comment">//123.207.32.32:8000&#x27;,</span><br>        method: &#x27;get&#x27;,<br>        timeout: <span class="hljs-number">5000</span>,<br>    &#125;)<br>    <span class="hljs-comment">// 创建的实例返回 Promise 对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">instance</span>(<span class="hljs-keyword">config</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Part4-axios-拦截器"><a href="#Part4-axios-拦截器" class="headerlink" title="Part4: axios 拦截器"></a>Part4: axios 拦截器</h2><p>axios 拦截器又分为<strong>请求拦截器<code>(success/failure)</code>和响应拦截器<code>(success/failure)</code></strong><br>拦截器内又细分为成功拦截和失败拦截两个状态。</p><h3 id="request请求拦截器"><a href="#request请求拦截器" class="headerlink" title="request请求拦截器"></a>request请求拦截器</h3><p>语法：<code>axios实例.interceptors.request.use()</code>   (看源码还有<code>axios实例.interceptors.request.eject()</code>，但暂时没碰到，后续补充)<br>作用：请求拦截器拦截的是网络请求的配置信息(config)<br>参数：<code>.use((config)=&gt;&#123;&#125;,(err)=&gt;&#123;&#125;)</code> 接收两个回调函数作为参数，第一个回调函数传入截获的网络请求配置参数config，第二个回调函数在拦截失败时执行，传入err错误对象。<br><strong>在请求拦截器中，通常执行以下业务需求：</strong></p><ol><li>对config信息预处理</li><li>发送网络请求时,都希望在界面中显示请求图标</li><li>某些网络请求(比如登录(token)),必须携带一些特殊信息.可在请求时拦截,进行判断,若不符合要求则展示相应的错误提示.</li></ol><p><strong>特别注意！！！</strong>：拦截的config对象必须被手动返回，否则config会因为被拦截器拦截，导致无法向后传递。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua">instance.interceptors.request.use(<br>    // 请求拦截器拦截网络请求的配置信息(<span class="hljs-built_in">config</span>),此处<span class="hljs-built_in">config</span>可以随便命名,但最好命名为<span class="hljs-built_in">config</span>,含义更清晰<br>    <span class="hljs-built_in">config</span> =&gt; &#123;<br>        console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">config</span>);<br>        // <span class="hljs-built_in">config</span> 必须被返回,因为拦截器将其拦截,我们做了相应操作后要返回<span class="hljs-built_in">config</span>.<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">config</span><br>    &#125;,<br>    err =&gt; &#123;<br>        console.<span class="hljs-built_in">log</span>(err);<br>    &#125;,<br>)<br></code></pre></td></tr></table></figure><h3 id="response响应拦截器"><a href="#response响应拦截器" class="headerlink" title="response响应拦截器"></a>response响应拦截器</h3><p>语法：<code>axios实例.interceptors.response.use()</code>   (看源码还有<code>axios实例.interceptors.response.eject()</code>，但暂时没碰到，后续补充)<br>作用：响应拦截器拦截网络响应后传递回来的结果对象(result)<br>参数：<code>.use((res)=&gt;&#123;&#125;,(err)=&gt;&#123;&#125;)</code> 接收两个回调函数作为参数，第一个回调函数传入截获的响应结果对象res，第二个回调函数在拦截失败时执行，传入err错误对象。<br><strong>在响应拦截器中，最常执行的是对响应结果的过滤：</strong><br>axios通常会对响应结果做一层自己的包装,包装成一个对象<br>对象内包含(config,data,headers,…)属性,其中真正的网络请求响应数据在 data 中<br>因此平时调用时通常需要 res.data.data 获取,在响应拦截中可对此做一个过滤<br><strong>特别注意！！！</strong>：拦截的res对象必须被手动返回，否则res会因为被拦截器拦截，导致无法向后传递。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">instance.interceptors.response.use(<br>    <span class="hljs-comment">// 响应拦截器拦截网络响应后传递回来的结果对象(result)</span><br>    res =&gt; &#123;<br>        <span class="hljs-built_in">console</span>.log(res);<br>        res = res.data;<br>        <span class="hljs-comment">// 同样需要返回被拦截的 res</span><br>        <span class="hljs-keyword">return</span> res<br>    &#125;,<br>    err =&gt; &#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><h3 id="拦截器练习的完整代码"><a href="#拦截器练习的完整代码" class="headerlink" title="拦截器练习的完整代码"></a>拦截器练习的完整代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> requestInter = <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> instance = axios.create(&#123;<br>        baseURL: <span class="hljs-string">&#x27;http://123.207.32.32:8000&#x27;</span>,<br>        method: <span class="hljs-string">&#x27;get&#x27;</span>,<br>        timeout: <span class="hljs-number">5000</span>,<br>    &#125;)<br><br>    <span class="hljs-comment">// request拦截器: axios实例.interceptors.request.use()</span><br>    instance.interceptors.request.use(<br>        config =&gt; &#123;<br>            <span class="hljs-built_in">console</span>.log(config);<br>            <span class="hljs-comment">// config 必须被返回,因为拦截器将其拦截,我们做了相应操作后要返回config.</span><br>            <span class="hljs-keyword">return</span> config<br>        &#125;,<br>        err =&gt; &#123;<br>            <span class="hljs-built_in">console</span>.log(err);<br>        &#125;,<br>    )<br><br>    <span class="hljs-comment">// response拦截器: axios实例.interceptors.response.use()</span><br>    instance.interceptors.response.use(<br>        <span class="hljs-comment">// 响应拦截器拦截网络响应后传递回来的结果对象(result)</span><br>        res =&gt; &#123;<br>            <span class="hljs-built_in">console</span>.log(res);<br>            res = res.data;<br>            <span class="hljs-comment">// 同样需要返回被拦截的 res</span><br>            <span class="hljs-keyword">return</span> res<br>        &#125;,<br>        err =&gt; &#123;<br>            <span class="hljs-built_in">console</span>.log(err);<br>        &#125;<br>    )<br><br>    <span class="hljs-keyword">return</span> instance(config)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Part5-网络请求结果封装"><a href="#Part5-网络请求结果封装" class="headerlink" title="Part5: 网络请求结果封装"></a>Part5: 网络请求结果封装</h2><p>实际项目中, 通常对所有网络请求进行封装, 有以下几点好处:</p><ol><li>方便管理</li><li>便于维护</li><li>减少项目对第三方框架的依赖(例如axios)</li></ol><p>项目中通常新建 <code>/network</code> 存储网络请求的封装, 不同网络请求方式进行不同的封装</p><p><strong>用函数封装网络请求并导出,项目文件以该函数为入口,传入各项目文件自定义的参数即可.</strong><br>函数封装的要点:</p><ol><li>封装的内容要有复用性, 一些特殊需求用参数代替, 期望调用者自定义传值, 增加代码灵活性</li><li>函数内封装一些公共且固定的配置信息</li><li><strong>函数封装本质上就是通过函数包裹执行代码,以函数名为入口,以函数返回值为出口.</strong></li><li><strong>函数封装过程类似于模块化自定义实现</strong>(开发者调用函数时,不需要知道函数内部操作,只需要配置相应的参数,接收返回值即可).</li></ol><p>举例：<br>封装了一个基础地址为 <a href="http://123.207.32.32:8000/">http://123.207.32.32:8000</a> 的axios实例，并将该实例向外界暴露</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> request = <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> instance = axios.create(&#123;<br>        baseURL: <span class="hljs-string">&#x27;http://123.207.32.32:8000&#x27;</span>,<br>        method: <span class="hljs-string">&#x27;get&#x27;</span>,<br>        timeout: <span class="hljs-number">5000</span>,<br>    &#125;)<br><br>    instance.interceptors.response.use(<br>        res =&gt; res.data,<br>        err =&gt; <span class="hljs-built_in">console</span>.log(err)<br>    )<br><br>    <span class="hljs-keyword">return</span> instance(config)<br>&#125;<br></code></pre></td></tr></table></figure><p>此处又做了进一步的封装，将所有项目用到的自定义网络请求(上面是通用网络请求的封装)封装在一个文件内管理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入了通用的网络请求</span><br><span class="hljs-keyword">import</span> &#123;request&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./request&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getHomeMultidata = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 通用请求的使用</span><br>    <span class="hljs-keyword">return</span> request(&#123;<br>        url: <span class="hljs-string">&#x27;/home/multidata&#x27;</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>axios</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里DIN(Deep Interest Network)阅读笔记</title>
    <link href="/2021/03/12/DeepInterestNetwork/"/>
    <url>/2021/03/12/DeepInterestNetwork/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 试试笔者的生日？" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0753ae5a3ff94c191d804eb756493e8cd6fcce99793b5719bea92779ea5b6c05">bda6ad0d5f606e7055c23f770369041fc566bf063be9d0864f3ead6d04288c1b23c6893ebb3d1aaa04c3b04844a5d626c3b4da1bae810875ef8cd64ecbf63998e63b9403adb08901a44ad950f92c50cc5437967393ff9b694ececd6a28839ee428228f2838d83060f8c9935ee9463d298de5beec78ef7c3197a84a30237bc6d01195141344e8042e52b09291fb14de773faf1e8d2992bed49e42aeacf6522046ae210b17235d2005f16a0d557c8b6f3fe44768602716824716e9c45074fb26ec17c681112401d09778b9077b4617b08b755cb29dc985509c3a12ac772344d8cbd9235d8314a080e56fcb8db8254a6970cb205bd8020c200cc8e062525115d478cbf6747d07927f8ebbf5880bc9b8d9cdf507982c1384dce959bd7b32838b1d22663913e0818abe609339e08720b8eaebf4e77239fef57140d1a410c74679d5d811055fe1a57b45fffcc888128633dcd50536f3045fc01c051e8b63c68321934d68e7555c63ef521bda238eb27bd6ede81b02f1b1d9657f036779cbe39c91776927b4dd3675fc0618f5561800e5df5e5c299899dc3514321db1b32044e6d9227589a89f2c97fca77f5027360a19b2aea930cec73ccec2a716d6eb9579e118c0f9f1b68dd41a457484476200a46a64b23862cca14dabbaba42c8f8292378aca248e89b0e5c81ba67e0f260d53f2743f19217817775c8f7d1a6ebc634209ca68af4f1907451fc2822f224c9200453999f3334f0d810e8631dd3da854a19e395f895878fbb1b2a86141bd8c7e82e29d539e30501d81ed9a4ebe0fd692f55bb1ec4a2caecba9d8f2b0c1e10da30dbfa1ce9033d64623a70619bc8cc4007258a5d17504d40f8ca3a1d5b284835453badbb10639416ac6ce8f619d32df3ae171ca88697f17829b38fa2d08940798926734514608fe82f628c41379df99106bb80b3a21a30f302077579dc8b3059b5e308282b8751720fd4c5294b683a1b3b733f526de53d81e5e76c11ca75207267697c6be7fd6d4fab4b01b38ec71a116128e9ac373234a3293415b2fb51d09e6a213ada150e2a4530aeee4e7e7768651d8c2f1c79f613d35153c24707e223dad1e193fad250b28db9de05c8e351c1be499bbb9a3052ac679a4f502ab09caf437b69fee63ed1f4a0d6b1c0e64e603af3958e4db41338c15cc74e9aa56c640efb84e96755b91453ac92a18d3ec9aee97860c83d1789e90d921a5d2952269f9e388af647d83868c68be557a9a04ad467a52a0d5199b70ec2e2a9deee64de6c60b22206a8290c361b3aece26615bf58ee5f1e9853b66687815f56b138dc277943a739b9837183a79cd680b6744953a264b01baecf11b57cfc527b7e4cd9ac2f93f1d257f231964204a8cf7416b22e37258dec6f009a60b17f373d5ec21f399c4f9684dc3c60020052f7bc7d046cef1f06fdcc946115098c8ca5a6cb2d2a0e59183389140bf74d4fc666ae61c2ea96671f6e892792551adef18d6d6fc1ccf99b918ef9fd0c4b1b796ac9c8ab99c733c50c940644e3f69f0de7f6da3a5ec8318c1476755dd9e04a45d952cb05ac2eb88d71d9fda8d22f85ae590fb8de01681722171baee7b99c3099cb095d3d51235821d7218e2280e13b89f68db15a35edf29bbba157257548dd6f66ff9efaccfddbca7da6595b3180fb22d7271bdbd8d4b0bc8f9d25f9af7450737b1409d87dbdb8e7ba516d2b5a32eb0e01b7acb121ff7f19e2fe1eee7be02bc8e137405e88869387f4a8a589cc706e6afa183fcac4d607845a53d87b29adf6822a07a25c1835af7594317f2eaa1f9798c06d0b14b2ed569fb19f827209dc32058ea059ac335461c42de7935889ff5e786fb9ef46f3a0f7590773578f90ed714a4899321d45e2ceb8e9aa1a552ab191b1f961cb46e11e53c824500e4b16392c9b84493f737fde6a63ba65e160484999db29570f21ef05f2d11ec26c755c000a1d8ebbce184a3a06016cd1ff9588fe9da400836d562dcfdb0ec918ea5f0d9bd1df70705eb7ca77708c4694997bbff742f903ca50548a075bda9d2d0f3a880fd14816884551a0606375e6ec1c2ae27f785ffdc0d2d74aec30fd8bef2badfc9515e9d4391d2ad2586708bf97fc9606b318a9cdc93af860260f16f7ce2b82a60b4634a80b9cb3e0e2d85212181aa81097824524fb47ed5bbdc6c084be9e86f54bafdb372a5e222545a97ed04c97377ad02d6419666e9602e75de94ea56a3d6348885541681c801afe5c0f7ad1f83de1c6e3ccfc92124085307a4a90fb5ec0ece930258d4e6f2e83d950e89a6427486fca19d9495afd150e03fe056861afb449d2277cbe617e48ddb1266903748152127c5d53b357defba1c8905f17c88a8c57b68684d0c598923513e2dd550430db87aa9c54cca29295c44df28cc74f1b66fb62981a7ab78ac36db38c9fc42ca557d2311cc6f72ddede14785e2cd8c1ce14a3ea15736c79fa6a37d4252cd7cb8f37d149ca5e9580e5f6c40eb4ea3027c35c1f18125cb9a04ceadca35dc261f25ed945122d287de8ed40bdc6af489758fb75ec02a999f333c11fb23e3c2ba2993dd7015176695788022b1035bdd1b66a8a510cdbbd703866e10fe4ed1403814e1b0d1a174e7e0698a83b070ca28fd468c76dd5d960e5249d219a3fc56f945c3fde02baab95accefdc9bf58da2a1b1d7bd3dbff2f0106d60cb615957c94ce6b0a48035cb95822bef8ee3794b8f7ac485d9c3b220470a740521cc4786601efbec6102d28a9ab0d6bfb7ef98239135a7e5cd70bd7994031f9e44245a50446711a44a9fc51f78085ee75229869537db4d69253ec00d617f2d41a195d5fc27f2c7185cb506de637be3538588c372a8b2b4c1782176eab56d0182c1fab8c6c54484c051c55f2b32a221b1f37226060f7e2249598b1998bc404518272e6977bb8771f740e476c54bf58c38fc8e99659723dc7d9b4eb830392bb5208464214b10344953ab737e7240f14a7e73fae4b02c38874167a6e7808213613ca80b4407c2582695157fb59682a3fa04cb8fcc030dc8fc8cff5fb4a14b913029bc7d4354ee1cd858804e09630a693564892d2b948c081ceab0e281ec73a9f1f639eeb6032cb55351a9f346be9fb5d52473da5065a991eed6a0ab91958ed2cfa4c2ebd8efa944e72ba52535266927f681876aa8de8dab4dba05da09e06d8c1f8859cd91151837876a8909e5fbafca9d2c0f6e466d357572cc70a2db5aafa2d9d5804a86c8cf49c9d0f4b472c6cc80aa3d562f1573862305d02bf842efd6b627b638f722bb354fbe2dd5abafd0184c2c93d6fe07c99b236478fbe6b837144e4a02f3730e52cfc642df8cb0fbc91d1ba5eedab2e32c897a7b9eeae00b9ad878467696bc48505e0e8166cf8d08aaaf08bd069f059df103a9e423dfe857cbc9643e946c4167f598dbc73b4b55e22427bd227ffa436f225015c26057f4def82c4d792f159cb9a8f685a6b5c97f45eab070351108878783ac855d8ccb0bc88530d5f5b9c01e183badf133787878280d4525bed49f27c03ca4cbceffd3e6bebfbe7957682045a9bf0cf0c876a4c80f94a40014521ed2c16017db3717b8414f191f7055df693242ecbfbd781fdf0aafc6388be4af13537870833741e5008d0964d6bea1e2c00d73574c9c4e49d381212cecceb07710c8116e9487a23fe887288cf39cbdade757036a193e8260dd31fb07f23315802f51e26aeb97f3c9618dad8c9ade52769f52554b2719ed9440e81d2d7831828e27cfdb1354db52bf033604b5106968bb1d45d26f60210cc23585e1deeceae2bd96f21754db54c0a4d7c98b8e994d6ed2e0c9698559432ae700f8564b974589cdceeabe09815735ea506c309cd9e70db3d648b7fb1ad39534ce4e933c6a65bbff5fe926ad9f1213b81b1bdf40fdfdfc6039fd593552816d41da3938b6b5c27ec55ebad52c7554d5ebf960db31b87be83b9e3b0a57a125e92e823ed422664eec1a78543794a2f81161fa3ec3f54ff6bb3d7391751442ee5bc30649ecfc572317d6259b1c321810c45e2920d88fbf50797a7bf6e6109510eb06fd209537ae372984b6973c627eb2a5a3ff7f5dd36351b072d82ec0521e56988305e0590b937ef67f84a85104944dabe697535bb2254a4ad622cafbca3f06033d60b20255796fe9c29e506c152343dee6e858aae2a4096b7b909911aeb769daa929e7ca9ea790ec064a14e4bf16c5b1845a9d8c8ee3cfa99b97cfe047edd935979da1e6e3e1f386765fc608816e64ed960f104a3f07c398c579131b6474f7284afc36c4be1524a23c179b967cd907638754408a74639906fccccdf75ea17bfbe45843d287232f4f38125220df254b4ce96fef87839b3bab7e9875d95c5409e9c627629c9698974824bb7deaed2beb9a633c90b152283918654f940fb73895c21629e877a79bdbb491825fd363655d4761bf5192295804cfd2a0b7fe76431227f77a1766d49eeaedbe1ae11ffb618edea0c777bd7200efa0a467b300dc50a993a0ea92c89114cb5aa973db0d0f24fe790fe9eb11b764098b1a63c0f931ac95ac6b9f95dc8881c2146f9b1bba1a98bf21ab26d83c5c7802775cab11b80c2934c907becb4400c1a615ea6aa8ae18f25ca06e661e9266fc2348fb43d672a00b79c1b1b2b85b8ff88dcd14ca9ba40b4bf28310eefd7fff4ee19c33439ab6424d8d0bef2dc4af7e4132fff5bc927f41f2ca45fa27aabb78ad4c7bb5d8189a974cd3a19025d1a747eb9aa9653caa0ddbdf7bc381140fcf2d1c5f8c3689b36f9abbf2dd986b97f25a9ec7fd6a8909f0251226021286a58205a6c81293e007325945847b28c6a4f3d31d61488ee5268b5d7055117c5d7be90e8190a19dae24918b22fc36ca365ed52cbc04bfc8ce060ad5bd4f8d5495a17d98f9cd44a5e6c1c6b37aad3be5d490453a9e2ae2a5ed4732c71b7dd3b917c5177dc81b3f780a843926992d494737084d30acb03e571b544299b9428a3994322b0d8eeec2b810695e6047bcd5faae9423bbe44fc2453f4187d7589d942f2ce907e6906d8ab02a4a709a1768f5aca2431ac87cbff459e0438cc8922aaf67ff6e8b743437d3e9d5ca20c918ddbd8908c44a9dd07150d8af39538aae13864c2358b37d7bbb9ba59ab3ae0dc5ec3dfdffdfc15cca8d5b0277540362e5a59a09bb2b579b0efe83e57d9d884dc7f95a07466c939e59a23498ce88017190d41c609c519a0bf716468e66379b6415dfeab2e3c771b50f01599e41c9135e47736bd4770b2ae15f2ced7aa294100dc9c73553a91563818d6a06d0cb3e4d513fa33b8487ad87b0f4f4eca7b009b3f18509a8ad78d13ebc81d37b1152fb78b55733c81af1bc1c7499095200ebb84885b409c79c091666977e41aaa748275f7e90f2d4079f55646ec2c15fddca0e1839d46525d0f5a707c8b24dfcda7965606b472bd7c7a8a033d4eb0ab8f80f324456a3d4fe935a78768ee751b83f8c8a52e4c5d377dfd73bf97b853bcf4c24ba6ebc19064a301bc58dca4367a6b2391697ca834795e8f1f38f17432b8fe9faf950679452100213e38799929d4be6732dec3d253cd2700704bf6a4ab4ab7148b55498f64f196cc15693f9a9fcf0c7be80cd73758819f54f3f36fe15040fd576c2770907b0a26f3f0b8906cc7a3f3a0c8274e646f0c76a36c14c20e8123eb400f9da8a7296cffbad14e6cf00c1fca3cca3726fc32ab393df3bcf1da948507473377987afbc3a723e813b35d6dbe3ffee482ae0aa2363fe2d42faf1c5fa7dc506d58c4eb0a1cff2b9e239555f4d48122209a47f92143d685dae7d43d935555bea463473e79a069492598848145689d66e6329568eb2d677341b41ede65a77253e265f170060c43e37581b794169b18a52aec523c0ab8aed87fdc81a67ebc16de3b23f3c948b6b77db0aff3ff728e99e57e9ca7ade69a292a437c884b094e8e6640764c011644f6bffcfdffe3ecd35792e3c48a941eef22a5092d27f2a408eb4fb21a0d34d05af4c1fbe84ed97b7b61385fad3b034b3d65f08c6ee61e7d6a8a50518b91dc5dc856560dc93b2121053674b2a8a6f52d72a61820acbf9d36afbc0be31a04ca974913cc3439bbbb23faebec45e9c70057aeaaa1b2ae961e86d16c8ddd9cd04e30053ca2caf704bad58d2bf059b1808adce8cabbb957bd71f87dd98cd0393cfc4343dd5897d61b212568949df1ac5d7e412d1dd50ab3c6a2d43506bdc805b916bb35b93b617bad715e790b4fd1282b93eda6a891c6cd0f106aedb541ed3f8478c24727eb3e9b187e75930d88567f7d0cfa0ed0aa02b7d6307cff730432273403c5fc1443f1cf26b31fe8fdad165b1cec1fbe5323acd0a29bef040033a134b1ca15bfae8545ea64c2b89e2085c630f7d707fcbfa2171b51df23d56b9b74cb089ddaad1807730f549cd4b98756294da6c7a95d2559ccdee1639094f2186e7460b4523d00a5d2b48b88843c1a5de9f827e32f1df0ace3facd08bb16e5baeb4cba144296cc868c199aff8cf8bdfdc05608b23c3e9a6674146a951f03185c8bfc4e83defb473b1f82066599d624c9ef53d1a73b87f0fe362952466f90b26062bbc9dd49225d9ec054f5847ea0d1a640615d85660c94c35bde3e2065349e8b50c29816049364a75cb6bd188c068e0d455760713714d407e0788813adcf37861c2dcc5cb48434e6b3ee0e4cf09d24ac7fdee7293c4531fa0ac3c51b864246c8a92ae74fceb702e6d92009d98c14f7a4ff58cc5fab57515b2719a87a243a11ca40920386e369110240644e00cc090f69fcb31f6aa598904414db61a2c10a8854404801f75e9279bd4c9eaf3c8c69b67378022b29d6dc40df862039c5dbd7716242eddcd4e14b0c068e45d1cab31db521ebd52523f525beafb8f8972f468a5ffb88ae5ff92cc9b33cf6ff6f99d6705650ccc011d2a768c06158a3049a3d43f450c734ba0c399d7f8ea832ca146c4aeb8076157c5e78216c776209b647e71efa463039ef5ae8994420c48bbf55220d6e4473d863d11ede73b701637cc41f2a248f5eb0ee0ea2f1379dad33e8aeff91ac47d810ebc6e657ba8969980c11c1a360300aa7334ca65aca532648dff2efd8c4d2e4e25b1a4e8bf14f66595c38c59d76253e87d19d208e2530a93f0b60486ca5d6deb5dee6da3025877d5e05729ef373c493dbdbebe3cd6d9140985477545aa0505a369662fb1989019c43aa744f0fe519bf45ffb1a5ba9c81fa117646ae2240602a4d6ffc40ec006f6401edd9c8d01ef280af0d1f82b08f9157b0dfa3ed6f14b7ad47addcd67ed91fff56eb41c07917e8033666a5fa03457ffb4b50a28783417b19fbb109d818d8f140d82e7b386d01f34910e38e546b1be3ed99b5d6d2a60eb539bcc0fa12f2a9f8d6f1e45f1b9b8f2eaebc24c9c03cc77ea03cfc8d002672b856cacab776b70cdb27bf5045af39f6932109f67bdad05d24b1d320685008368fccaf7378a033f2a6a60ba39da6c4d8b6cdcedf759dd67af84ddc47cfe5a0d8909ad76f7b4ec89bcc5b7bb4ca64eeeaaf8d55a0d21fb739bc61ba8e6b0aa9b0ee48a14629ea34d1e9fbfcb0c3b37ba1b5710d1d7b439b4233044be768f589366627af238b4d68d23e2d10fc80a568526585ad438dbe00e05638a9328f26b9893efc42390b26f2f0f112bac2c2a13ea166fe809d8eb4ae7f9b48d8302f812ea601c7afd62ebd66554f3e2918b16bc779dce29fb870f8b2655217d1f7a873d1a7376d5c38a36207b8be851fdaceeaef8b5deec9699bcaceaca91a841a953cffd2451c58b13f695bae6130a00ac7c25b82c10b924c1c477ec0ea0338547c6706a645ffe0fcc5d310a259799ef8ec39e8a5bcac56f84036877a381414c1565c14b39524e546fca9832ba48556113c89ebb572146fe8fbeffb7e57bf28ef8dcc2d60d92cbfc415df1c2fc77a4ce87c264f54ff00a52abf88894f77ea4432e0aca1da0fe28d10306405f662a0fb68344e2a006ba3fc31c6a23f6052936c1b7a6de2274db710653941af5457c44420fda29cd5d4ec9aaa0a2837f2f5e8577af4cf4e8c809c8fc2e2b266134296636b9ceb6ca2de545b03b113451a2a5ecbb82737c532734a946ac1c9404c142631247eb7818d1a70539064ff2de0721177a5bc5de975bd6d95d01ca889df4fc1d3f2541ef22f01cedc5f25ee84bcf596976cca64d1369f722ded7daa8868a6d759383bce48bf1b237ea70b1c4940ab4deb2c45c591d278a055057b9366d6ce9b9f74af0ec974af719eb6952af2682aeaf3c0a4ba887e9cd504eec09e7ee96ba14b000bf71d2f63c5711e621daab2550a1654f42e07a17dd7d67830c5dacd5cc10dae7c1a683d50e41a71a0c596f26e213a9ee0cd320d606ced43d6104a7552e84ddc52178ba89c399c4b25547ea0c189537082f5307a23b61ddf7dd9f6be84c47bb159221cdf9978de86c82aed9482fbc10beb69c4877d665f84de39bbad6b5e7e64348f947f03cb1b9386627ae0441ed6749a6a21d38b6144782c38d5a6a2ce5e263ec51246bffe6876623bbbd45b38f9851598afbc7998790f67f9be2657a45c86423b6e55d30ac8ef5a923f0dfb1ad1976ccb2183c957d2b79ec55c11b987d4b818128e714c6cb6cfa31986722ab1ed52cf5b675f2e8ad71d04bbe9070f0d6ef26b015e05b5f15b7d52b7cacdc6ea6069673e36509ffdfff9b0da62cb489cc219a3787d96b9634b394c33a9197022f44e4ce5946e2cffddb58dfab81e504dee86ba6523a0cd32513fb1d57aa4596eb25f638598cd9e23f15181a2895695746301476269eecc536154940e39e2afa550bc8abb42ed92c357c86d4398c658f9e49c914b9abca7776efb05b0ca6622d9f9556c584024cd8ee8037e2aac6f52d9f49dab15ab1311a94dbed74f47bcc3301cce9ede728473a376858604d61a1f6dd6c3b5c393dca92e5e4a5349cd995f785a73f1c384346ca9ede9dac8c9b9a1bf3d90b739be12778805ea6e7d67da687deda95a8648dee7ea2aec9d2e3a45e8ee9071a2fab9d3c4557741baeff6336b4cbc5d780ef494781e7be61f6eb9dc87f37609fe151f6db259a50a9d621dc99c302b36b8003f3573fc9d766bafcae706c0482935aaed2413fc0a36646437beda2750c48d9ef91275513077742ed9948215414f3fa4a8203f3f2f361c6e00141e42ae6a53505f9bb46ec99a4023ed576be0385aefff21835929b60baeb09dbe32a4009ebb2f530b7746b4ccb6b6b753c428e45e294a034ab6309e1a5c577bb0aa67cd3e5f3516388a1153ce0ae76b2c11062bbe07ec931ca0ca587a5c9467488f6b8dac4e1db005857c032228a4af8b77420f80c8dfb30b90cc07ee7d94c673e9826f7c418b5579761eb8acb232d676bbfc050f919f0928a37358d84c6615ee0a93f3f0086503a03321590fba05625ae057c9e62d431b2761ca4c6b66e2d8671d1f1ecf86497611aa0bf37fa5dd3d054c0c71932607a54da75afbfa54ff5d6eb6624e26ed3a87f99647689e5e2ff0c8b732d8754046b3b195e5fb8aacd919a81e2a7051489e8dec60a146616baaaa9d39a31ecbcf8f24c071b4c2e99f3170c04ba5e20da701737d1d61a626d0f9a8e9985731cf47551e790afbc74c9ce788a159c403e85eff08a95ca093528573ac8b5a4e6704a6a61ac6e0b11f9c24b68d657e5bfccf8e2df051237f1833b68abd587c719e5597796e4a800e574d72713630b1ab9680c25d8defcedc9266792b84a58d81dc70a3feac7de92bbb5ef9225b661d426d3d4874d2992df6b35cf308daefde6e3055bc0519db1a0a260bb5af6d60c4de0b7d1d2506a03e6027b1b1c75e004b5df29cde352929479a68ebcfa86ad91d00d94a32f3bd3482383168f0daeb6e6da16a0ae148d33f458acdaeeb9690d4055a6ea7558790cc11b4d238f6a90413217cde3468f27cb38bfce263fa5433b535e3562d692e072336f958c0afa4bba78a42e25a04b4918383d1c05f918ac58b80d9dc0d46d39bb70c43394e13679625e358892fb06bb8baa7ad597485214422d16067d25a67d36aa61ef1c689859e0d0472feaf14c86418fa7091cb3fcadb4f4d04e1c99b6fd573d09d944996b7037a4a080172d5994b170ab4af90c52f016ce49340c6446da68df5a3e6b38b62b6b11e8e70d937392e95e0d80b89ea26b630a56d2ba153f01fe3180ec37f66e5fe0a6778a8a716f35b957b971aae575e4b02931069fecbc8f14124007dc5546b9034e2b35d5e78b9c1553f0ccec7da7ceacb453d796d92024ff575d68a8f1010c640f17df4f8157660262b01669add6dee9514c73b1df52a6f1197b1a10f3dfdc393abd93ccdbb8b26d1fcc639ab0d93716b48a45cb5ee1e8bc3886e4178a75509080ba2d1011f834a0ed3e82f42a4636b71fedd16680976e5faeafd7ba7fe62432613f29c1c2e931b532122d5ea25f3b151e1622e77196de6a032c646c894f5141c096ae419fec377b3e0d6022a11570f6da344af2ab6750951cbb276122a470ec6701d6d731440b08b16c68d9c445d320ac6d74fc8107a1173cb3aedc8cc1a8ec25968762af362f40ed7d88e6d4a89a0c00a0c4974bbfb385a3488452a3d655569e387b27d56f2b218cefcf59776efd6b18a135db09c6d0262d482c02cf445d9f08d898a604fd678357e83229b19099750a7b349093a2c42039ff3b7b44109e9265e240dc2ad070a6998da01b68a1d4c475e9593218d4a1362abe7f56de131b327563cd69b3ca5e60cdce91d7fa076327f911cd4f7e3279db57d70c1c5bbb7cc044ed416399b9791df707c17bc7b512be15c67a19a724c13b3d3fb09f99e2f24a39655853ea494eb68fd7327dfbd310207909c47bf3b4198d4e9595d770dcf1a9aa089afec0fc58c106ce7955574e11a1f79577cabaa57572900c3b337e11840a318c6c59326dc47cb3f22ad418306d5c82b3a76717ce5138b1ca05141e6632de8b17f73733e6e8bb6c5f07adbdda803699c721ff7c46400ce4e18d11f593a9e4d3b16bec20f6b41ff815348f32703f1b31d9779d944f71d0a81e57db7b2284f674a6fd7c205dfb538ce25ccbdfad54cfe982cf6e666e56d08cd4bfd6cb20400a44e31e32887361a9975110dfaed202ba9ac7340a4d01c1ed27ef1d270115494673e41a59b2d6c2125603582ac6659beac2e0dd2edd69f17983438aa43bd997b20f5c9e97174f91af2bff9275fc53c9627f5c29a33628c2aadd3cc2f3ab1d3ea882a66ced4ec5af78e3982e92b8efb046c6379ccd1eaaddd4c8f1596fa515a9bb09a2899cf99b39650bc2e8449f00a6c9ba729170210a3f684b719a9a9b37ffe62e41e913ea5a045e1de986727ac799b19644689f4d5749ef359aea3d6ee049c20b6d8f04f5bc63147db86b4b8e5171cbb352f25f1ed59bcd3ec04f317dbbbbb130832cf5ea717060258e198864e0d8ee5aba88c423da9dd69e7255d4d80d6a2e1448a616a99ecb12d86ac911ac8ee5ea548e4a2526bd215492868675d7c9307d31cb6944455fecc411d6d8b0a143c04eaf54f48625427e4ec77d9022b90e83699e309f4f34c54921db0a45057429597e4f1dde7e3efec8de18b92f72ab349ccf0625d90eefac0e00a35796385ff860fba2dd69a804931f892ca2cfc6e75c2b220f0d659373112c8d6c11780995d7a13c1a129f7503fdd6e674c30e300d638e3ec43ddb273e2c92803130bc66c6176b185e9728beb4b562889123a851324912ed407e4e9e2b9a18b92309e9694b746de7e9708a8fcc427d82d5afbffc634d10574cc1cf25ea1dda43ae6c370de01acf8f75fb8d0041f4cebb97b28293a3e0fade34061f764a1c7a4b6025011769bbd3c9ec4151381935efb053a9c3cc109ea1f589dd862125c90455e1d137f187698b8835d3421dc742076a859b2acbe1b4259dd36dbb2f4ba00b322dfcb6fc96593cddd634f6a4d544e605cc86c77be6cbd4a03cc7dbd6f47aec372b82feaf7592abb2d8f6464fa673cadb27618ebf0ead3bbad52b83a48a728726b297b0a7e9d7360340e7e255f8dde0f04ec5842fdfb6908f848ea668930d5e6539680d35323ce81f30d66a0054fab6b68977dd6320c7927806e45f2f25298832ea3daa82c41986b8d07a6eaf9f9ca5a846b7eb3ad55ae04c1acfcaffe2340712c644f7457ccbf35544cb416e17314a7ff2212055b5d63df04bd89c2a5a3d0b3a1e28eceb8b3a6b6252df340795b2d18b9b4964f8a230a8f76f82d62c185c736bd8f5e3ae63c974cc739d69bba25c0b4df92bd0a7fc16855f1f80f172b6df310305b7ed5abf4ed5970ff8d216a8c810f2f84b1a02608be0da5fe6fabce86183ec8472138561311a54f55f016bed739c2edaad9e668e2f20eeb86e00df852efc96b458d44479dc8f50495335cfbcf8d55e09bbc92d51a94b6d15731ddfbae090b11d62d26b8b6810085eb44270838ffdca2f4cf0830241c8a4b27a11672b6977e69347baed20f53db5d05b3e5bfb1dca1fecb8cff361b59d04d9515222a76fff426facb4aba3343d2ccd51232649f35b3ec60289cbde1c62894feabd9fbed068c280d345cddf139b0b8d5110800c63b3881520920ed3d7067c74c905e53dfb1d3acc5da2d12444575fc7251ee9159764c80a4cf309329740c62292750601f99aebbd98879c1519648d76b499b406b434f771f1d9de8c7ca4ea3db29e9a76e08daf65da3f42bf66aaa74e17d866a33ebf7ac5703068494349080481bb36014d68f91a4c6051ef6e5f613f52f452e09d634331d6c212738ba2f3418e1e11a42ebc522b775aeb32c2a1dbddb1fcd5533012187372a0837f4629f94d3a3ad076569ede93aa0d4622248337c697c936a113d7054eb9ca67b7477b47061e1d775dd9f3a45d4d61a81bf38d2e46a62e71a383fba7fd631739717f1b0db685fae520f482c87bc38d68b672dcc59280db2a69b2147a62fa63d3950a2c5d616c68b624ecade07c8e96fd7830bd0eda4c6e66a45942375edece6ea69edd9cda3da49ec4f00beabae6b72290bf9f4c828a0c3b093225c88dcf49c077a6b5df2b3f8413837355dc83bc8b3e6e43ef391331ec30d3a7aafb6d771b9ed1a46f202a8e9064f3ffe2e20807f70c34233b1ac7d40891f79dffaa7ab51f10b5fdf599489d0442c225c69ff8ae95ce6d1f8d2bce00b828c31a785647448f543562bd24f9963c7874fa7c4b782bbb562465246df71b7bcf5d2fe32df04bd817dfc255badd78241898356297a1bd8c2689b546b56f26cace78917718aa488103e0927b267dc4d22b6a150a09193ce5016f3308b539acaa8952fe298951ff55a00270d292da4e646d389673834aa89b5f78835bd3a580c24c3d18c9a6aa9fb0125d85d35059e980f1df016bedfff1434c200de2520208a169ff588b6e88874da7510ae10acfe30ce8b8a3866e6f8045ca710ae46c205dbc28ef1292192f107f4cb7587905b50078cd0f98acc701c88110d4d4a565a1638abc2129163ba3b378cc3ab01493d2b35103908929348795d1fbdf2fd6f32c49276e1198d8164260d180ea5216cd07d55b7ef2bcda4562af1a89767f1d2b668a6617d196d8bc56d4947feb0a4dc86b4918aba6e6c41dfaaf240b6618de941a8aee993f1e710d7bd73ca11f30df25407e7fcd7b80e315b9951dca39af042e16029ed5af36c1fa65f2dc673d15f3a5aaebae0ddf17723a03d7fffeb0e8ad82c8e3da06401e8737cf34a7df011187e357813ffcdd676656bbcd14762bd0eda03d22c24f3fd1fc43c87f64c7d5e9e72636f8bf2d1e341cef3e55068e45e7c06e84028a08a30bdbacc999ab722da81126b5022d38819132dc6ad06127f6efe94ee753c9df92f04d964f20051cf15e586110dc832562039c57c22cdd07f181e56009e64139b808785d601a9115b815b77d315168b2407d44e49751d1c7baaad53e332a2e3cc6bfc08b45b620b432ffb8d47e7d61388e6851398b880feccb956fb8f16b99acb00515c8b8b434a419262e1bdfb513809ee494ad59d60d9791f3a0888c5afa33b959cf0151ac73f91cc0899904b8fc23a5fc6733dceeeefdc01be325ffec4a6f94308c6d577c15c9b1d5b1bf32e20e747e862fbb8e7c2d60e0fc35e96eb5b23ed785911e45321f80e956983ad6a888ea6fd1e04d70cebe3e4fd9f965c440eeaad1638a2558ad81b98a5bf67c59a0a7b1252c6ad49f8365bfb60b19831083bf7d806a1a77809397da8d74afa7e2e95d25bb423ba53f50b7693868b62ad3f85aa52f483ff0319303a6e34e08ea2a5a7923110b6004065004ecd176db9f9f82fdf5c5b61035f78457312e28c463fdf119015b7182a0d17d32d9aac30955623ac9c25c0f326c4c9d17f350730b419c223f3a12bcaaad59dcac4f77b32cabf076552261aac3cb8f281153932f23c25dfabb5f390209f98b18ec647e5b1f14720862e193f5b89c54fcf794a012003a826856e637394b37d07d4fa0f56afc35460026b21fe770e1c3fc587b5c94533b123ebc17aaa219547968cdc131b85b84f2c0acc913c2e4e333f93c9d7cf5a1fe54082bff1d6c16837907da6ed19e15eec478d3ae21df8610ac262cd38544604d611d4ae1ff53729299a7272320845f74c7dbbfecbfbbfa49e90a4dd2880e8ce57d033695bac9a06581b57854cef8c307125fee70a2c9100cd147461c8794ad33d0e7bdbe5b2ff0628cea456cb63244b36caca15fd339a60803a88fb74d913444f3833df35b8f377bb9d0a980f60769b104d314d77b10a2adab4ec95daf09957d89a392bb73f56b492fef5f445781c308458c60f74d3048e4f9db215bbc50b97aabd10641e88cb587c163625786e9ceacffa00fe45ad4b80a54b298713386319e655117cfb878251920d58263d474723cb4d2f1bbe2f97bc11dc023ed9aee87fca4680b198f3ba352ebfcbd931f9f900581adaccc4efcb868d50726f2b0c0cab517ceb1de94b214ca08ae8e7d4e4bbae49948c302aee8e232216bb31d89862a2e162ed5b4acab669cabc3088d512414d39d2fdb29af528614274268146fb290bd3bea2c7dbe545715c7716b16ff035899e82bd1a0c55b3cfa28ddbc4937a41fd48c1120efad2429d0a4b9f6a4a96d80f901a0f84f379326a10dda6e7a255033c3305bd38ffb485156aa27b3e3e52c717c31a178cf540f13f0ce00b84a61a412671ceaa78bf5b0df3626dbd7c31cb320373e04e24019352e36211d533076930a9a429b8dfb39527c5c97a78e7e30d76b4802e4431fd77a78130be8c6d4c68fb0a36048336f715a916cecd725b59f3b9cbcf33b0355ebbbc8415dc773caefbcd77df053837f38ffe90f2a9e4cf4ffa7485b05b2f7c1020a0df25cb5d64feb5ecd6d6312ea9bb209001be065e5d21f47025753e8375cafc11142ebd9b1c7be548b96e1e4462a32fb5e04fc9c7e3d3cb3d72face89c73e549c9eb2efecaa4e6ba49a23f48ee5005abbabbaa657defb63d0302c10fbcc6cc6dd9165e4f0858ad8da075d0864c86a352f9cb49514e12b81f80c7aafe2842f90ae4be6ae34625278e2c5336ae92e912bad2087be68d815f8bd92d95c9bed03315c4d0ba74ca4e9e6115c6634be3139b5826af308290318787dba39af2bfe50e0151d974fbd5cc21a0a93fcd58accc22ac97ed935e27fcfdf295797bd535d8c01ce89c1a09ebfcda03236ebdbec68e7f411843d3dba786b380ddcc104e00225836aedc1b9bcd6ad8c2c9619bb563c4cebe295018116c4a62018e7424fe285c6c90e9095953cd0183bcfb6e31a50fedc5578de6cee1b2a2c67dcf29f2513e596b802972aa07a75ac3a7a8e712c8d15574907f1517e96322260ef57ca1b7e0758a6f7cbde2db99944390c4cb0929b0342a251e9162dea1317771a7c71eb90f234acb9ddef6cd8042616f071168e3aaa0a46c94498d6215f105184bcfaa8705679d3981dba21101197b8e1c9b0a12c249becdaaf3acfa02bfbc6c496d29568918f45768d3cbfeaeb82638f364d399cd402b68f1e5572a082fa0e5b2b1c01b98c14ad0ce690940f91c275ed583ccfc3fe64342fc6c7b885fbe26550026bb757ff9f685e8bc3e0e7aaa88eae26612a83fa8bf15c95a0966a60ccf237c020c8737796dc7f0e5f11ba9035475fba7a5ba81c11648c248dccf06550cd77298ec7c49ee49d4c9c384ceb492692c1ea36bbd722479985fd17e7cf04870c3753d078a1c30601bb949fb349c5ca4f5f0f0c7fa113bd2cbde274220a7b5dbb37804de2e619c4a48cf6357fabd9bf8b95e343d2ff2ca4ad0e62488acf15124c9ff183270fc60b4d466b903e4ce24b4d3a881f4c2bf5385793efcc08d4d1dbcf1077f16b1119cf239c32d4e0927ecd7adef0b98b9412fa4eea8ce993b33f14deabfaa5d3c6122f3580005b63a62c25c7be1f215d3f47742416b6775d193c56caa74650a2894560f1c706c62f53124b133fac9c7dda450975da4152ff29c312168770bb0f131b886c55e657cfe4057895041374ed04ac05844bffb3d4f12303dd7ee887f5d416159c0679b41e3b24ea9d30a836fb92007c26cc5070c1f93446d4cbcf77fa7cd02c4f1ef9824558824af3dd77fccfc803446ccaaa81e2dc1f9eb11ebb2eb67c393e401b99b097e4c70524c87117f15cdf1aaae780ada0e405cd1db340f695c0657aa16f3b037643307332beb0a7fdfbaaaf80a6149067989d0b740249cb8c2a12b1a57ccb7cc6745beedf192c5a02c8ee4dce6993d241682ce8b51ebdb7aafa85e218902e4e941ef386103592599cc60576d95eb1844bee4d049437ab6d282fe0478a5ab2baa33940f6bec1a7885f939726e41176bc6c278dc3152489ca6d37f4c5efd0d76b09aee84f80768d28c28932dba24e8fae5cbb988ffdcb517893890f8e8698f560882ceb3d3aea3307ac0732cb3396d3f8b01b1b7480be429ce1dba513aff3667a9c0f29416ad676e819f506fcc8e160271b530810a359d09b8f8bcad1aecd336a2e9382d2d5fad0a3fe1bdf028df6657b267e39c913a40eba02b9499d96e67479e3fa1470fb8a6d213404fa3b6f744a062b85fd5842c6eff39d4b6572c71dc4d7ba9c345fb2ca407df945bf90ddaf980f8b8f2ee3f6ce90c9561f68f4b0f72a5f7fbc61ce0179bcb3a3fc572aa75873661fb973434198ae1fe1896c1a620961435068c55f732205f60d7026e989e3a2451b9c7892a1493dbd75a55cf2ac86ddb472c82c1d195c51709faf67e020e483654721a59970f05927932ccc88e65e1044395217c9e72fa29d61dabbf2740ede27464e0bc9527cf0a38eb5ed9abae3a6dd75f4cec494eae5375025dc9003808447445144545cd6e163cfa133a47d34df96f17322e47f4c73b8b547168fe26158a5c70d7e41f490f6d4e0a8cce59ecc17abcf32101b0895f12e9501b2acbb8569cfdb2776f136e30279baca9fe9d151332d2adadaf811e65871d7f29814238ea8f83020b34b7ff755a91c815dc508bf5d5b6b29e3849d66eb60c98b50a5bc559ca6660be3e40fbc9c2ef443f68ad56f13a192f0478de98e5e6d1afe02847451a5ed885f9726dc91ce51b5dd3d0fad1ba308d63e71944a63aadf3faeea696e31ee1f7ab7524533eca7d9aecd2234306313421c29945b778dbebaadc10be2517db96bf9a3b48babbb47e61b8a599ddb5805413110ad751e7a5a081ea1fe310f6fd5d5ef376cb30659c8b04080518d755163d1b75adf75e5815bea3bc92319db11305717b9e23669cd8eef8057717f9a658498cff9690cd3ac64643ee103bd3dbf545fe26453a8e459c1c0e01ddb2f86d6272d30b7cfb959188186de5f9942cdfff4f8d59097847c9e9d2af09b3f53c4523681b3dc189e7a4badb806fd0c2dbbbe53fa68a05e5ba005aac854a96f1739bb9b6f4f7a15190fbfe5a40609d0fe7c0661d5e7c4e06b57a747f57fe0458aed7268dbbe52ea8ee50346f7d966d713a13ebf3a45f22c2e2f3886b0b0debbe405111de31ed5ffe622de05628106b64926f51814f26d6c6dfb75baaf55b2d3c37268c787006849d0dbc310776e1f70e45132960cf67b9d94acecc3a3dd71ad83aafd201de6ecd394eb64988edc008c104df6e1df6d9a470d4cb6dd41162fb4c904dad434e9f61b84e4b8acb5877c08ccc07e761ce2fc124696f40635939f71ad2f0686931511631de673b6afd1fcfa8d079326833177ebfeb8015f09426e60c1eeca26ae03031eb160f9d0bafde6426d3bfe7e23923e1025ae93f35e468a3b7bd1091ee8603318da2b663c706850273ed75dd9f49451607803b41002b4a6493569e14c654cc2d892c8caeb95bb00a83cdf47352fb4b1b52836dcf958c8cae1394e704d913be55050fe2ed8febc10368e26e9995c36de7386c40e5f83b04d491cd5cd1d26f9dddea24c1752737de401ceba3c6fbb8f4b28d74d2cea67e885f0670283f3cc40841e15c919b94db34a68115842b0ab7472b83e69cc11a6f1fd9e1620e8ed59d9edf5613e5dcd1d2b9df8204dff64414cc909375884b466cace1feac6ec0c143e20409f492117f3b814d5e617c131986758e806cd7e0567d35685da735ab5e0d201f776dfbba6572b7886817ec68ab42926fb21d4f5a618d9cac3ad0ae768016eb5808cd7a6bc9b426cc0f3cb90cb7c7f147697e513abaa0aaf4c46d6496277ef98d12bb010b9cd94e26bbb62c718cd2c9360f707922247e6215ee588e12b761b4dfe52eac2f65801c810c71fde5aac82a2d1f335e24c36030511ee3b9a3f690518692ec7c6cbaecfe4aea064bcaf0602a9e0c30059f1ae6e0bda3e1a1c875a1871dfb5ac5033eb2122b644d465e4e63859e561ab843c01fbda7a1647bc37a59a5fefd3e7eed162c43128aa411e7ef093aa6cb6e3b7b152d1f69007e01badb1feebac82c2838cfc9ecada3e3189fc375d82de01e84401069cadd7feead5aabb5cc4a60207ba712e68307e4df14a8a39864287291f7094c3b7587652006f471990ba5075b355a2f5cdc11c62ecd0c5301fda2ff1ae8c7b7e8704fa5b550ba05dfba35814e7ecf772fc37b7361471cfccfa243ee007f285500b63f1fd1329ebcf7c1bfc7a12b9d1a5cfc0ec770665c79c95f997447a78727498a4428046bf360427555093a9781da6ad727950db2049807e668c7916e90de5d9e3358325642d91b358ec0f005b25789e90785d02412fdce976d5cf5f95a118596349684e7279d224ed977830ea5600f3ffa5327d773e0d0d36604d4d4bddf8013e8d62958bd1ba309593df8db45330324a04ac30ea5bc94240f3b261252efef1c6591fbed6a9fbd93d01af3fe51f6c2f1d6beaa043359cd7a87e193982ca46d08afbd37038e56de7619b15803044a115d33bb946aea71741d75428ce55d98f75b748c675b2da03e4c97f5bccc7cead291d46c32fc2a0f1fffe5abec0dc84a2a13b24e9f12b6267a4cf20253cbb41901b4b299dd65ecc588bf1f205f0536c535d65fa2430925819f40c6f60e132f81cd3efed8572024f8042d27d283a557d1803f8fe9b9c431fcc3469a5040eaf2be4f0c9938441cb462b1d0eff68b9888450c75e653b02d0f5e379934b8c9cf3bca7bae2c349381ab401cee98144b1e4679c84b25140e5138597fe6a4b343d077067645d82e32f552be1f0314673d02b965edf6c5984edd902d82ab85402e0db0dfeebb7c7b03c53e4484d6f2e6ff0251fc305df25f94f6c470c0108d8f2ba63a92b5f7fd576f6bd453e9d081931f5fe5fc0573455ea8b21bf8503152685959827b97f7e76865d7c22d1d4c00d9f8dcf7e4ca3f8fb3eaad24d6d55191f2d7ec3508c3c2f1c157ffd859e60af8dcae0376e9bec75bd34fd1ceaaea1f41f6705c5a1aa8412731f1e463373acc0fb77748026fd796ee4f7514821bf4c3315cad5d6071a340f468c495ea51a4820670964f3904039bda96b1cca7fb0d2e983769bfb09da7ed859bfc40825e24d792ae21207dd8e00ce4d93fac38a63c64d17c8f37ed2424c57b7c27d54a6f6a24d9b81636377db755c89931abff8b2cdf6f2a559c556edd88dc576647c29b4fe5df444875dd42d4c71878c2f011a6c49601f342fd8b0fbaf6a725b80779d65f677e9d501fec7a9f7d771717967b69e1b5ebda976489223d9f4d6135b585c24883b02449699aae165b1f70550718370f3f4e463530cce99adfd7121ac96c587eb1a59bb062e12a25f0bc228ecdb2cfc3c93f350f429f23164ee8b9c96e8778994b0dd9aac0cd11256a1fd20bfaad4e38dd822a04e14e906c5c740cbb23cbd2181f44b065063be659c9e97bf0a838286ba460f3e7eacf799a86eca90a340c1d6df8c6e2ce73bcd5f3c5c34af79c2fcf0be77610f0736d40016109c6064a0dde2fb3b4e5c4fd7578021d2635f362cb226a17107e8ec5cc5c47ad9ec408b66436f24bd40cb5e1f7a1e85430bcb4feb337612106928e867cd687c7b436893ccbcc9b88008007ebd4a3a68b5c2c7983397d51e4c7d16046307559995e00523bcc7142a02259665d227cb6f17a6d1791e9b829a2acab543003c2e8b0c7399cdd17665c31e51d5515d56aea0fa46f3ca55af3dd05d03f54433446ae614bbc2ddd8fe8eca06a05696924dcb9f92cff2f94b9f1a70f4c4dd6808d0dd80d30ae834bc5a34b18238b3cd66528f9bed1f5a6b889cfcdd4282dc307cb16c8cf26242542c40daf39b1ab40c60fde0701f3d5d00032602fec9613b1b104d1dc6d5c51a8bed91c1514d91848298f3866acca0f482116a736dfd000aff73dee038158d2655bf3b9fdd573ea0add57df2d605b76d1facc9edf1779f51a82d2730adf16bca08fb0633e29b2a5980d1a3363c8673d57e47a7026798eb94aa7e8c933829ab81e68363f2a849c0a53352fe4ce4291de9bead279ddfbe373f7d5b9cdcbf2b69c93bcadfc06f4e7fb48e6caa9fda19de8714cf82836762a4e55e04ac23ae8b1193f7050d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo发布文章报错问题记录</title>
    <link href="/2021/03/10/hexo%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/10/hexo%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo发布文章报错问题记录"><a href="#hexo发布文章报错问题记录" class="headerlink" title="hexo发布文章报错问题记录"></a>hexo发布文章报错问题记录</h1><p>hexo g 生成博客时报错，报错原因如下：<br><code>can not read a block mapping entry; a multiline key may not be an implicit key at ...</code></p><p>原因记录：<br>没有严格按照 yaml 语法编辑博客头部配置</p><p><strong>注意：</strong> 博客头部配置中，</p><ol><li>变量和值中间必须有空格，如<code>title: xxxxx</code></li><li>不能出现英文 <code>&quot;&quot;</code>，用中文双引号或者尽量避免使用双引号</li><li>多标签配置：<code>- xxx</code> 或者 <code>[xx,xx,xx]</code> 。 <code>-</code> 后面要加空格，按回车会自动生成 <code>-</code> 表示书写正确。</li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue全局注册与异步加载</title>
    <link href="/2021/03/10/Vue%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    <url>/2021/03/10/Vue%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue全局注册与异步加载"><a href="#Vue全局注册与异步加载" class="headerlink" title="Vue全局注册与异步加载"></a>Vue全局注册与异步加载</h1><h2 id="应用需求描述"><a href="#应用需求描述" class="headerlink" title="应用需求描述"></a>应用需求描述</h2><p>单独封装一个地图控件，实现开关控制地图插件的显示。当开关状态为ON时，在地图上显示相应的地图插件，当开关状态为OFF时，隐藏地图插件。<br><img src="/img/posts_img/20210310215211593_26729.png"></p><h2 id="Vue-代码"><a href="#Vue-代码" class="headerlink" title="Vue 代码"></a>Vue 代码</h2><p><strong>MapPlugin.vue:</strong> 整体插件框封装</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;map-plugin&quot;</span>&gt;</span><br>    //预留插槽，开发者可向内插入任意数目插件<br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;MapPlugin&quot;</span>,</span><br>  <br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-selector-id">#map-plugin</span> &#123;</span><br>  width: 180px;<br>  min-height: 100px;<br><br>  padding: 0 20px;<br>  margin-left: 10px;<br><br><span class="css">  <span class="hljs-selector-tag">border</span>: 3<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">ridge</span> <span class="hljs-selector-id">#515a6ece</span>;</span><br>  border-radius: 5px 25px;<br><br>  display: flex;<br>  flex-direction: column;<br><br>  position: fixed;<br>  bottom: 40px;<br>  left: 0;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>PluginItem.vue:</strong> 单个插件封装</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;plugin-item&quot;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">text</span> &#125;&#125;</span><br><span class="xml">    //使用了iView UI的 i-switch 封装组件</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">i-switch</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;switch1&quot;</span> @<span class="hljs-attr">on-change</span>=<span class="hljs-string">&quot;change&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;large&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;open&quot;</span>&gt;</span>ON<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span>OFF<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">i-switch</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;PluginItem&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    text: &#123;</span><br><span class="xml">      type: String,</span><br><span class="xml">      default: &quot;&quot;,</span><br><span class="xml">    &#125;,</span><br><span class="xml">    callback: Function,</span><br><span class="xml">  &#125;,</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      switch1: false,</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  methods: &#123;</span><br><span class="xml">    change(status) &#123;</span><br><span class="xml">      //   console.log(status);</span><br><span class="xml">      let cn = &quot;&quot;;</span><br><span class="xml">      if (status) &#123;</span><br><span class="xml">        cn = &quot;开&quot;;</span><br><span class="xml">      &#125; else &#123;</span><br><span class="xml">        cn = &quot;关&quot;;</span><br><span class="xml">      &#125;</span><br><span class="xml">      this.$Message.info(&quot;开关状态：&quot; + cn);</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;,</span><br><span class="xml">  //watch 侦听 switch1 变量状态变化，发生变化时调用函数 callback</span><br><span class="xml">  //callback 函数外部传入</span><br><span class="xml">  //watch 使用细节参考 Vue.js 官网</span><br><span class="xml">  watch: &#123;</span><br><span class="xml">    switch1: function (newValue, oldValue) &#123;</span><br><span class="xml">      this.callback(newValue);</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;,</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br><span class="xml">.plugin-item &#123;</span><br><span class="xml">  display: flex;</span><br><span class="xml">  justify-content: space-between;</span><br><span class="xml">  padding: 10px 10px;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="定制封装个性化插件组件"><a href="#定制封装个性化插件组件" class="headerlink" title="定制封装个性化插件组件"></a>定制封装个性化插件组件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">MapPlugin</span>&gt;</span><br>    //向预留插槽内插入PluginItem.vue封装的插件<br>    <span class="hljs-tag">&lt;<span class="hljs-name">PluginItem</span> <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;比例尺&quot;</span> <span class="hljs-attr">:callback</span>=<span class="hljs-string">&quot;getScale&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">PluginItem</span> <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;鹰眼控件&quot;</span> <span class="hljs-attr">:callback</span>=<span class="hljs-string">&quot;getOverView&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">PluginItem</span> <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;工具条&quot;</span> <span class="hljs-attr">:callback</span>=<span class="hljs-string">&quot;getToolBar&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">MapPlugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; MapPlugin, PluginItem &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;components/common/plugin&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; getPlugin &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./getPlugin&quot;</span>;</span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;ModelOnePlugin&quot;</span>,</span><br>  components: &#123;<br>    MapPlugin,<br>    PluginItem,<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-comment">// 填坑1：this.$plugin 在页面挂在完成前没有创建，需要用异步方法，等待 this.$plugin 赋值后获取值并执行</span></span><br>    /**填坑2：<br><span class="javascript">     * <span class="hljs-built_in">this</span> 指向问题. Vue 方法等定义中，若用箭头函数，<span class="hljs-built_in">this</span> 指向上级父作用域，因此值为 <span class="hljs-literal">undefined</span> (打印可知)</span><br><span class="javascript">     * 获取 Vue 实例的 <span class="hljs-built_in">this</span>，需要通过 <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125; 声明函数。同理在 getPlugin.js 中定义的箭头函数，<span class="hljs-built_in">this</span> =&gt; <span class="hljs-literal">undefined</span></span><br><span class="javascript">     * 解决 <span class="hljs-built_in">this</span> 指向：最有效的办法就是获取正确的 <span class="hljs-built_in">this</span> 指向并将它保存到变量内使用。</span><br>     */<br><span class="javascript">    getScale: <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">active</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);</span><br><span class="javascript">      <span class="hljs-keyword">let</span> vueinstance = <span class="hljs-built_in">this</span>;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">await</span> getPlugin(vueinstance);</span><br>      if (active) &#123;<br><span class="javascript">        <span class="hljs-comment">// .show() 插件展示</span></span><br>        obj.scale.show();<br><span class="javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">        <span class="hljs-comment">// .hide() 插件隐藏</span></span><br>        obj.scale.hide();<br>      &#125;<br>    &#125;,<br><span class="javascript">    getOverView: <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">active</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> vueinstance = <span class="hljs-built_in">this</span>;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">await</span> getPlugin(vueinstance);</span><br>      if (active) &#123;<br><span class="javascript">        <span class="hljs-comment">// .show() 插件展示</span></span><br>        obj.overview.show();<br><span class="javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">        <span class="hljs-comment">// .hide() 插件隐藏</span></span><br>        obj.overview.hide();<br>      &#125;<br>    &#125;,<br><span class="javascript">    getToolBar: <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">active</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> vueinstance = <span class="hljs-built_in">this</span>;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">await</span> getPlugin(vueinstance);</span><br>      if (active) &#123;<br><span class="javascript">        <span class="hljs-comment">// .show() 插件展示</span></span><br>        obj.toolbar.show();<br><span class="javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">        <span class="hljs-comment">// .hide() 插件隐藏</span></span><br>        obj.toolbar.hide();<br>      &#125;<br>    &#125;,<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>getPlugin 函数单独封装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const getPlugin = <span class="hljs-function"><span class="hljs-params">(vueinstance)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(vueinstance);<br>    <span class="hljs-regexp">//</span> 此处箭头函数内 <span class="hljs-built_in">this</span> 上级作用域仍为一个箭头函数，值为 <span class="hljs-literal">undefined</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (vueinstance.$plugin) &#123;<br>            resolve(vueinstance.$plugin)<br>        &#125;<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;<br>    getPlugin,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>MapPlugin.vue 和 PluginItem.vue 两个组件封装了通用的插件框和插件<br>主要细节在于插件组件的使用：<br><strong>问题描述一：</strong><br>由于我们采用自己封装的通用插件组件，因此在定制特定功能的插件时，我们需要传入相对应的插件对象，这些插件对象为高德地图创建出来的插件实例。<strong>注意：</strong> 在挂载高德地图实例的时候，我们就提到过，外部实例挂载在Vue实例上，需要等待Vue实例完全挂载。在地图实例挂载时，在mounted中回调创建实例的函数是为了防止Vue实例未挂载完全就执行实例的创建，从而地图实例缺少挂载容器而挂在失败的问题。而在插件实例挂载中，我们本意是在创建通用插件时，传入相应的插件实例从而完成插件个性化定制。但是此时插件实例还未被创建(只有在mounted后执行)，因此用同步方法传递实例自然是失败了。<br><strong>解决方法：</strong><br>用异步方法传递插件实例，插件实例创建后，本文方法将插件实例统一放到对象内并通过<code>Vue.prototype.$xxx</code>全局注册，在插件中通过异步方法获取该全局对象，即用<code>Promise</code>对象包裹异步操作，当检测到<code>$plugin</code>(本文注册的全局对象)时，通过<code>resolve()</code>落定Promise状态为fulFilled，这样我们就能获得包含有插件实例的全局对象，然后对通用插件进行个性化配置。</p><p><strong>问题描述二：</strong><br>上述代码中，我们要特别注意 this 的指向问题，在 Vue 的 methods 定义中，使用箭头函数，由于 this 会指向最近外层作用域<code>&#123;&#125;</code>，因为methods并没有 this，所以值为 undefined。我们需要用 <code>function() &#123;&#125;</code> 来定义，这样定义的函数的 this 会指向 Vue 实例。同理，单独封装的 <code>getPlugin.js</code> 中的箭头函数 this 经过判断也是 undefined，需要做进一步处理保证其获得的是 Vue 实例。<br><strong>解决方法：</strong><br>为了避免多次判断 this 指向，我们可以在明确 this 指向的地方，用变量保存 this 值，然后通过参数传递该变量，用该变量来作为 this 使用。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>ES6</tag>
      
      <tag>async</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js挂载(高德)地图服务API</title>
    <link href="/2021/03/10/Vue%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E9%AB%98%E5%BE%B7API/"/>
    <url>/2021/03/10/Vue%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E9%AB%98%E5%BE%B7API/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue异步加载高德API"><a href="#Vue异步加载高德API" class="headerlink" title="Vue异步加载高德API"></a>Vue异步加载高德API</h1><h2 id="高德地图服务JS-API异步加载"><a href="#高德地图服务JS-API异步加载" class="headerlink" title="高德地图服务JS API异步加载"></a>高德地图服务JS API异步加载</h2><p><a href="https://developer.amap.com/api/javascript-api/guide/abc/prepare">高德地图服务JS API官方文档</a></p><h3 id="Step1-创建挂载容器"><a href="#Step1-创建挂载容器" class="headerlink" title="Step1: 创建挂载容器"></a>Step1: 创建挂载容器</h3><p>官方文档-&gt;准备-&gt;注册并申请Key值<br>添加div标签作为地图容器，同时为该div指定id属性：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">//后续AMap创建的地图实例将挂载在container地图容器上</span><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-symbol">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt; <br></code></pre></td></tr></table></figure><p>为地图容器指定高度、宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span> &#123;<span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">180px</span>; &#125; <br></code></pre></td></tr></table></figure><h3 id="Step2-获取异步加载代码"><a href="#Step2-获取异步加载代码" class="headerlink" title="Step2: 获取异步加载代码"></a>Step2: 获取异步加载代码</h3><p>参考文档：获取异步加载API的相关代码</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-built_in">window</span>.onLoad  = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> AMap.Map(<span class="hljs-string">&#x27;container&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">url</span> = <span class="hljs-string">&#x27;https://webapi.amap.com/maps?v=1.4.15&amp;key=您申请的key值&amp;callback=onLoad&#x27;</span>;<br><span class="hljs-keyword">var</span> jsapi = doc.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);<br>jsapi.charset = <span class="hljs-string">&#x27;utf-8&#x27;</span>;<br>jsapi.src = <span class="hljs-built_in">url</span>;<br><span class="hljs-built_in">document</span>.head.appendChild(jsapi);<br></code></pre></td></tr></table></figure><h3 id="Step3-挂载实例"><a href="#Step3-挂载实例" class="headerlink" title="Step3: 挂载实例"></a>Step3: 挂载实例</h3><p>先挂完整的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs xml">//TMap.vue<br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  //用于挂载实例的容器<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;TMap&quot;</span>,</span><br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">initMap</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-comment">// 高德异步加载地图相关代码</span></span><br><span class="javascript">      <span class="hljs-built_in">window</span>.onLoad = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-comment">// new AMap.Map(&quot;container&quot;,...) 创建高德实例并挂载在container上</span></span><br><span class="javascript">        <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> AMap.Map(<span class="hljs-string">&quot;container&quot;</span>, &#123;</span><br><span class="javascript">          zoom: <span class="hljs-number">11</span>, <span class="hljs-comment">//级别</span></span><br><span class="javascript">          center: [<span class="hljs-number">116.397428</span>, <span class="hljs-number">39.90923</span>], <span class="hljs-comment">//中心点坐标</span></span><br><span class="javascript">          viewMode: <span class="hljs-string">&quot;3D&quot;</span>, <span class="hljs-comment">//使用3D视图</span></span><br>        &#125;);<br><span class="javascript">        <span class="hljs-comment">//将地图实例map注册到全局，方便在其他组件作用域内使用(调用$map即可)</span></span><br>        Vue.prototype.$map = map;<br><br><span class="javascript">        <span class="hljs-comment">//高德地图插件注册(可暂时忽略)</span></span><br>        AMap.plugin(<br><span class="javascript">          [<span class="hljs-string">&quot;AMap.Scale&quot;</span>, <span class="hljs-string">&quot;AMap.ToolBar&quot;</span>, <span class="hljs-string">&quot;AMap.OverView&quot;</span>],</span><br><span class="javascript">          <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-comment">//异步加载插件</span></span><br><span class="javascript">            <span class="hljs-keyword">let</span> scale = <span class="hljs-keyword">new</span> AMap.Scale(&#123;</span><br><span class="javascript">              visible: <span class="hljs-literal">false</span>,</span><br>            &#125;);<br><span class="javascript">            <span class="hljs-keyword">let</span> toolbar = <span class="hljs-keyword">new</span> AMap.ToolBar(&#123;</span><br><span class="javascript">              visible: <span class="hljs-literal">false</span>,</span><br>            &#125;);<br><span class="javascript">            <span class="hljs-keyword">let</span> overview = <span class="hljs-keyword">new</span> AMap.OverView(&#123;</span><br><span class="javascript">              visible: <span class="hljs-literal">false</span>,</span><br><span class="javascript">              isOpen: <span class="hljs-literal">true</span>,</span><br>            &#125;);<br>            map.addControl(scale);<br>            map.addControl(toolbar);<br>            map.addControl(overview);<br><span class="javascript">            <span class="hljs-comment">// 全局注册</span></span><br><span class="javascript">            <span class="hljs-keyword">let</span> obj = &#123;</span><br>              scale,<br>              toolbar,<br>              overview,<br>            &#125;;<br>            Vue.prototype.$plugin = obj;<br>          &#125;<br>        );<br>      &#125;;<br><span class="javascript">      <span class="hljs-keyword">var</span> url =</span><br><span class="javascript">        <span class="hljs-string">&quot;https://webapi.amap.com/maps?v=1.4.15&amp;key=此处填申领的Key值&amp;callback=onLoad&quot;</span>;</span><br><span class="javascript">      <span class="hljs-keyword">var</span> jsapi = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;script&quot;</span>);</span><br><span class="javascript">      jsapi.charset = <span class="hljs-string">&quot;utf-8&quot;</span>;</span><br>      jsapi.src = url;<br><span class="javascript">      <span class="hljs-built_in">document</span>.head.appendChild(jsapi);</span><br>    &#125;,<br>  &#125;,<br><span class="javascript">  <span class="hljs-comment">// 最关键的一步：在组件挂载完成后(mounted)挂载高德实例</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.initMap();</span><br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-selector-id">#container</span> &#123;</span><br>  height: 100%;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>重点：</strong><br>高德JS API异步加载代码，会通过<code>new AMap.Map(&quot;容器id&quot;,...)</code>创建高德实例并挂载在指定容器上。<br>值得注意的是，我们需要将整个异步加载的过程放在 Vue 挂载完成后执行。<br>原因：<br>在 Vue 实例没有完全挂载完成前，我们无法保证组件内 <code>&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</code> 已经被创建。<br>若容器未被创建，异步加载代码就已经被执行，地图是无法挂载到 Vue 实例上的。<br>因此，我们需要借助 Vue 的生命周期 mounted (在Vue实例挂载完成后执行内部函数)。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础</title>
    <link href="/2021/03/06/CSS%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/03/06/CSS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h1><p>参考资料：<a href="https://www.w3school.com.cn/css/index.asp">W3School–CSS</a></p><hr><h2 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h2><p>**CSS规则集(rule-set)**：选择器 + 声明块<br><img src="/img/posts_img/20210306111858285_13158.png"><br>实例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重点：</strong></p><ol><li>选择器概念</li><li>声明块内可包含多条声明语句，用 <code>;</code> 分隔。(区别于对象)</li><li>声明语句以键值对(key-value)形式书写，值不需要指定为字符串形式。(区别于对象)</li></ol><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>概念：指定设置样式的 HTML 元素<br>CSS选择器类型包括：</p><ol><li>简单选择器（根据名称、id、类来选取元素）</li><li>组合器选择器（根据它们之间的特定关系来选取元素）</li><li>伪类选择器（根据特定状态选取元素）</li><li>伪元素选择器（选取元素的一部分并设置其样式）</li><li>属性选择器（根据属性或属性值来选取元素）</li></ol><h4 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h4><h5 id="css元素选择器"><a href="#css元素选择器" class="headerlink" title="css元素选择器"></a>css元素选择器</h5><p>作用：根据元素名称(HTML标签)选择 HTML 元素，所有指定的标签样式均会被更改。<br>实例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="css-id选择器"><a href="#css-id选择器" class="headerlink" title="css id选择器"></a>css id选择器</h5><p>作用：根据 HTML 元素的 id 属性来选择特定元素。元素的 id 在页面中是唯一的，因此 id 选择器用于选择一个唯一的元素。<br>语法：<code>#idname &#123;css style;...&#125;</code><br>实例：(id 为 myidname 的标签被选中并修改样式)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#myidname</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="css类选择器"><a href="#css类选择器" class="headerlink" title="css类选择器"></a>css类选择器</h5><p>作用：根据 HTML 元素的 class 属性来选择特定元素。<br>语法： <code>.classname &#123;css style;...&#125;</code><br>实例1：(所有class名为myclassname的标签均被选中并修改样式)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.myclassname</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例2：(h2标签中class名为myclassname的标签被选中并修改样式)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span><span class="hljs-selector-class">.myclassname</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="css通用选择器"><a href="#css通用选择器" class="headerlink" title="css通用选择器"></a>css通用选择器</h5><p>作用：选择页面上的所有的 HTML 元素。<br>语法：<code>* &#123;css style;...&#125;</code><br>实例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="css分组选择器"><a href="#css分组选择器" class="headerlink" title="css分组选择器"></a>css分组选择器</h5><p>作用：将样式相同的 HTML 元素写在一起，缩减代码量。<br>语法：<code>name1, name2, ... &#123;css style;...&#125;</code><br>实例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-id">#idname</span>, <span class="hljs-selector-class">.classname</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="后续补充，敬请期待"><a href="#后续补充，敬请期待" class="headerlink" title="后续补充，敬请期待"></a>后续补充，敬请期待</h4><h2 id="CSS使用"><a href="#CSS使用" class="headerlink" title="CSS使用"></a>CSS使用</h2><h3 id="外部CSS"><a href="#外部CSS" class="headerlink" title="外部CSS"></a>外部CSS</h3><p>外部样式表可以在任何文本编辑器中编写，并且必须以 <code>.css</code> 扩展名保存。<br>可在所引入的页面下使用表内样式。<br>引用：</p><ol><li>HTML 页面：在 <code>&lt;head&gt;</code> 部分的 <code>&lt;link&gt;</code> 元素内包含对外部样式表文件的引用。</li><li>框架内：在 <code>&lt;script&gt;</code> 部分通过模块化导入 <code>.css</code> 文件</li></ol><p>实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">HTML：<br>&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;mystyle.css&quot;</span>&gt;<br><br>框架：<br>import <span class="hljs-string">&quot;./xxx/xx/mystle.css&quot;</span>;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>外部 <code>.css</code> 文件不应包含任何 HTML 标签。</li><li>请勿在属性值和单位之间添加空格（例如 <code>margin-left: 20 px;</code>）。正确的写法是：<code>margin-left: 20px;</code></li></ol><h3 id="内部CSS"><a href="#内部CSS" class="headerlink" title="内部CSS"></a>内部CSS</h3><p>仅在某一页面内使用定义的样式。<br>引用：</p><ol><li>HTML 页面：在 <code>&lt;head&gt;</code> 部分的 <code>&lt;style&gt;</code> 元素中进行定义。</li><li>框架内(以Vue为例)：在组件的 <code>&lt;style&gt;</code> 部分定义样式。</li></ol><p>实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>body &#123;<br>  background-color: linen;<br>&#125;<br><br>h1 &#123;<br>  color: maroon;<br>  margin-left: 40px;<br>&#125; <br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="行内CSS-内联样式"><a href="#行内CSS-内联样式" class="headerlink" title="行内CSS(内联样式)"></a>行内CSS(内联样式)</h3><p>为单个元素应用唯一的样式。<br>引用：行内样式在相关元素的 <code>style</code> 属性中定义<br>实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue;text-align:center;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>提示：</p><ol><li>行内样式失去了样式表的许多优点（通过将内容与呈现混合在一起）。请谨慎使用此方法。</li><li>标签内属性值均用 <code>&quot;&quot;</code> 包裹，内联样式传递给 <code>style</code> 属性时不需要 <code>&#123;&#125;</code> 包裹。</li></ol><h3 id="CSS样式层叠优先级"><a href="#CSS样式层叠优先级" class="headerlink" title="CSS样式层叠优先级"></a>CSS样式层叠优先级</h3><p>优先级从高到低依次为：</p><ol><li>行内样式（在 HTML 元素中）</li><li>外部和内部样式表（在 head 部分）</li><li>浏览器默认样式</li></ol><p>行内样式具有最高优先级，并且将覆盖外部和内部样式以及浏览器默认样式。</p><h2 id="CSS颜色"><a href="#CSS颜色" class="headerlink" title="CSS颜色"></a>CSS颜色</h2><h2 id="CSS背景"><a href="#CSS背景" class="headerlink" title="CSS背景"></a>CSS背景</h2><h2 id="CSS边框"><a href="#CSS边框" class="headerlink" title="CSS边框"></a>CSS边框</h2><h2 id="CSS边距"><a href="#CSS边距" class="headerlink" title="CSS边距"></a>CSS边距</h2><h3 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距(margin)"></a>外边距(margin)</h3><p>CSS margin 属性用于在任何定义的边框(包括没有定义边框)之外，为元素周围创建空间。<br><strong>margin 属性</strong>：</p><ol><li>margin-top</li><li>margin-right</li><li>margin-bottom</li><li>margin-left</li></ol><p>**margin 属性值(允许负值)**：</p><ol><li><code>auto</code> - 浏览器来计算外边距</li><li><code>length</code> - 以 px、pt、cm 等单位指定外边距</li><li><code>%</code> - 指定以包含元素宽度的百分比计的外边距</li><li><code>inherit</code> - 指定应从父元素继承外边距</li></ol><p>margin 属性简写：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">margin:</span> 上 右 下 左<br><span class="hljs-symbol">margin:</span> 上 右左 下<br><span class="hljs-symbol">margin:</span> 上下 右左<br><span class="hljs-symbol">margin:</span> 上下左右<br></code></pre></td></tr></table></figure><p>auto 属性值的特殊用途(水平居中)：<br><code>margin: auto</code><br>元素将占据指定的宽度，并且剩余空间将在左右边界之间平均分配。</p><h4 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h4><p>当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。<br>具体参照：<a href="https://www.w3school.com.cn/css/css_margin_collapse.asp">外边距合并</a> ，此处不做细致讲解</p><h3 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距(padding)"></a>内边距(padding)</h3><p>CSS padding 属性用于在任何定义的边界内的元素内容周围生成空间。即向内填充。<br><strong>padding 属性</strong>：</p><ol><li>padding-top</li><li>padding-right</li><li>padding-bottom</li><li>padding-left</li></ol><p>**padding 属性值(允许负值 | 没有 auto 属性值)**：</p><ol><li><code>length</code> - 以 px、pt、cm 等单位指定外边距</li><li><code>%</code> - 指定以包含元素宽度的百分比计的外边距</li><li><code>inherit</code> - 指定应从父元素继承外边距</li></ol><p>padding 属性简写：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">padding:</span> 上 右 下 左<br><span class="hljs-symbol">padding:</span> 上 右左 下<br><span class="hljs-symbol">padding:</span> 上下 右左<br><span class="hljs-symbol">padding:</span> 上下左右<br></code></pre></td></tr></table></figure><h2 id="CSS高度-宽度"><a href="#CSS高度-宽度" class="headerlink" title="CSS高度/宽度"></a>CSS高度/宽度</h2><p>height 和 width 属性用于设置元素的高度和宽度。height 和 width 属性不包括内边距、边框或外边距。<br>标准盒子模型：<br><img src="/img/posts_img/20210306140343369_9779.png"></p><p>IE盒子模型：<br><img src="/img/posts_img/20210306140404202_28129.png"></p><p><strong>height | width 属性</strong>：</p><ol><li><code>auto</code> - 默认。浏览器计算高度和宽度。</li><li><code>length</code> - 以 px、cm 等定义高度/宽度。</li><li><code>%</code> - 以包含块的百分比定义高度/宽度。</li><li><code>initial</code> - 将高度/宽度设置为默认值。</li><li><code>inherit</code> - 从其父值继承高度/宽度</li></ol><p><strong>注意</strong>：<br>在标准盒子模型中，height 和 width 属性不包括内边距、边框或外边距！它们设置的是元素的内边距、边框和外边距内的区域的高度/宽度！</p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面设计</title>
    <link href="/2020/12/12/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/12/12/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h1><p>项目 GitHub 地址：<a href="https://github.com/jtwang7/group_website.git">group_website</a></p><h2 id="方法-重难点"><a href="#方法-重难点" class="headerlink" title="方法+重难点"></a>方法+重难点</h2><h3 id="CSS脱离文档流后同级元素上移问题"><a href="#CSS脱离文档流后同级元素上移问题" class="headerlink" title="CSS脱离文档流后同级元素上移问题"></a>CSS脱离文档流后同级元素上移问题</h3><p>参考链接：<a href="https://www.html.cn/qa/css3/18193.html">css固定定位脱离文档流怎么解决？</a><br>某元素脱离文档流后，同级元素位置上移的原因是因为没有给父级层设置相应的高度。当子级元素没有脱离文档流时，父DIV会因为子DIV的高度而被撑起来，然而当子DIV设置绝对定位或固定定位时，父DIV不会再根据子DIV的高度撑起来，也就是我们常说的脱离文档流。<br>解决方法1：强行给父级DIV设置相应的高度，这个方案的缺点是不够灵活，需要自己计算要设置的高度</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.parent</span>&#123;<br><span class="hljs-comment">/*解决方法1：css强制设置父模块宽度高度*/</span><br><span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>...<br>&#125;<br><span class="hljs-selector-class">.son</span>&#123;<br><span class="hljs-comment">/*设置固定定位*/</span><br><span class="hljs-attribute">position</span>:fixed;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方法2：在合适的位置设置占位元素。没有在父元素设置元素高度直观，不建议采用。<br><strong>解决方法3：使用JS设置父级DIV的高度等于子DIV (推荐)</strong></p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-built_in">window</span>.onload = ()=&gt;(<br>    <span class="hljs-keyword">let</span> son = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;son&#x27;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-built_in">parent</span> = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;parent&#x27;</span>);<br>    <span class="hljs-comment">//不兼容IE9以前的浏览器，IE9 以前用 son.currentStyle 获取</span><br>    <span class="hljs-built_in">parent</span>.style.height = <span class="hljs-built_in">window</span>.getComputedStyle(<span class="hljs-string">&#x27;son&#x27;</span>).height;<br>)<br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle">window.getComputedStyle()</a>: 以对象形式返回目标的所有CSS样式值<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload">window.onload()</a>: MDN文档中说明，onload 事件触发发生在所有 DOM 资源加载完成后，此时所有元素在DOM中均已完成挂载，不用担心 onload 事件触发后调用函数无作用对象的问题。<br><strong>在 React 中用 ref 属性来获取 dom 元素进行操作</strong></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">//在组件完成挂载时，添加 window.onload 监听事件，它在所有 DOM 资源加载完成后调用函数执行。</span><br><span class="xml">componentDidMount() &#123;</span><br><span class="xml">    window.onload = ()=&gt;&#123;</span><br><span class="xml">        this.parent.style.height = window.getComputedStyle(this.son).height</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br><span class="xml">...</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="xml">    style=</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">position:</span> <span class="hljs-string">&quot;relative&quot;</span> &#125;&#125;</span><br><span class="xml">    //获取DOM元素</span><br><span class="xml">    ref=&#123;(parent) =&gt; &#123; this.parent = parent &#125;&#125;</span><br><span class="xml">&gt;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="xml">        style=</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">position:</span> <span class="hljs-string">&quot;absolute&quot;</span>, zIndex: -1, width: <span class="hljs-string">&quot;100vw&quot;</span>, height: <span class="hljs-string">&quot;1080px&quot;</span> &#125;&#125;</span><br><span class="xml">        src=&#123;headerPng&#125;</span><br><span class="xml">        alt=&quot;&quot;</span><br><span class="xml">        //获取DOM元素</span><br><span class="xml">        ref=&#123;(son) =&gt; &#123; this.son = son &#125;&#125;</span><br><span class="xml">    /&gt;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Titles</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">DropdownMenu</span> <span class="hljs-attr">isActive</span>=<span class="hljs-string">&#123;this.state.isActive&#125;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">position:</span> <span class="hljs-string">&quot;relative&quot;</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span></span><br><span class="xml">    //去除了占位元素： - <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;titlePlaceHolder&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">PageOne</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>渲染结果：<br><img src="/img/posts_img/20201213093355087_31820.png"></p><h3 id="this-指向问题"><a href="#this-指向问题" class="headerlink" title="this 指向问题"></a>this 指向问题</h3><p>参考链接：<br><a href="https://www.cnblogs.com/felearn/p/this-zhi-xiang-wen-ti.html">this 指向问题</a><br><a href="https://www.cnblogs.com/dongcanliang/p/7054176.html">this 指向详细解析</a><br>这里只对实战中遇到的 this 做简要分析，具体的需要详细学习。<br><strong>DOM事件处理函数</strong><br>(1)当函数被当做监听事件处理函数时， 其 this 指向触发该事件的元素 （针对于addEventListener事件）<br>(2)代码被内联处理函数调用时，它的this指向监听器所在的DOM元素,当代码被包括在函数内部执行时，其this指向等同于函数直接调用的情况</p><p><strong>setTimeout &amp; setInterval</strong><br>对于延时函数内部的回调函数的this指向全局对象window</p><p><strong>箭头函数中的 this</strong><br>(1)由于箭头函数不绑定this， 它会捕获其所在上下文的this值， 作为自己的this值。<strong>因此常被用于调用函数，改变函数的this指向，不容易出错。</strong><br>(2)方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象,箭头函数没有this</p><p>举例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; dispatch(&#123; type: <span class="hljs-string">&quot;close_isActive_delay&quot;</span> &#125;) &#125;, <span class="hljs-number">300</span>)<br></code></pre></td></tr></table></figure><p>上述例子中，不能直接使用dispatch函数，因为在setTimeout中this指向全局对象window，使用箭头函数后自动关联上下文，this最终指向监听事件的DOM元素。(正确性有待商榷，对this不是很了解)</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">├─ group_website<br>│  └─ src<br>│     ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">App</span>.</span></span>css<br>│     ├─ components<br>│     │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DropdownMenu</span>.</span></span>js<br>│     │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DropdownSubTitle</span>.</span></span>js<br>│     │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DropdownTitle</span>.</span></span>js<br>│     │  ├─ page1<br>│     │  │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PageOne</span>.</span></span>js<br>│     │  │  └─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PageOneText</span>.</span></span>js<br>│     │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SubTitle</span>.</span></span>js<br>│     │  └─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Titles</span>.</span></span>js<br>│     ├─ images<br>│     │  ├─ header.png<br>│     │  ├─ pgoneBackground.png<br>│     │  └─ testImg.jpg<br>│     ├─ index.js<br>│     ├─ store<br>│     │  ├─ index.js<br>│     │  └─ reducer.js<br>│     ├─ style<br>│     │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DropdownMenu</span>.</span></span>css<br>│     │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DropdownTitle</span>.</span></span>css<br>│     │  ├─ page1<br>│     │  │  └─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PageOne</span>.</span></span>css<br>│     │  ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SubTitle</span>.</span></span>css<br>│     │  └─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Titles</span>.</span></span>css<br>│     └─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Website</span>.</span></span>js<br>└─ package-lock.json<br></code></pre></td></tr></table></figure><p>项目入口 js 文件为 <code>Website.js</code>，CSS样式存储于 <code>/store</code>文件夹下，页面组件存储于<code>/components</code>文件夹中。</p><h2 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h2><h3 id="Website-js"><a href="#Website-js" class="headerlink" title="Website.js"></a>Website.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> DropdownMenu <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/DropdownMenu&#x27;</span><br><span class="hljs-keyword">import</span> Titles <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Titles&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./App.css&quot;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/index&#x27;</span><br><span class="hljs-keyword">import</span> headerPng <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./images/header.png&#x27;</span><br><span class="hljs-keyword">import</span> PageOne <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/page1/PageOne&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Website</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = store.getState()<br>        <span class="hljs-built_in">this</span>.storeChange = <span class="hljs-built_in">this</span>.storeChange.bind(<span class="hljs-built_in">this</span>)<br>        store.subscribe(<span class="hljs-built_in">this</span>.storeChange)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">storeChange</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(store.getState())<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div&gt;<br>                    &lt;div style=&#123;&#123; <span class="hljs-attr">position</span>: <span class="hljs-string">&quot;relative&quot;</span> &#125;&#125;&gt;<br>                        &lt;img style=&#123;&#123;<span class="hljs-attr">position</span>:<span class="hljs-string">&quot;absolute&quot;</span>,<span class="hljs-attr">zIndex</span>:-<span class="hljs-number">1</span>,<span class="hljs-attr">width</span>:<span class="hljs-string">&quot;100vw&quot;</span>,<span class="hljs-attr">height</span>:<span class="hljs-string">&quot;1080px&quot;</span>&#125;&#125; src=&#123;headerPng&#125; alt=<span class="hljs-string">&quot;&quot;</span> /&gt;<br>                        &lt;Titles /&gt;<br>                        &lt;DropdownMenu isActive=&#123;<span class="hljs-built_in">this</span>.state.isActive&#125; /&gt;<br>                    &lt;/div&gt;<br>                    &lt;div style=&#123;&#123;<span class="hljs-attr">position</span>:<span class="hljs-string">&quot;relative&quot;</span>&#125;&#125;&gt;<br>                        &lt;div className=<span class="hljs-string">&quot;titlePlaceHolder&quot;</span>&gt;&lt;/div&gt;<br>                        &lt;PageOne /&gt;<br>                    &lt;/div&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Website;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">z-index设置：</span><br><span class="hljs-comment">1. 设置z-index的元素必须设置position:(relative/fixed/absolute)，若不对位置有调整或特殊要求，可以单设一个relative。</span><br><span class="hljs-comment">2. 将要在z轴排序的元素用&lt;div&gt;包裹，同时在父级元素上也要设position。</span><br><span class="hljs-comment">3. 根据需要对不同的子元素设置z-index，排序。</span><br><span class="hljs-comment">***关键：所有参与的元素(包括父元素)都要设置position</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">脱离文档流后元素上移问题：</span><br><span class="hljs-comment">1. 同级元素脱离文档流后，在整体布局上不占位置。</span><br><span class="hljs-comment">2. 若要保证其他元素原有布局，用&lt;div&gt;创建一个具有原同级元素大小的元素充当占位元素。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="重难点分析"><a href="#重难点分析" class="headerlink" title="重难点分析"></a>重难点分析</h4><p><strong>页面布局</strong></p><ol><li>如何让组件脱离文档流？方法一：设置<code>position:(&quot;fixed&quot;/&quot;absolute&quot;)</code>，方法二：设置<code>display:float</code>，不过目前常用的是 flex 布局，一般用不到 float 浮动布局。</li><li>脱离文档流的好处和坏处？好处：脱离文档流可以释放元素占据的空间，让同级以及子级元素浮动到顶部，在设置图片背景的时候常用，如实战代码中的<code>&lt;img style=&#123;&#123;position:"absolute",zIndex:-1,width:"100vw",height:"1080px"&#125;&#125; src=&#123;headerPng&#125; alt=&quot;&quot; /&gt;</code>。坏处：脱离文档流后后续的布局会被打乱，很难调整。</li><li>如何克服脱离文档流后后续元素上移问题：用<code>&lt;div&gt;</code>创建一个具有原同级元素大小的元素充当占位元素，或者给父级元素设置相应的高度。实战中代码使用如下：<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">//设置position:&quot;absolute&quot;后脱离文档流</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">position:</span> <span class="hljs-string">&quot;relative&quot;</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">position:&quot;absolute&quot;</span>,zIndex:-1,width:&quot;100vw&quot;,height:&quot;1080px&quot;&#125;&#125;</span><span class="xml"><span class="hljs-tag"> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;headerPng&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Titles</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">DropdownMenu</span> <span class="hljs-attr">isActive</span>=<span class="hljs-string">&#123;this.state.isActive&#125;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">position:&quot;relative&quot;</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span></span><br><span class="xml">    //设置一个div元素，大小与上述div最大尺寸相同，占据原有位置</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;titlePlaceHolder&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">PageOne</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li>脱离文档流的元素位置设置：<code>position:(&quot;fixed&quot;/&quot;absolute&quot;)</code>属性都是相对于父级的<code>position:&quot;relative&quot;</code>进行定位的。若要进行位置定位，在父级元素单独设置<code>position:&quot;relative&quot;</code>即可。</li><li>关于 z-index 属性设置：在设置背景的时候，往往会遇到背景遮盖了优先需要显示的部分，这就需要调整 z-index 的属性，z-index 越大，显示的优先级越高。<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">z-<span class="hljs-built_in">index</span>设置：<br>设置z-<span class="hljs-built_in">index</span>的(每一个)元素必须设置<span class="hljs-keyword">position</span>:(relative/fixed/absolute)，若不对位置有调整或特殊要求，可以单设一个relative。<br>将要在z轴排序的元素用&lt;div&gt;包裹，同时在父级元素上也要设<span class="hljs-keyword">position</span>。<br>根据需要对不同的子元素设置z-<span class="hljs-built_in">index</span>，排序。<br>***关键：所有参与的元素(包括父元素)都要设置<span class="hljs-keyword">position</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="Title-js"><a href="#Title-js" class="headerlink" title="Title.js"></a>Title.js</h3><p><img src="/img/posts_img/20201213093805783_19881.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../style/Titles.css&quot;</span><br><span class="hljs-keyword">import</span> SubTitle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./SubTitle&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Titles</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;&#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> titleInfo = [<br>            &#123;<br>                titleText: <span class="hljs-string">&quot;Title1&quot;</span>,<br>                id:<span class="hljs-number">1</span>,<br>                subTitleProps: [<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;百度&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;搜狗&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.sogou.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;360搜索&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.so.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;火狐&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://start.firefoxchina.cn/&quot;</span>, &#125;,<br>                ],<br>            &#125;,<br>            &#123;<br>                titleText: <span class="hljs-string">&quot;Title2&quot;</span>,<br>                id:<span class="hljs-number">2</span>,<br>                subTitleProps: [<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;百度&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;搜狗&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.sogou.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;360搜索&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.so.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;火狐&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://start.firefoxchina.cn/&quot;</span>, &#125;,<br>                ],<br>            &#125;,<br>            &#123;<br>                titleText: <span class="hljs-string">&quot;Title3&quot;</span>,<br>                id:<span class="hljs-number">3</span>,<br>                subTitleProps: [<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;百度&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;搜狗&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.sogou.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;360搜索&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.so.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;火狐&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://start.firefoxchina.cn/&quot;</span>, &#125;,<br>                ],<br>            &#125;,<br>            &#123;<br>                titleText: <span class="hljs-string">&quot;Title4&quot;</span>,<br>                id:<span class="hljs-number">4</span>,<br>                subTitleProps: [<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;百度&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;搜狗&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.sogou.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;360搜索&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://www.so.com/&quot;</span>, &#125;,<br>                    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;火狐&quot;</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;https://start.firefoxchina.cn/&quot;</span>, &#125;,<br>                ],<br>            &#125;,<br>        ]<br><br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div className=<span class="hljs-string">&quot;titleContainer&quot;</span>&gt;<br>                    &lt;div className=<span class="hljs-string">&quot;leftPlaceHolder&quot;</span>&gt;&lt;/div&gt;<br>                    &lt;div className=<span class="hljs-string">&quot;rightPlaceHolder&quot;</span>&gt;<br>                        &#123;<br>                            titleInfo.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>                                <span class="hljs-keyword">return</span> (<br>                                    &lt;SubTitle<br>                                        key=&#123;index&#125;<br>                                        titleText=&#123;item.titleText&#125;<br>                                        params=&#123;item.subTitleProps&#125;<br>                                        index=&#123;item.id&#125;<br>                                        /&gt;)<br>                            &#125;)<br>                        &#125;<br>                    &lt;/div&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Titles;<br></code></pre></td></tr></table></figure><h4 id="重难点分析-1"><a href="#重难点分析-1" class="headerlink" title="重难点分析"></a>重难点分析</h4><p><strong>组件使用思想</strong><br>React 尽量将具有相同功能的组件单独编写，一些内容变化可以通过传参的方式，事先声明存储内容的参数数组进行遍历，如上述代码所示。若功能完全一致的组件可以声明为高阶组件进行复用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">titleInfo.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;SubTitle<br>            key=&#123;index&#125;<br>            titleText=&#123;item.titleText&#125;<br>            params=&#123;item.subTitleProps&#125;<br>            index=&#123;item.id&#125;<br>            /&gt;)<br>&#125;)<br></code></pre></td></tr></table></figure><ol><li>注意 <code>&#123;&#125;</code>是需要用<code>return()</code>返回内容的，这里也可以用<code>()=&gt;()</code>的ES6写法，默认省略<code>return</code>，自动返回括号内的内容。</li><li>通过传递<code>props</code>的方式修改通用组件<code>&lt;SubTitle /&gt;</code>中的部分内容，实现组件的高度复用。</li><li>页面布局的小技巧：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;div <span class="hljs-attribute">className</span>=<span class="hljs-string">&quot;leftPlaceHolder&quot;</span>&gt;&lt;/div&gt;<br>&lt;div <span class="hljs-attribute">className</span>=<span class="hljs-string">&quot;rightPlaceHolder&quot;</span>&gt;<br></code></pre></td></tr></table></figure>布局前实现用空<code>&lt;div&gt;</code>进行空间分配，再在相应空间内进行布局。</li></ol><h3 id="SubTitle-js"><a href="#SubTitle-js" class="headerlink" title="SubTitle.js"></a>SubTitle.js</h3><p><img src="/img/posts_img/20201213093842983_11703.png"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> React, &#123; Component &#125; from <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> DropdownTitle from <span class="hljs-string">&#x27;./DropdownTitle&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../style/SubTitle.css&quot;</span><br><span class="hljs-keyword">import</span> store from <span class="hljs-string">&#x27;../store/index&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubTitle</span> <span class="hljs-title">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(props) &#123;<br>        <span class="hljs-keyword">super</span>(props);<br>        <span class="hljs-keyword">this</span>.state = store.getState()<br>        <span class="hljs-keyword">this</span>.storeChange = <span class="hljs-keyword">this</span>.storeChange.bind(<span class="hljs-keyword">this</span>)<br>        store.subscribe(<span class="hljs-keyword">this</span>.storeChange)<br><br>        <span class="hljs-keyword">this</span>.handleMouseOver = <span class="hljs-keyword">this</span>.handleMouseOver.bind(<span class="hljs-keyword">this</span>)<br>        <span class="hljs-keyword">this</span>.handleMouseOut = <span class="hljs-keyword">this</span>.handleMouseOut.bind(<span class="hljs-keyword">this</span>)<br>    &#125;<br><br>    handleMouseOver() &#123;<br>        <span class="hljs-keyword">const</span> action = &#123;<br>            type: <span class="hljs-string">&quot;open_isActive_delay&quot;</span>,<br>            id: <span class="hljs-keyword">this</span>.props.index,<br>        &#125;<br>        store.dispatch(action)<br>    &#125;<br><br>    handleMouseOut() &#123;<br>        <span class="hljs-keyword">const</span> delayAction = () =&gt; (dispatch, getState) =&gt; &#123;<br>            <span class="hljs-comment">// setTimeout里用箭头函数调用dispatch函数，目的是绑定this，这里不能用bind方法，因为这样绑定的this是全局的，无效</span><br>            let timer = setTimeout(() =&gt; &#123; dispatch(&#123; type: <span class="hljs-string">&quot;close_isActive_delay&quot;</span> &#125;) &#125;, <span class="hljs-number">300</span>)<br>            console.log(<span class="hljs-keyword">this</span>.state.isActive)<br>            dispatch(&#123; type: <span class="hljs-string">&quot;add_timer&quot;</span>, timer &#125;)<br>        &#125;<br>        store.dispatch(delayAction())<br>    &#125;<br><br>    storeChange() &#123;<br>        <span class="hljs-keyword">this</span>.setState(store.getState())<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div className=<span class="hljs-string">&quot;subTitleContainer&quot;</span>&gt;<br>                &lt;div&gt;<br>                    &lt;a<br>                        className=<span class="hljs-string">&quot;textFont&quot;</span><br>                        onMouseOver=&#123;(e) =&gt; &#123;<br>                            <span class="hljs-keyword">this</span>.handleMouseOver()<br>                        &#125;&#125;<br>                        onMouseOut=&#123;(e) =&gt; &#123;<br>                            <span class="hljs-keyword">this</span>.handleMouseOut()<br>                        &#125;&#125;<br>                        <span class="hljs-comment">//this.state.id是鼠标移动到某一title时传递的id</span><br>                        <span class="hljs-comment">//this.props.index是组件遍历渲染时分配的id</span><br>                        <span class="hljs-comment">//即当两者相匹配时，证明该title被鼠标激活，此时修改样式</span><br>                        <span class="hljs-comment">//将其他title从白色设为灰色，同时将激活的title设为天蓝色</span><br>                        style=&#123;<br>                            <span class="hljs-keyword">this</span>.state.isActive ?<br>                                ((<span class="hljs-keyword">this</span>.state.id === <span class="hljs-keyword">this</span>.props.index) ?&#123; color: <span class="hljs-string">&quot;#44DAFF&quot;</span> &#125; : &#123; color: <span class="hljs-string">&quot;#666666&quot;</span> &#125;)<br>                                : &#123; color: <span class="hljs-string">&quot;white&quot;</span> &#125;<br>                        &#125;<br>                    &gt;&#123;<span class="hljs-keyword">this</span>.props.titleText&#125;&lt;/a&gt;<br>                &lt;/div&gt;<br>                &lt;DropdownTitle<br>                    params=&#123;<span class="hljs-keyword">this</span>.props.params&#125;<br>                    index=&#123;<span class="hljs-keyword">this</span>.props.index&#125;<br>                /&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br>export default SubTitle;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">redux中怎么使用setTimeout? redux-thunk中间件</span><br><span class="hljs-comment">此处用setTimeout()做延迟操作，使用户有足够时间移动到子选项</span><br><span class="hljs-comment">注意omMouseOut里面的异步操作，setTimeout执行时，会执行this.setState()，而非等待setTimeout执行完。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="重难点分析-2"><a href="#重难点分析-2" class="headerlink" title="重难点分析"></a>重难点分析</h4><p><strong>Redux-thunk</strong><br>在导航栏设计时需要考虑用户拖动鼠标的时间，假设不设置 setTimeout 延时，会导致用户鼠标离开标题后，直接触发 onMouseOut 事件，将导航栏关闭，无法点击导航栏的子选项。因此我们要给用户一定的时间从主标题移动到子标题，当用户移动到子标题时，触发子标题上的 onMouseOver 事件，清除 setTimeout 延时并维持 isActive 状态为 true。<br>由于涉及到多级的状态管理，因此使用了 Redux ，但是在 Redux 中<code>const action = &#123;type:&quot;...&quot;,...&#125;</code>只能传递对象，无法加入 <code>setTimeout()</code> 异步函数，因此我们又需要引入中间件Redux-thunk。thunk 中间件主要处理一些状态的异步操作问题：例如 setTimeout 延时, axios 请求等。<br><strong>thunk 的基础和原理在这里不过多的介绍，可以参考：</strong><br><a href="https://zhuanlan.zhihu.com/p/152237565">redux-thunk最简单的讲解，7行代码用就完事了</a><br>精炼：<br><strong>执行同步action：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">decrement</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">1</span> &#125;<br>&#125;<br>const mapDispatchToProps = <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>     increment: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;INCREMENT&#x27;</span>, <span class="hljs-attr">payload</span>: <span class="hljs-number">1</span>&#125;),<br>     decrement: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> dispatch( decrement() )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>执行异步action：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const delayAction =<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span><span class="hljs-function"> (<span class="hljs-params">dispatch</span>, <span class="hljs-params">getState</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> timer = set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123; dispatch(&#123; <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;close_isActive_delay&quot;</span> &#125;) &#125;, <span class="hljs-number">300</span>)<br>    dispatch(&#123; <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;add_timer&quot;</span>, timer &#125;)<br>&#125;<br>store.dispatch(delay<span class="hljs-constructor">Action()</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意事项<br>dispatch内必须是一个扁平化的object，或者是能直接返回一个{type:’REDUCERS’,payload:data}的函数</p></blockquote><hr><p><a href="https://www.zhihu.com/question/290001259/answer/467650797">在什么场景下需要用到redux的middleware,thunk？</a><br>精炼：<br>thunk 函数接收两个参数，其都是 Redux 的方法名</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">(dispatch, getState) =&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>thunk 可以通过 getState 方法获取 store 仓库中的所有状态，并可以在执行完自定义函数操作后将结果 dispatch 到 store 仓库中。</p><hr><p><a href="https://zhuanlan.zhihu.com/p/85403048">理解redux-thunk</a><br><a href="https://jspang.com/detailed?id=48#toc264">技术胖-Redux-thunk</a><br>thunk 的使用方法：</p><ol><li>安装 redux-thunk<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save redux-thunk</span><br></code></pre></td></tr></table></figure></li><li>配置 redux-thunk<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//在redux中使用中间件，首先要引入applyMiddleware</span><br><span class="hljs-keyword">import</span> &#123; createStore , applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span> <br><span class="hljs-comment">//引入redux-thunk库</span><br><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span><br><span class="hljs-comment">//创建数据存储仓库</span><br><span class="hljs-keyword">const</span> store = createStore( reducer, applyMiddleware(thunk))<br></code></pre></td></tr></table></figure></li><li>使用 thunk<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const func1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (dispatch, getState) =&gt; &#123;<br>    let timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; dispatch(&#123; type: <span class="hljs-string">&quot;close_isActive_delay&quot;</span> &#125;) &#125;, <span class="hljs-number">300</span>)<br>    dispatch(&#123; type: <span class="hljs-string">&quot;add_timer&quot;</span>, timer &#125;)<br>&#125;<br>store.dispatch(func1())<br></code></pre></td></tr></table></figure>这里创建一个func1的函数，其返回一个 <strong>thunk 函数</strong>，thunk 函数接收两个参数，并在内部写业务逻辑，得到的 action 对象通过 dispatch 注入，并最后将 thunk 函数通过 dispatch 注入到 store 中。这里有一个点需要注意：即为什么要在 thunk 函数外嵌套一层函数，而不是直接将 thunk 函数注入到 store 中？这是因为外层嵌套函数后可以传入一些自定义的参数，由于 thunk 函数接收的两个参数是固定的，因此就有必要嵌套一层函数使得 thunk 函数可以使用用户自定义的一些业务逻辑参数，例如<code>const func1 = (myname) =&gt; (dispatch, getState) =&gt; &#123;...&#125;</code></li></ol><p><strong>注意<code>store.dispatch(func1())</code>中注入的是函数的调用而非函数名。</strong><br>当然上述函数定义也可以写为：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const func1 = <span class="hljs-function"><span class="hljs-params">(xxx)</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>        (dispatch, getState) =&gt; &#123;<br>            let timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; dispatch(&#123; type: <span class="hljs-string">&quot;close_isActive_delay&quot;</span> &#125;) &#125;, <span class="hljs-number">300</span>)<br>            dispatch(&#123; type: <span class="hljs-string">&quot;add_timer&quot;</span>, timer &#125;)<br>        &#125;<br>    )<br>&#125;<br>store.dispatch(func1())<br></code></pre></td></tr></table></figure><h3 id="DropdownMenu-js"><a href="#DropdownMenu-js" class="headerlink" title="DropdownMenu.js"></a>DropdownMenu.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; createPortal &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../style/DropdownMenu.css&quot;</span><br><span class="hljs-keyword">import</span> &#123; CSSTransition &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-transition-group&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store/index&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DropdownMenu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;&#125;<br>        <span class="hljs-keyword">const</span> dom = <span class="hljs-built_in">window</span>.document<br>        <span class="hljs-built_in">this</span>.node = dom.createElement(<span class="hljs-string">&quot;div&quot;</span>)<br>        dom.body.appendChild(<span class="hljs-built_in">this</span>.node)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">window</span>.document.body.removeChild(<span class="hljs-built_in">this</span>.node)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> createPortal((<br>            &lt;div<br>                className=<span class="hljs-string">&quot;menuContainer&quot;</span><br>            &gt;<br>                &lt;CSSTransition<br>                    <span class="hljs-keyword">in</span>=&#123;<span class="hljs-built_in">this</span>.props.isActive&#125;<br>                    timeout=&#123;<span class="hljs-number">200</span>&#125;<br>                    classNames=&#123;&#123;<br>                        enter: <span class="hljs-string">&quot;menuEnter&quot;</span>,<br>                        enterActive: <span class="hljs-string">&quot;menuEnterActive&quot;</span>,<br>                        enterDone: <span class="hljs-string">&quot;menuEnterDone&quot;</span>,<br>                        exit: <span class="hljs-string">&quot;menuExit&quot;</span>,<br>                        exitActive: <span class="hljs-string">&quot;menuExitActive&quot;</span>,<br>                        exitDone: <span class="hljs-string">&quot;menuExitDone&quot;</span>,<br>                    &#125;&#125;<br>                &gt;<br>                    &lt;div className=<span class="hljs-string">&quot;dropDownMenu&quot;</span>&gt;&lt;/div&gt;<br>                &lt;/CSSTransition&gt;<br>            &lt;/div&gt;<br>        ), <span class="hljs-built_in">this</span>.node);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> DropdownMenu;<br></code></pre></td></tr></table></figure><h4 id="重难点分析-3"><a href="#重难点分析-3" class="headerlink" title="重难点分析"></a>重难点分析</h4><p>主要实践了 React-Portal，其实这里可以用脱离文档流加定位的方式实现，只是单纯的为练习而使用，React-Portal 具体使用可以参考先前的文章。</p><h2 id="页面滚动动画"><a href="#页面滚动动画" class="headerlink" title="页面滚动动画"></a>页面滚动动画</h2><h3 id="PageOneText-js"><a href="#PageOneText-js" class="headerlink" title="PageOneText.js"></a>PageOneText.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../../style/page1/PageOne.css&quot;</span><br><span class="hljs-keyword">import</span> &#123; Typography &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../store&#x27;</span>; <span class="hljs-comment">//可省略index.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../../style/page1/PageOne.css&quot;</span><br><span class="hljs-keyword">import</span> testImg <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../images/testImg.jpg&#x27;</span><br><br><span class="hljs-keyword">const</span> &#123; Title &#125; = Typography;<br><span class="hljs-keyword">const</span> &#123; Paragraph &#125; = Typography;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageOneText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = store.getState()<br>        <span class="hljs-built_in">this</span>.storeChange = <span class="hljs-built_in">this</span>.storeChange.bind(<span class="hljs-built_in">this</span>)<br>        store.subscribe(<span class="hljs-built_in">this</span>.storeChange)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">handleScroll</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.documentElement.scrollTop &gt; <span class="hljs-number">900</span>) &#123;<br>            <span class="hljs-keyword">const</span> action = &#123;<br>                type: <span class="hljs-string">&quot;handle_scroll&quot;</span>,<br>            &#125;<br>            store.dispatch(action)<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.documentElement.scrollTop &lt; <span class="hljs-number">550</span>) &#123;<br>            <span class="hljs-keyword">const</span> action = &#123;<br>                type: <span class="hljs-string">&quot;handle_noscroll&quot;</span>,<br>            &#125;<br>            store.dispatch(action)<br>        &#125;<br>        <span class="hljs-comment">// console.log(document.documentElement.scrollTop)</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">storeChange</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(store.getState())<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 挂载 onscroll 监听事件，object.onscroll = function()</span><br>        <span class="hljs-built_in">window</span>.onscroll = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">this</span>.handleScroll() &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div className=<span class="hljs-string">&quot;textContainer&quot;</span>&gt;<br>                &lt;img className=&#123;<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.pgoneClassNames.img&#125;</span>`</span>&#125; src=&#123;testImg&#125; alt=<span class="hljs-string">&quot;&quot;</span> /&gt;<br>                &lt;Title className=&#123;<span class="hljs-string">`title <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.pgoneClassNames.title&#125;</span>`</span>&#125;&gt;&#123;<span class="hljs-built_in">this</span>.props.title&#125;&lt;/Title&gt;<br>                &lt;Paragraph<br>                    ellipsis=&#123;&#123; <span class="hljs-attr">rows</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">expandable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">symbol</span>: <span class="hljs-string">&#x27;more&#x27;</span> &#125;&#125;<br>                    className=&#123;<span class="hljs-string">`texts paragraph <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.pgoneClassNames.text&#125;</span>`</span>&#125;<br>                &gt;<br>                    &#123;<span class="hljs-built_in">this</span>.props.text&#125;<br>                &lt;/Paragraph&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PageOneText;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">页面滚动动画机制：</span><br><span class="hljs-comment">页面滚动时界面会不断渲染，因此在componentDidMount生命周期中可以监听scrollTop页面位置，作为动画入场条件。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="重难点分析-4"><a href="#重难点分析-4" class="headerlink" title="重难点分析"></a>重难点分析</h4><p><strong>页面滚动事件</strong></p><ol><li>处理页面滚动的函数<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">handleScroll</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (document<span class="hljs-selector-class">.documentElement</span><span class="hljs-selector-class">.scrollTop</span> &gt; <span class="hljs-number">900</span>) &#123;<br>        const action = &#123;<br>            type: <span class="hljs-string">&quot;handle_scroll&quot;</span>,<br>        &#125;<br>        store.dispatch(action)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (document<span class="hljs-selector-class">.documentElement</span><span class="hljs-selector-class">.scrollTop</span> &lt; <span class="hljs-number">550</span>) &#123;<br>        const action = &#123;<br>            type: <span class="hljs-string">&quot;handle_noscroll&quot;</span>,<br>        &#125;<br>        store.dispatch(action)<br>    &#125;<br>    <span class="hljs-comment">// console.log(document.documentElement.scrollTop)</span><br>&#125;<br></code></pre></td></tr></table></figure><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/documentElement">document.documentElement</a>返回document文档的根节点元素，例如HTML文档则返回<code>&lt;html&gt;</code>元素节点。<br>通过<code>document.documentElement.scrollTop</code>可以获得HTML文档滚动条距离其顶部的高度，由于显示分辨率的不同，scrollTop也不同，具体调试滚动阈值的时候可以通过<code>console.log(document.documentElement.scrollTop)</code>来实时打印确定。</li></ol><blockquote><p>题外话：document.documentElement和document.body区别<br>body是DOM对象里的body子节点，即body标签<br>documentElement 是整个节点树的根节点root</p></blockquote><ol start="2"><li>挂载监听事件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 挂载 onscroll 监听事件，object.onscroll = function()</span><br>    <span class="hljs-built_in">window</span>.onscroll = <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">this</span>.handleScroll() &#125;<br>&#125;<br></code></pre></td></tr></table></figure>上述<code>handleScroll()</code>只定义了监听事件的处理函数，我们还需要在合适的位置将监听函数挂载。通常用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onscroll">window.onScroll</a>为当前页面的页面滚动事件添加事件处理函数。<br>我们将页面滚动监听放在<code>componentDidMount</code>中，在页面组件渲染完成后挂载监听事件，当用户滚动页面时会不断触发监听事件所添加的事件处理函数<code>handleScroll</code>，当滚动距离超过阈值时，执行动画操作。</li></ol><h3 id="PageOne-js"><a href="#PageOne-js" class="headerlink" title="PageOne.js"></a>PageOne.js</h3><p>用于包裹<code>&lt;PageOneText /&gt;</code>组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../../style/page1/PageOne.css&quot;</span><br><span class="hljs-keyword">import</span> PageOneText <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./PageOneText&#x27;</span><br><span class="hljs-keyword">import</span> testImg <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../images/testImg.jpg&#x27;</span><br><span class="hljs-keyword">import</span> pgoneBackground <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../images/pgoneBackground.png&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageOne</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;&#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> itemList = [<br>            &#123;<br>                title: <span class="hljs-string">&quot;h1. Title1&quot;</span>,<br>                text: <span class="hljs-string">&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\</span><br><span class="hljs-string">                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\</span><br><span class="hljs-string">                XXXXXXXXXXXXXXXXXXxxxxxxxxxxxxxxx\</span><br><span class="hljs-string">                xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\</span><br><span class="hljs-string">                xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>,<br>                imgSrc: testImg,<br>            &#125;,<br>            &#123;<br>                title: <span class="hljs-string">&quot;h2. Title2&quot;</span>,<br>                text: <span class="hljs-string">&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\</span><br><span class="hljs-string">                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\</span><br><span class="hljs-string">                XXXXXXXXXXXXXXXXXXxxxxxxxxxxxxxxx\</span><br><span class="hljs-string">                xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\</span><br><span class="hljs-string">                xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>,<br>                imgSrc: testImg,<br>            &#125;,<br>            &#123;<br>                title: <span class="hljs-string">&quot;h3. Title3&quot;</span>,<br>                text: <span class="hljs-string">&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\</span><br><span class="hljs-string">                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\</span><br><span class="hljs-string">                XXXXXXXXXXXXXXXXXXxxxxxxxxxxxxxxx\</span><br><span class="hljs-string">                xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\</span><br><span class="hljs-string">                xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>,<br>                imgSrc: testImg,<br>            &#125;,<br>        ]<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div className=<span class="hljs-string">&quot;pgOnePlaceholder&quot;</span>&gt;<br>                &lt;img<br>                    src=&#123;pgoneBackground&#125;<br>                    style=&#123;&#123;<br>                        opacity: <span class="hljs-number">1</span>,<br>                        width: <span class="hljs-string">&quot;100%&quot;</span>,<br>                        height: <span class="hljs-string">&quot;100%&quot;</span>,<br>                        position: <span class="hljs-string">&quot;absolute&quot;</span>, <span class="hljs-comment">//脱离文档流，但是基于父级position:&quot;relative&quot;定位，置于背景的一种方法</span><br>                    &#125;&#125;<br>                    alt=<span class="hljs-string">&quot;&quot;</span> /&gt;<br>                &#123;<br>                    itemList.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> (<br>                        &lt;PageOneText<br>                            key=&#123;index&#125;<br>                            imgSrc=&#123;item.imgSrc&#125;<br>                            title=&#123;item.title&#125;<br>                            text=&#123;item.text&#125; /&gt;<br>                    ))<br>                &#125;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PageOne;<br></code></pre></td></tr></table></figure><h1 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h1><p>关于 CSS 动画，这里单独拿出一块来讲，因为这块踩的坑比较多。<br>我在使用 CSS 动画时，前期采用了 React 官方的一个动画库 <code>react-transition-group</code> ，但是由于教程比较少，一些问题得不到解决，所以后面改用了 CSS 的 keyframe 帧动画。</p><h2 id="CSSTransition"><a href="#CSSTransition" class="headerlink" title="CSSTransition"></a>CSSTransition</h2><p><a href="https://reactcommunity.org/react-transition-group/css-transition">react-transition-group CSSTransition</a><br>使用方法：</p><ol><li>安装 react-transition-group<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm install --<span class="hljs-built_in">save</span> react-transition-<span class="hljs-built_in">group</span><br></code></pre></td></tr></table></figure></li><li>配置 react-transition-group<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> &#123; CSSTransition &#125; <span class="hljs-keyword">from</span> &#x27;react-transition-<span class="hljs-keyword">group</span>&#x27;<br></code></pre></td></tr></table></figure></li><li>使用 CSSTransition<br>用<code>&lt;CSSTransition&gt;&lt;/ CSSTransition&gt;</code>标签包裹需要动画的组件(只能是一个整体，即多个子组件需要用<code>&lt;div&gt;</code>包裹)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">CSSTransition</span></span><br><span class="hljs-tag">    <span class="hljs-attr">in</span>=<span class="hljs-string">&#123;&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">classNames</span>=<span class="hljs-string">&#123;&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">timeout</span>=<span class="hljs-string">&#123;200&#125;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">onEnter</span>=<span class="hljs-string">&#123;(el)</span>=&gt;</span>(...)&#125;<br>    ...<br>&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">subComponent</span> /&gt;</span><br><span class="hljs-tag">&lt;/ <span class="hljs-attr">CSSTransition</span>&gt;</span><br></code></pre></td></tr></table></figure><code>&lt;CSSTransition&gt;</code> 标签参数参考官方文档，必要的参数为<code>in, classNames, timeout</code>，in 参数接收 true/false，表示动画执行的条件；classNames 参数设定动画的CSS样式；timeout 设定动画执行时间。<br>classNames 要区别于 className，其次，classNames 有两种声明方式：<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean">classNames = &#123;&#123;<br>    enter: <span class="hljs-string">&quot;xx&quot;</span>,<br>    enterActive: <span class="hljs-string">&quot;xxx&quot;</span>,<br>    enterDone: <span class="hljs-string">&quot;xxxx&quot;</span>,<br>&#125;&#125;<br>##########<br>.xx &#123;&#125;<br>.xxx &#123;&#125;<br>.xxxx &#123;&#125;<br></code></pre></td></tr></table></figure>或者<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">classNames = <span class="hljs-string">&quot;xx&quot;</span><br>##########<br>.xx-enter &#123;&#125;<br>.xx-enter-active &#123;&#125;<br>.xx-enter-done &#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="使用CSSTransition的一些坑"><a href="#使用CSSTransition的一些坑" class="headerlink" title="使用CSSTransition的一些坑"></a>使用CSSTransition的一些坑</h2><p>无法设置目标的初始状态，例如一些淡入淡出的效果，目标未进行动画的时候理论上应该隐藏在用户视野之外。但在使用CSSTransition动画时，若设置目标 <code>opacity:0</code>，则无法播放动画效果。<br><strong>可能原因：</strong><br>目标还未挂载渲染时候，<code>&lt;CSSTransition&gt;</code>已经挂载，后续的CSS样式遮盖了动画效果。目前没有什么比较好的解决方法。此外，目标组件内容若是接收传递的props，也会出现上述问题。因此，在PageOne 页面制作的时候，采用了 keyframe 帧动画。</p><h1 id="CSS-Keyframes"><a href="#CSS-Keyframes" class="headerlink" title="CSS Keyframes"></a>CSS Keyframes</h1><p>参考链接：<br><a href="https://www.w3cplus.com/css3/CSS3-animation.html">CSS动画 </a></p><h2 id="定义关键帧"><a href="#定义关键帧" class="headerlink" title="定义关键帧"></a>定义关键帧</h2><p><code>@keyframes 关键帧名称 &#123;&#125;</code><br>其中 <code>0%, 100%</code> 代表关键帧位置；<code>opacity</code> 表示透明度，<code>transform</code> 表示相对于目标初始位置的位移。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> leftToRight &#123;<br>    0%&#123;<br>        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>);<br>    &#125;<br>    100%&#123;<br>        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@keyframes</span> topToBottom &#123;<br>    0%&#123;<br>        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateY</span>(-<span class="hljs-number">100%</span>);<br>    &#125;<br>    100%&#123;<br>        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateY</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定义animation动画"><a href="#定义animation动画" class="headerlink" title="定义animation动画"></a>定义animation动画</h2><p><a href="https://www.w3school.com.cn/cssref/pr_animation.asp">CSS3 animation</a><br><code>animation: name duration timing-function delay iteration-count direction fill-mode;</code>包含以下几个参数：</p><ol><li>name: keyframes 的动画样式名称</li><li>duration: 动画时长</li><li>timing-function: ease-in 快进慢出；ease-out 慢进快出；ease-in-out；…</li><li>delay：动画延迟，等待n秒后开始动画 <a href="https://www.w3school.com.cn/cssref/pr_animation-delay.asp">animation-delay</a></li><li>iteration-count：循环播放次数</li><li>direction：方向</li><li>fill-mode：规定动画在播放之前或之后，其动画效果是否可见。 none | forwards | backwards | <strong>both</strong>; <a href="https://www.w3school.com.cn/cssref/pr_animation-fill-mode.asp">CSS3 animation-fill-mode</a></li></ol><p>其中 animation-fill-mode 是解决动画目标初始化的关键，当 animation-fill-mode 设定为 both 时，以上述代码为例，动画播放前，目标元素动画效果可见，其为<code>opacity:0; transform:translateX(-100%)</code>，即隐藏，而动画播放结束后，目标元素动画效果将会停留在关键帧<code>100%</code>的地方，即显示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item_row</span> &#123;<br>    <span class="hljs-attribute">animation</span>: leftToRight <span class="hljs-number">1000ms</span> both ease-out;<br>&#125;<br><br><span class="hljs-selector-class">.item_delay_row</span> &#123;<br>    <span class="hljs-attribute">animation</span>: leftToRight <span class="hljs-number">1000ms</span> ease-out <span class="hljs-number">100ms</span> both;<br>&#125;<br><br><span class="hljs-selector-class">.item_column</span> &#123;<br>    <span class="hljs-attribute">animation</span>: topToBottom <span class="hljs-number">1500ms</span> both ease-out;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定义触发动画的监听事件"><a href="#定义触发动画的监听事件" class="headerlink" title="定义触发动画的监听事件"></a>定义触发动画的监听事件</h2><p>监听事件由上述的页面滚动触发。首先我们需要设定一个充当占位的样式(可为空)，此处<a href="https://www.w3school.com.cn/cssref/pr_class_visibility.asp">visibility</a>设为hidden表示该元素不可见但仍保留其布局空间。当监听事件触发时，我们向className中添加相应动画的CSS样式，替换原有的占位样式即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.hidden</span> &#123;<br>    <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>`$&#123;<span class="hljs-attr">this.state.pgoneClassNames.img</span>&#125;`&#125; <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;testImg&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Title</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">title</span> $&#123;<span class="hljs-attr">this.state.pgoneClassNames.title</span>&#125;`&#125;&gt;</span>&#123;this.props.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Title</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Paragraph</span></span></span><br><span class="xml">    ellipsis=</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">rows:</span> <span class="hljs-number">5</span>, expandable: <span class="hljs-literal">true</span>, symbol: <span class="hljs-string">&#x27;more&#x27;</span> &#125;&#125;</span><br><span class="xml">    className=&#123;`texts paragraph $&#123;this.state.pgoneClassNames.text&#125;`&#125;</span><br><span class="xml">&gt;</span><br><span class="xml">    &#123;this.props.text&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Paragraph</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>采用 CSS Keyframes 的另一个好处是能够将动画 CSS 样式和初始 CSS 样式分开，例如下述代码<code>title $&#123;xxx&#125;</code>，用 ES6 模板字符串的方式，title 是固定的初始样式，<code>$&#123;xxx&#125;</code>内可以传入动态的动画样式。</p><h1 id="CSS-样式布局心得"><a href="#CSS-样式布局心得" class="headerlink" title="CSS 样式布局心得"></a>CSS 样式布局心得</h1><p>调整CSS样式心得：</p><ol><li>从网页打开F12，选择元素查看其className进行定位。</li><li>width,height 宽高100%(或百分比设置)针对的是上一级元素(父级元素)，<br>因此若多余空白的<div>包裹应将其删除，或者将上级空白div设置宽高100%。</div></li></ol>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>React</tag>
      
      <tag>React-Portal</tag>
      
      <tag>Redux</tag>
      
      <tag>Redux-thunk</tag>
      
      <tag>CSS-animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客备份</title>
    <link href="/2020/12/08/hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/"/>
    <url>/2020/12/08/hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo博客备份"><a href="#hexo博客备份" class="headerlink" title="hexo博客备份"></a>hexo博客备份</h1><p>参考链接：<br><a href="https://www.itrhx.com/2019/09/29/A53-hexo-backup/">使用 Hexo-Git-Backup 插件备份你的 Hexo 博客 </a><br><a href="https://blog.csdn.net/qq_41793001/article/details/103151182">使用hexo-git-backup插件备份博客源文件</a><br><a href="https://github.com/coneycode/hexo-git-backup">hexo-git-backup</a></p><hr><p>利用 <code>hexo-git-backup</code> 插件进行备份</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>安装备份插件<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ npm install hexo-git-backup@0.0.91 <span class="hljs-params">--save</span>  <span class="hljs-string">//Hexo</span> <span class="hljs-keyword">version</span> = 2.x.x<br>$ npm install hexo-git-backup <span class="hljs-params">--save</span>  <span class="hljs-string">//Hexo</span> <span class="hljs-keyword">version</span> &gt; 3.x.x<br></code></pre></td></tr></table></figure></li><li>到 Hexo 博客根目录的 <code>_config.yml</code> 配置文件里添加以下配置：(我使用了fluid主题，所以需要在<code>_config.fluid.yml</code>中同步配置)<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">backup</span>:<br>  <span class="hljs-attribute">type</span>: git<br>  <span class="hljs-attribute">theme</span>: fluid<br>  <span class="hljs-attribute">message</span>: Back up my blog<br>  <span class="hljs-attribute">repository</span>:<br>    <span class="hljs-attribute">github</span>: git<span class="hljs-variable">@github</span>.<span class="hljs-attribute">com</span>:coneycode/hexo-git-backup.git,hexo<br></code></pre></td></tr></table></figure>参数解释：<br>theme：你要备份的主题名称<br>message：自定义提交信息<br>repository：仓库名，注意仓库地址后面要添加一个分支名，比如我创建了一个 hexo 分支</li><li>在github仓库新建分支，分支名与上述配置对应</li><li>此时github仓库中应存在 master(或main)和hexo ，在提交的时候只需在 master 中使用以下命令备份你的博客即可：<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo backup<br></code></pre></td></tr></table></figure>或者使用以下简写命令也可以：<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo b<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Portal 实战——登陆弹窗</title>
    <link href="/2020/12/08/React%20Portal%20%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%99%BB%E9%99%86%E5%BC%B9%E7%AA%97/"/>
    <url>/2020/12/08/React%20Portal%20%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%99%BB%E9%99%86%E5%BC%B9%E7%AA%97/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Portal-实战——登陆弹窗"><a href="#React-Portal-实战——登陆弹窗" class="headerlink" title="React Portal 实战——登陆弹窗"></a>React Portal 实战——登陆弹窗</h1><h2 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h2><p>点击初始界面登录按钮，跳转到登录路径，用 Portal 创建一个登录弹窗以及灰色蒙版背景。<br>要求：</p><ol><li>同时保证原始界面内容保留并显示在蒙版后。</li><li>点击退出按钮后，重定向到“个人档案”页面。</li></ol><p>效果图：<br><img src="/img/posts_img/20201208094720091_21532.png"></p><h2 id="登陆界面代码"><a href="#登陆界面代码" class="headerlink" title="登陆界面代码"></a>登陆界面代码</h2><p>直接解读代码内容<br><strong>重点：</strong></p><ol><li>使用 Portal 需要在组件开头导入 <code>ReactDOM.createPortal()</code> 方法，即 <code>import &#123; createPortal &#125; from &#39;react-dom&#39;</code></li><li>掌握 Portal 的组织结构：创建DOM节点，添加JSX元素，在组件销毁前移除DOM节点</li><li>React Router 重定向</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; createPortal &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../index.css&quot;</span><br><span class="hljs-keyword">import</span> registerPng <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../images/register.png&#x27;</span><br><span class="hljs-comment">//AntDesign调用</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span><br><span class="hljs-keyword">import</span> &#123; Input, Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span><br><span class="hljs-keyword">import</span> &#123; EyeInvisibleOutlined, EyeTwoTone &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ant-design/icons&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Register</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            isRender: <span class="hljs-literal">true</span>,<br>        &#125;<br>        <span class="hljs-built_in">this</span>.redirect = <span class="hljs-built_in">this</span>.redirect.bind(<span class="hljs-built_in">this</span>)<br><br>        <span class="hljs-keyword">const</span> dom = <span class="hljs-built_in">window</span>.document;<br>        <span class="hljs-built_in">this</span>.node = dom.createElement(<span class="hljs-string">&quot;div&quot;</span>)<br>        <span class="hljs-built_in">this</span>.node.setAttribute(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;account&quot;</span>) <span class="hljs-comment">//this.node.id = &quot;account&quot;</span><br>        dom.body.appendChild(<span class="hljs-built_in">this</span>.node)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">redirect</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 多余步骤，跳转时其实已经执行了componentWillUnmount；</span><br>        <span class="hljs-comment">// 此处只做关于组件销毁的常用方法记录；</span><br>        <span class="hljs-built_in">this</span>.setState(&#123;<br>            isRender: <span class="hljs-literal">true</span>,<br>        &#125;)<br>        <span class="hljs-built_in">this</span>.props.history.push(<span class="hljs-string">&quot;/person/齐天大圣&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">window</span>.document.body.removeChild(<span class="hljs-built_in">this</span>.node)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> createPortal(<br>            <span class="hljs-built_in">this</span>.state.isRender ? (<br>                &lt;div&gt;<br>                    &lt;div className=<span class="hljs-string">&quot;beijing&quot;</span>&gt;<br>                        &lt;div className=<span class="hljs-string">&quot;dengLu&quot;</span>&gt;<br>                            &lt;img<br>                                src=&#123;registerPng&#125;<br>                                style=&#123;&#123;<br>                                    borderRadius: <span class="hljs-string">&quot;15px 15px 0 0&quot;</span>,<br>                                    margin: <span class="hljs-number">0</span>,<br>                                    padding: <span class="hljs-number">0</span>,<br>                                &#125;&#125;<br>                            /&gt;<br>                            &lt;div className=<span class="hljs-string">&quot;inputContainer&quot;</span>&gt;<br>                                &lt;h3 style=&#123;&#123; <span class="hljs-attr">marginLeft</span>: <span class="hljs-string">&quot;40px&quot;</span> &#125;&#125;&gt;账户&lt;/h3&gt;<br>                                &lt;Input<br>                                    placeholder=<span class="hljs-string">&quot;Please enter account...&quot;</span><br>                                    className=<span class="hljs-string">&quot;inputStyle&quot;</span><br>                                    style=&#123;&#123;<br>                                        width: <span class="hljs-string">&quot;70%&quot;</span>,<br>                                        height: <span class="hljs-string">&quot;30px&quot;</span>,<br>                                        marginRight: <span class="hljs-string">&quot;40px&quot;</span><br>                                    &#125;&#125;<br>                                /&gt;<br>                            &lt;/div&gt;<br>                            &lt;div className=<span class="hljs-string">&quot;inputContainer&quot;</span>&gt;<br>                                &lt;h3 style=&#123;&#123; <span class="hljs-attr">marginLeft</span>: <span class="hljs-string">&quot;40px&quot;</span> &#125;&#125;&gt;密码&lt;/h3&gt;<br>                                &lt;Input.Password<br>                                    placeholder=<span class="hljs-string">&quot;input password&quot;</span><br>                                    iconRender=&#123;<span class="hljs-function"><span class="hljs-params">visible</span> =&gt;</span> (visible ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">EyeTwoTone</span> /&gt;</span></span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">EyeInvisibleOutlined</span> /&gt;</span></span>)&#125;<br>                                    style=&#123;&#123;<br>                                        width: <span class="hljs-string">&quot;70%&quot;</span>,<br>                                        height: <span class="hljs-string">&quot;30px&quot;</span>,<br>                                        marginRight: <span class="hljs-string">&quot;40px&quot;</span><br>                                    &#125;&#125;<br>                                /&gt;<br>                            &lt;/div&gt;<br>                            &lt;div className=<span class="hljs-string">&quot;confirmAction&quot;</span>&gt;<br>                                &lt;Button&gt;确认&lt;/Button&gt;<br>                                &lt;Button onClick=&#123;<span class="hljs-built_in">this</span>.redirect&#125;&gt;取消&lt;/Button&gt;<br>                            &lt;/div&gt;<br>                        &lt;/div&gt;<br>                    &lt;/div&gt;<br>                &lt;/div&gt;<br>            ) : <span class="hljs-literal">null</span><br>            , <span class="hljs-built_in">this</span>.node<br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Register;<br></code></pre></td></tr></table></figure><h3 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h3><ol><li>React v16 Portal 创建的调用方法<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; createPortal &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span><br></code></pre></td></tr></table></figure></li><li>Portal 主体<br>constructor()构造函数中创建DOM节点<br>(给DOM节点添加id属性)<br>将DOM节点添加到<code>&lt;body&gt;</code>中<br>用<code>createPortal</code>方法创建 Portal，传入可渲染子元素以及挂载的DOM节点，并在<code>render</code>中返回<br>在<code>componentWillUnmount</code>中，即组件销毁(路由跳转，display:none等都算将组建销毁)前，移除该DOM节点<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Register</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        ...<br>        <span class="hljs-comment">//创建dom节点</span><br>        <span class="hljs-keyword">const</span> dom = <span class="hljs-built_in">window</span>.document;<br>        <span class="hljs-built_in">this</span>.node = dom.createElement(<span class="hljs-string">&quot;div&quot;</span>)<br>        <span class="hljs-built_in">this</span>.node.setAttribute(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;account&quot;</span>) <span class="hljs-comment">//this.node.id = &quot;account&quot;</span><br>        dom.body.appendChild(<span class="hljs-built_in">this</span>.node)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">window</span>.document.body.removeChild(<span class="hljs-built_in">this</span>.node)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> createPortal(<br>            (<br>                &lt;div&gt;<br>                    ...<br>                &lt;/div&gt;<br>            )<br>            , <span class="hljs-built_in">this</span>.node<br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Register;<br></code></pre></td></tr></table></figure></li><li>React Router 路由重定向<br>路由重定向可以实现路由路径的直接跳转，例如进入某一组件，在碰到重定向后自动跳转到另一组件。<br>路由重定向可以分为：<strong>标签式重定向</strong> 和 <strong>编程式重定向</strong><br>详细参考 Router 路由文章，此处用了编程式的重定向方法<code>this.props.history.push(&quot;url&quot;)</code>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">redirect</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 多余步骤，跳转时其实已经执行了componentWillUnmount；</span><br>    <span class="hljs-comment">// 此处只做关于组件销毁的常用方法记录；</span><br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>        isRender: <span class="hljs-literal">true</span>,<br>    &#125;)<br>    <span class="hljs-built_in">this</span>.props.history.push(<span class="hljs-string">&quot;/person/齐天大圣&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>React-Portal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Portal</title>
    <link href="/2020/12/08/React_Portal/"/>
    <url>/2020/12/08/React_Portal/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Portal"><a href="#React-Portal" class="headerlink" title="React Portal"></a>React Portal</h1><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/29880992">传送门：React Portal</a><br>官方网站：<a href="https://reactjs.org/docs/portals.html#___gatsby">Portals-React</a></p><hr><h2 id="Portal-–-传送门"><a href="#Portal-–-传送门" class="headerlink" title="Portal – 传送门"></a>Portal – 传送门</h2><p>为什么React需要传送门？<br>React Portal之所以叫Portal，因为做的就是和“传送门”一样的事情：<strong>render到一个组件里面去，实际改变的是网页上另一处的DOM结构。</strong><br>在React中，一切皆为组件，用组件可以表示一切界面中发生的逻辑，不过，有些特例处理起来还比较麻烦，比如，某个组件在渲染时，在某种条件下需要显示一个对话框(Dialog)，这该怎么做呢？<br>最直观的做法，就是直接在JSX中把Dialog画出来，像下面代码的样子。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;<br>   &lt;<span class="hljs-keyword">div</span>&gt; ... &lt;/<span class="hljs-keyword">div</span>&gt;<br>   &#123; needDialog ? &lt;Dialog /&gt; : <span class="hljs-keyword">null</span> &#125;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>问题是，我们写一个Dialog组件，就这么渲染的话，Dialog最终渲染产生的HTML就存在于上面JSX产生的HTML一起了，类似下面这样。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;foo&quot;</span>&gt;<br>   &lt;<span class="hljs-keyword">div</span>&gt; ... &lt;/<span class="hljs-keyword">div</span>&gt;<br>   &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;Dialog Content&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>可是问题来了，对话框应该是一个独立的组件，通常应该显示在屏幕的最中间，现在Dialog被包在其他组件中，要用CSS的position属性控制Dialog位置，就要求从Dialog往上一直到body没有其他postion是relative的元素干扰，这有点难为作为通用组件的Dialog，毕竟，谁管得住所有组件不用position呢。还有一点，Dialog的样式，因为包在其他元素中，各种样式纠缠，CSS样式太容易搞成一坨浆糊了。<br>因此，React 就引入了 Portal 传送门的概念。</p><h2 id="React-v16-之前的传送门实现方法"><a href="#React-v16-之前的传送门实现方法" class="headerlink" title="React v16 之前的传送门实现方法"></a>React v16 之前的传送门实现方法</h2><p>为什么要讲旧版本的实现方法呢？因为旧版本更能体现传送门实现的一个思想，而新版本更多的是一个封装和便于使用，理解了旧版本就可以更好地使用新版本 Portal 了。<br>在v16之前，实现“传送门”，要用到两个秘而不宣的React API</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">unstable_renderSubtreeIntoContainer</span><br><span class="hljs-attribute">unmountComponentAtNode</span><br></code></pre></td></tr></table></figure><ul><li>第一个unstable_renderSubtreeIntoContainer。这个API的作用就是建立“传送门”，可以把JSX代表的组件结构塞到传送门里面去，让他们在传送门的另一端渲染出来。</li><li>第二个unmountComponentAtNode用来清理第一个API的副作用，通常在unmount的时候调用，不调用的话会造成资源泄露的。</li></ul><p>一个通用的Dialog组件的实现差不多是这样，注意看renderPortal中的注释。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;unstable_renderSubtreeIntoContainer, unmountComponentAtNode&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dialog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> doc = <span class="hljs-built_in">window</span>.document;<br>    <span class="hljs-built_in">this</span>.node = doc.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    doc.body.appendChild(<span class="hljs-built_in">this</span>.node);<br><br>    <span class="hljs-built_in">this</span>.renderPortal(<span class="hljs-built_in">this</span>.props);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.renderPortal(<span class="hljs-built_in">this</span>.props);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    unmountComponentAtNode(<span class="hljs-built_in">this</span>.node);<br>    <span class="hljs-built_in">window</span>.document.body.removeChild(<span class="hljs-built_in">this</span>.node);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">renderPortal</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    unstable_renderSubtreeIntoContainer(<br>      <span class="hljs-built_in">this</span>, <span class="hljs-comment">//代表当前组件</span><br>      &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;<br>        &#123;props.children&#125; <span class="hljs-comment">//也可以是其他自定义JSX结构</span><br>      &lt;<span class="hljs-regexp">/div&gt;, /</span><span class="hljs-regexp">/ 塞进传送门的JSX</span><br><span class="hljs-regexp">      this.node /</span><span class="hljs-regexp">/ 传送门另一端的DOM node</span><br><span class="hljs-regexp">    );</span><br><span class="hljs-regexp">  &#125;</span><br><span class="hljs-regexp">&#125;</span><br></code></pre></td></tr></table></figure><ol><li>首先，**<code>render</code>函数不要返回有意义的<code>JSX</code>(即返回<code>null</code>)**，也就说说这个组件通过正常生命周期什么都不画，要是画了，那画出来的HTML/DOM就直接出现在使用Dialog的位置了，这不是我们想要的。</li><li>在**<code>componentDidMount</code><strong>里面，</strong>利用原生API来在body上创建一个div**，这个div的样式绝对不会被其他元素的样式干扰。</li><li>然后，无论<code>componentDidMount</code>还是<code>componentDidUpdate</code>，都<strong>调用一个<code>renderPortal</code>来往“传送门”里塞东西</strong>。</li><li>在<code>renderPortal</code>中，利用<code>unstable_renderSubtreeIntoContainer</code>函数往直前创建的<code>div</code>里塞<code>JSX</code>，这里我们用的<code>JSX</code>是这样。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;<br>   &#123;props.children&#125;<br>&lt;/div&gt;<br><span class="hljs-comment">//--------------------</span><br><span class="hljs-comment">//调用 Dialog 组件时，可以加上任意的子组件。</span><br>&lt;Dialog&gt;<br>  What ever shit<br>  &lt;div&gt;Hello&lt;/div&gt;<br>  &lt;p&gt;World&lt;/p&gt;<br>&lt;/Dialog&gt;<br></code></pre></td></tr></table></figure></li></ol><p>总结，这个Dialog组件做得事情是这样：</p><ul><li>它什么都不给自己画，render返回一个null就够了；</li><li>它做得事情是通过调用renderPortal把要画的东西画在DOM树上另一个角落。</li></ul><h2 id="React-v16-Portal"><a href="#React-v16-Portal" class="headerlink" title="React v16 Portal"></a>React v16 Portal</h2><p>正因为 Portal 的强大能力，React v16 开始正式支持 Portal。<br>在v16中，使用Portal创建Dialog组件简单多了，不需要牵扯到componentDidMount、componentDidUpdate，也不用调用API清理Portal，关键代码在render中，像下面这样就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;createPortal&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dialog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(...arguments);<br><br>    <span class="hljs-keyword">const</span> doc = <span class="hljs-built_in">window</span>.document;<br>    <span class="hljs-built_in">this</span>.node = doc.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    doc.body.appendChild(<span class="hljs-built_in">this</span>.node);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">window</span>.document.body.removeChild(<span class="hljs-built_in">this</span>.node);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> createPortal(<br>      &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;<br>        &#123;<span class="hljs-built_in">this</span>.props.children&#125;<br>      &lt;<span class="hljs-regexp">/div&gt;, /</span><span class="hljs-regexp">/塞进传送门的JSX</span><br><span class="hljs-regexp">      this.node /</span><span class="hljs-regexp">/传送门的另一端DOM node</span><br><span class="hljs-regexp">    );</span><br><span class="hljs-regexp">  &#125;</span><br><span class="hljs-regexp">&#125;</span><br></code></pre></td></tr></table></figure><p>整体思想是类似的：</p><ol><li>在 <code>constructor</code> 中，获取 DOM，用原生 API 创建节点。</li><li>将该节点加载到 DOM 文档树的 body 部分。</li><li>调用 <code>createPortal(child,container)</code> 方法创建新的 JSX 元素(即构造新组件)。**<code>createPortal</code>方法接收两个参数，<code>child</code>是任何可渲染的React子元素，例如元素，字符串或片段。<code>container</code>是将被传送到的目标节点(DOM元素),它会将<code>child</code>插入<code>container</code>中，并且将<code>child</code>传送到<code>container</code>元素内的最底部。**</li><li>在组件销毁时调用<code>componentWillUnmout</code>将 body 中的节点<code>&lt;div&gt;&lt;/div&gt;</code>移除。</li><li>在写模态框时，用了portal，就不会完全挡死，只需调节z-Index，可以覆盖页面上的任意元素(存疑，video，canvas等这类元素未试过)。</li></ol><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>v16之前的React Portal实现方法，有一个小小的缺陷，就是Portal是单向的，内容通过Portal传到另一个出口，在那个出口DOM上发生的事件是不会冒泡传送回进入那一端的。具体详情可以看<a href="https://reactjs.org/docs/portals.html#___gatsby">官方文档</a>，有详细的说明。</p><p>代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;onDialogClick&#125;</span>&gt;</span>   <br>   <span class="hljs-tag">&lt;<span class="hljs-name">Dialog</span>&gt;</span><br>     What ever shit<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在Dialog画出的内容上点击，onDialogClick是不会被触发的。<br>在v16中，通过Portal渲染出去的DOM，事件是会冒泡从传送门的入口端冒出来的，上面的onDialogClick也就会被调用到了。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><a href="https://www.cnblogs.com/demodashi/p/8512647.html">React Portal 实现 Modal</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>React-Portal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Router 路由</title>
    <link href="/2020/12/07/React%20Router%20%E8%B7%AF%E7%94%B1/"/>
    <url>/2020/12/07/React%20Router%20%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Router-路由"><a href="#React-Router-路由" class="headerlink" title="React Router 路由"></a>React Router 路由</h1><h2 id="React-Router-开发环境搭建"><a href="#React-Router-开发环境搭建" class="headerlink" title="React Router 开发环境搭建"></a>React Router 开发环境搭建</h2><ol><li>安装React脚手架工具（若之前安装过了可以省略）<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> -g <span class="hljs-keyword">create</span>-react-app<br></code></pre></td></tr></table></figure></li><li>创建项目<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">D:  <span class="hljs-regexp">//</span>进入D盘<br>mkdir ReactRouterDemo   <span class="hljs-regexp">//</span>创建ReactRouterDemo文件夹<br>cd ReactRouterDemo      <span class="hljs-regexp">//</span>进入文件夹<br>create-react-app demo01  <span class="hljs-regexp">//</span>用脚手架创建React项目<br>cd demo01   <span class="hljs-regexp">//</span>等项目创建完成后，进入项目目录<br>npm  start  <span class="hljs-regexp">//</span>预览项目，可跳过该步<br></code></pre></td></tr></table></figure></li><li>安装 React Router<br>在终端<code>Ctrl+丶</code>的项目目录下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save react-router-dom</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="React-Router-使用"><a href="#React-Router-使用" class="headerlink" title="React Router 使用"></a>React Router 使用</h2><h2 id="创建多个组件作为路由跳转的目标组件"><a href="#创建多个组件作为路由跳转的目标组件" class="headerlink" title="创建多个组件作为路由跳转的目标组件"></a>创建多个组件作为路由跳转的目标组件</h2><p><strong>组件目录树: 新建<code>components</code>文件夹存放组件</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">demo_router_01<br>└─ src<br>  ├─ components<br>     ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Analysis</span>.</span></span>js<br>     ├─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Home</span>.</span></span>js<br>     └─ <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Person</span>.</span></span>js<br></code></pre></td></tr></table></figure><p><strong><code>Home.js</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> homePng <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../images/Home.png&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../index.css&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Home</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;&#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div className=<span class="hljs-string">&quot;homePage&quot;</span>&gt;<br>                    &lt;img className=<span class="hljs-string">&quot;img&quot;</span> src=&#123;homePng&#125; alt=<span class="hljs-string">&quot;&quot;</span> /&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Home;<br></code></pre></td></tr></table></figure><p><strong><code>Analysis.js</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> analysisPng <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../images/Analysis.png&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../index.css&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Analysis</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;  &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123; <br>        <span class="hljs-keyword">return</span> ( <br>            &lt;div&gt;<br>                &lt;img className=<span class="hljs-string">&quot;img&quot;</span> src=&#123;analysisPng&#125; alt=<span class="hljs-string">&quot;&quot;</span> /&gt;<br>            &lt;/div&gt;<br>         );<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Analysis;<br></code></pre></td></tr></table></figure><p><strong><code>Person.js</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> personPng <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../images/Person.png&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../index.css&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;  &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123; <br>        <span class="hljs-keyword">return</span> ( <br>            &lt;div&gt;<br>                &lt;img className=<span class="hljs-string">&quot;img&quot;</span> src=&#123;personPng&#125; alt=<span class="hljs-string">&quot;&quot;</span> /&gt;<br>            &lt;/div&gt;<br>         );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Person;<br></code></pre></td></tr></table></figure><h2 id="编写路由组件-React万物皆组件"><a href="#编写路由组件-React万物皆组件" class="headerlink" title="编写路由组件(React万物皆组件)"></a>编写路由组件(React万物皆组件)</h2><p><strong>新建<code>router</code>文件夹存放路由组件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; BrowserRouter <span class="hljs-keyword">as</span> Router, Route, NavLink &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home&#x27;</span><br><span class="hljs-keyword">import</span> Analysis <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Analysis&#x27;</span><br><span class="hljs-keyword">import</span> Person <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Person&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../index.css&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../images/iconfont.css&quot;</span><br><br><span class="hljs-keyword">const</span> HomePage = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> routeList = [<br>        &#123;<br>            path: <span class="hljs-string">&quot;/&quot;</span>,<br>            exact: <span class="hljs-literal">true</span>,<br>            title: <span class="hljs-string">&quot;首页&quot;</span>,<br>            component: Home,<br>            icon: <span class="hljs-string">&quot;iconfont icon-yemian-copy&quot;</span><br>        &#125;,<br>        &#123;<br>            path: <span class="hljs-string">&quot;/analysis/&quot;</span>,<br>            exact: <span class="hljs-literal">false</span>,<br>            title: <span class="hljs-string">&quot;相关性分析&quot;</span>,<br>            component: Analysis,<br>            icon: <span class="hljs-string">&quot;iconfont icon-fenxi&quot;</span><br>        &#125;,<br>        &#123;<br>            path: <span class="hljs-string">&quot;/person/&quot;</span>,<br>            exact: <span class="hljs-literal">false</span>,<br>            title: <span class="hljs-string">&quot;个人档案&quot;</span>,<br>            component: Person,<br>            icon: <span class="hljs-string">&quot;iconfont icon-icon-text-fn-documentation&quot;</span><br>        &#125;,<br>    ]<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            &lt;div&gt;<br>                &lt;div className=<span class="hljs-string">&quot;pageTop&quot;</span>&gt;<br>                    &lt;h2 className=<span class="hljs-string">&quot;pageTitle&quot;</span>&gt;社矫人员属性及轨迹数据可视化分析平台&lt;/h2&gt;<br>                &lt;/div&gt;<br>                &lt;div className=<span class="hljs-string">&quot;titleBottom&quot;</span>&gt;<br>                    &lt;Router&gt;<br>                        &lt;div className=<span class="hljs-string">&quot;leftMenu&quot;</span>&gt;<br>                            &lt;ul&gt;<br>                                &#123;<br>                                    routeList.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> (<br>                                        &lt;div className=<span class="hljs-string">&quot;subTitle&quot;</span> key=&#123;index&#125;&gt;<br>                                            &lt;i className=&#123;item.icon&#125; key=&#123;index&#125;&gt;&lt;/i&gt;<br>                                            &lt;li className=<span class="hljs-string">&quot;textItem&quot;</span>&gt;<br>                                                &lt;NavLink<br>                                                    exact=&#123;item.exact&#125; <span class="hljs-comment">//NavLink-exact: if true, 精确匹配active</span><br>                                                    to=&#123;item.path&#125;<br>                                                    key=&#123;index&#125;<br>                                                    className=<span class="hljs-string">&quot;link&quot;</span><br>                                                    activeClassName=<span class="hljs-string">&quot;activeLink&quot;</span><br>                                                &gt;&#123;item.title&#125;&lt;/NavLink&gt;<br>                                            &lt;/li&gt;<br>                                        &lt;/div&gt;<br>                                    ))<br>                                &#125;<br>                            &lt;/ul&gt;<br>                        &lt;/div&gt;<br>                        &lt;div&gt;<br>                            &#123;<br>                                routeList.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>                                    <span class="hljs-keyword">return</span> (<br>                                        &lt;Route<br>                                            exact=&#123;item.exact&#125;<br>                                            path=&#123;item.path&#125;<br>                                            key=&#123;index&#125;<br>                                            component=&#123;item.component&#125;<br>                                        &gt;&lt;/Route&gt;<br>                                    )<br>                                &#125;)<br>                            &#125;<br>                        &lt;/div&gt;<br>                    &lt;/Router&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>    )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> HomePage<br></code></pre></td></tr></table></figure><p><strong>重点：</strong></p><ol><li>上述路由组件中没有状态的变化，因此采用了无状态组件的方式书写。<strong>注意引入<code>React</code>，凡是用到<code>JSX</code>语法的都要<code>import React from &#39;react&#39;</code></strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">const</span> xxx = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;...&lt;/div&gt;<br>    )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> xxx<br></code></pre></td></tr></table></figure></li><li>开头引入<code>react-router-dom</code>，否则无法使用路由标签。**<code>NavLink</code>与<code>Link</code>相比可以在<code>active</code>时改变样式，<code>BrowserRouter as Router</code>设定别名**。<br>React Router 具体标签属性和使用可以参考<a href="https://reactrouter.com/web/api/NavLink/exact-bool">官方文档</a><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; BrowserRouter <span class="hljs-keyword">as</span> Router, Route, NavLink &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br>or <br><span class="hljs-keyword">import</span> &#123; BrowserRouter <span class="hljs-keyword">as</span> Router, Route, Link &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom</span><br></code></pre></td></tr></table></figure></li><li>开头引入路由跳转组件<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home&#x27;</span><br><span class="hljs-keyword">import</span> Analysis <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Analysis&#x27;</span><br><span class="hljs-keyword">import</span> Person <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Person&#x27;</span><br></code></pre></td></tr></table></figure></li><li>列表存放路由参数，模拟接收后台请求数据。此处采用遍历路由参数信息列表的方式搭建路由。相较于单独搭建，该方法灵活性更高。<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dts">const routeList = [<br>    &#123;<br><span class="hljs-symbol">        path:</span> <span class="hljs-string">&quot;/&quot;</span>,<br><span class="hljs-symbol">        exact:</span> true,<br><span class="hljs-symbol">        title:</span> <span class="hljs-string">&quot;首页&quot;</span>,<br><span class="hljs-symbol">        component:</span> Home,<br><span class="hljs-symbol">        icon:</span> <span class="hljs-string">&quot;iconfont icon-yemian-copy&quot;</span><br>    &#125;,<br>    &#123;<br><span class="hljs-symbol">        path:</span> <span class="hljs-string">&quot;/analysis/&quot;</span>,<br><span class="hljs-symbol">        exact:</span> false,<br><span class="hljs-symbol">        title:</span> <span class="hljs-string">&quot;相关性分析&quot;</span>,<br><span class="hljs-symbol">        component:</span> Analysis,<br><span class="hljs-symbol">        icon:</span> <span class="hljs-string">&quot;iconfont icon-fenxi&quot;</span><br>    &#125;,<br>    &#123;<br><span class="hljs-symbol">        path:</span> <span class="hljs-string">&quot;/person/&quot;</span>,<br><span class="hljs-symbol">        exact:</span> false,<br><span class="hljs-symbol">        title:</span> <span class="hljs-string">&quot;个人档案&quot;</span>,<br><span class="hljs-symbol">        component:</span> Person,<br><span class="hljs-symbol">        icon:</span> <span class="hljs-string">&quot;iconfont icon-icon-text-fn-documentation&quot;</span><br>    &#125;,<br>]<br></code></pre></td></tr></table></figure></li><li>遍历路由参数列表，设定<code>&lt;Route&gt;</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">routeList.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;Route<br>            exact=&#123;item.exact&#125;<br>            path=&#123;item.path&#125;<br>            key=&#123;index&#125;<br>            component=&#123;item.component&#125;<br>        &gt;&lt;/Route&gt;<br>    )<br>&#125;)<br></code></pre></td></tr></table></figure></li><li>遍历路由参数列表，引用<code>&lt;NavLink&gt;</code>标签<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">routeList.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> (<br>    &lt;div className=<span class="hljs-string">&quot;subTitle&quot;</span> key=&#123;index&#125;&gt;<br>        &lt;i className=&#123;item.icon&#125; key=&#123;index&#125;&gt;&lt;/i&gt;<br>        &lt;li className=<span class="hljs-string">&quot;textItem&quot;</span>&gt;<br>            &lt;NavLink<br>                exact=&#123;item.exact&#125; <span class="hljs-comment">//NavLink-exact: if true, 精确匹配active</span><br>                to=&#123;item.path&#125;<br>                key=&#123;index&#125;<br>                className=<span class="hljs-string">&quot;link&quot;</span><br>                activeClassName=<span class="hljs-string">&quot;activeLink&quot;</span><br>            &gt;&#123;item.title&#125;&lt;/NavLink&gt;<br>        &lt;/li&gt;<br>    &lt;/div&gt;<br>))<br></code></pre></td></tr></table></figure></li></ol><p><strong>注意事项：</strong></p><ul><li>注意路由的层级关系为 <code>&lt;BrowserRouter&gt;</code>&gt;<code>&lt;Route&gt;</code>=<code>&lt;Link&gt;</code>，即<code>&lt;Route&gt;</code>和<code>&lt;Link&gt;</code>都必须被包裹在 <code>&lt;BrowserRouter&gt;</code>内使用。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><code>Link</code>,<code>NavLink</code>,<code>Route</code>常用参数举例：<br>to: 跳转路径 “string”<br>path: 路由路径 “string”<br>exact: 是否精确匹配 (true/false)<br>component: 目标组件<br>activeClassName: 链接激活后的样式 “string”<br>activeStyle: 链接激活后的样式 (css obj)<br>NavLink - exact: NavLink 中定义的 exact 指确认 active 激活的精确匹配，若不设置可能导致 <code>&quot;/&quot;&quot;/post/&quot;</code>两个链接都显示 active 样式<br><code>&lt;Link to=&quot;/&quot;&gt;&lt;/Link&gt;</code><br><code>&lt;NavLink to=&quot;/post/&quot; activeClassName=&quot;activeAction&quot; activeStyle=&#123;&#123;color:red,&#125;&#125;&gt;&lt;/NavLink&gt;</code><br><code>&lt;Route path=&quot;/post/&quot; exact=true component=&quot;Home&quot;&gt;&lt;/Route&gt;</code></li><li><code>map()</code> 遍历时要给所遍历的组件加上<code>key</code>参数，且<code>key</code>要保证唯一性，此处用<code>key=&#123;index&#125;</code>，但实际应用中往往采用其他办法。</li><li><code>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code> 无序列表书写格式，不要写错(填坑)</li></ul><h3 id="精确匹配-exact"><a href="#精确匹配-exact" class="headerlink" title="精确匹配 exact"></a>精确匹配 exact</h3><p>精确匹配从字面上理解，就是你的路径信息要<strong>完全匹配</strong>成功，才可以实现跳转，匹配一部分是不行的。<br>例如路由设置了两个跳转路径<code>/</code>和<code>/post/</code>，若<code>exact=false</code>，则路由既可以跳转到<code>/</code>对应的组件，也可以跳转到<code>/post/</code>对应的组件。<br>值得一提的是，我们一般在首页<code>/</code>的时候采用精确匹配，其余时候不用，当然这也要考虑的实际项目需求，酌情而定。</p><h2 id="路由动态传参"><a href="#路由动态传参" class="headerlink" title="路由动态传参"></a>路由动态传参</h2><p>参考链接：<a href="https://www.cnblogs.com/yky-iris/p/9161907.html">路由动态传参</a></p><h3 id="通配符传参"><a href="#通配符传参" class="headerlink" title="通配符传参"></a>通配符传参</h3><p>在进行路由跳转的过程中，我们可以通过 url 向子组件传递一些参数，这也被称为路由的动态传参。<br><strong>设置动态传参的步骤如下：</strong></p><ol><li>在<code>Route</code>上设置动态传值 <strong>(设置传参的 key 值)</strong><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/post/:key&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>在<code>Link</code>上传递值 <strong>(value)</strong><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;<span class="hljs-keyword">Link</span> <span class="hljs-keyword">to</span>=<span class="hljs-string">&quot;/post/123&quot;</span>&gt;&lt;/<span class="hljs-keyword">Link</span>&gt;<br></code></pre></td></tr></table></figure></li><li>在子组件上获取传递的参数<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">value</span> === <span class="hljs-keyword">this</span>.props.match.<span class="hljs-keyword">params</span>.key<br><span class="hljs-keyword">value</span> === <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>注意事项：</strong></p><ul><li>如果不往 url 里传任何东西，是没办法匹配路由成功的。即若设置了动态传参<code>:</code>，则必须要给定一个参数。</li><li>params：传递过来的参数，<code>key</code>和<code>value</code>值。通过 <code>this.props.params.xxx</code> 取值，xxx = key</li></ul><blockquote><p>优点：简单快捷，并且在刷新页面的时候，参数不会丢失。<br>缺点：只能传字符串，并且如果传的值太多的话，url会变得长而丑陋。<br>如果想传对象的话，可以用<code>JSON.stringify()</code>,想将其转为字符串，然后另外的页面接收后，用<code>JSON.parse()</code>转回去。</p></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><strong>设置动态路由 &amp; Link传值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; BrowserRouter <span class="hljs-keyword">as</span> Router, Route, NavLink &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home&#x27;</span><br><span class="hljs-keyword">import</span> Analysis <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Analysis&#x27;</span><br><span class="hljs-keyword">import</span> Person <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Person&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../index.css&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../images/iconfont.css&quot;</span><br><br><span class="hljs-keyword">const</span> HomePage = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> routeList = [<br>        ...<br>        &#123;<br>            <span class="hljs-comment">// href 定义了 value</span><br>            <span class="hljs-comment">// path 定义了 key</span><br>            href: <span class="hljs-string">&quot;/person/齐天大圣&quot;</span>,<br>            path: <span class="hljs-string">&quot;/person/:name&quot;</span>,<br>            exact: <span class="hljs-literal">false</span>,<br>            title: <span class="hljs-string">&quot;个人档案&quot;</span>,<br>            component: Person,<br>            icon: <span class="hljs-string">&quot;iconfont icon-icon-text-fn-documentation&quot;</span><br>        &#125;,<br>    ]<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            ...<br>        &lt;/div&gt;<br>    )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> HomePage<br></code></pre></td></tr></table></figure><p><strong>子组件接收参数</strong><br>用了 <code>Ant Design</code> 的标签，标签具体属性可参照官网。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../index.css&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span><br><span class="hljs-keyword">import</span> &#123;Input&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;  &#125;<br>        <span class="hljs-built_in">this</span>.onSearch = <span class="hljs-built_in">this</span>.onSearch.bind(<span class="hljs-built_in">this</span>)<br>    &#125;<br><br>    onSearch () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> &#123;Search&#125; = Input <br>        <span class="hljs-keyword">return</span> ( <br>            &lt;div&gt;<br>                &lt;div&gt;<br>                    &lt;h1 className=<span class="hljs-string">&quot;basicInfo&quot;</span>&gt;基本信息&lt;/h1&gt;<br>                &lt;/div&gt;<br>                &lt;div&gt;<br>                    &lt;Search <br>                        <span class="hljs-comment">// 接收传递的参数</span><br>                        placeholder=&#123;<span class="hljs-built_in">this</span>.props.match.params.name&#125;<br>                        allowClear<br>                        onSearch=&#123;<span class="hljs-built_in">this</span>.onSearch&#125;<br>                        style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">250</span>, <span class="hljs-attr">margin</span>: <span class="hljs-string">&#x27;0 10px&#x27;</span> &#125;&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>         );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Person;<br></code></pre></td></tr></table></figure><h3 id="query-传参"><a href="#query-传参" class="headerlink" title="query 传参"></a>query 传参</h3><ol><li><code>&lt;Route&gt;</code>定义方式同普通路由相同<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/post/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><code>&lt;Link&gt;</code>定义前需要声明一个对象，保存 url 地址和传递的参数 <code>key: value</code><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts">const name = &#123;<br><span class="hljs-symbol">    pathname:</span> <span class="hljs-string">&quot;/post/&quot;</span>,<br><span class="hljs-symbol">    query:</span> &#123;<br><span class="hljs-symbol">        xxx:</span> yyy,<br><span class="hljs-symbol">        aaa:</span> bbb,<br>        ...<br>    &#125;<br>    <span class="hljs-comment">// query: value (string or obj)</span><br>&#125;<br><span class="hljs-params">&lt;Link to=&#123;name&#125;&gt;</span><span class="hljs-params">&lt;/Link&gt;</span><br></code></pre></td></tr></table></figure></li><li>子组件参数获取<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.props</span><span class="hljs-selector-class">.location</span><span class="hljs-selector-class">.query</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>注意事项：</strong></p><ul><li><code>pathname, query</code>都是固定名称，不能修改，其中<code>pathname</code>不是驼峰命名，<code>query</code>表示传递的参数，等价于通配符的<code>key</code>。</li><li>获取参数时，取的是 url 链接内的 <code>query</code> 属性值，而不是 <code>name</code>。即<code>this.props.location.name</code> 是错误的</li></ul><blockquote><p>优点：优雅，可传对象。<br>缺点：刷新页面，参数丢失。</p></blockquote><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> HomePage = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> routeList = [<br>        &#123;<br>            <span class="hljs-comment">// href 对应的是&lt;Link&gt;标签内的 to 属性值</span><br>            href: &#123;<span class="hljs-attr">pathname</span>:<span class="hljs-string">&#x27;/analysis/&#x27;</span>, <span class="hljs-attr">query</span>:&#123;<span class="hljs-attr">id</span>:<span class="hljs-number">1024</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;齐天大圣&quot;</span>&#125;&#125;,<br>            path: <span class="hljs-string">&quot;/analysis/&quot;</span>,<br>            exact: <span class="hljs-literal">false</span>,<br>            title: <span class="hljs-string">&quot;相关性分析&quot;</span>,<br>            component: Analysis,<br>            icon: <span class="hljs-string">&quot;iconfont icon-fenxi&quot;</span><br>        &#125;,<br>        ...<br>    ]<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            ...<br>        &lt;/div&gt;<br>    )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> HomePage<br></code></pre></td></tr></table></figure><p><strong>子组件接收参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> analysisPng <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../images/Analysis.png&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;../index.css&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Analysis</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;&#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 刷新后参数不保留，会报错，因此在这添一个判断</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.props.location.query === <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-built_in">this</span>.setState(&#123;<br>                id: <span class="hljs-number">0</span>,<br>                name: <span class="hljs-string">&quot;无&quot;</span>,<br>            &#125;)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.props)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.setState(&#123;<br>                id: <span class="hljs-built_in">this</span>.props.location.query.id,<br>                name: <span class="hljs-built_in">this</span>.props.location.query.name<br>            &#125;)<br>            <span class="hljs-comment">// this.props.location.query 接收传递的参数值，此处为一个对象</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.props.location.query)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div&gt;<br>                    &lt;img className=<span class="hljs-string">&quot;img&quot;</span> src=&#123;analysisPng&#125; alt=<span class="hljs-string">&quot;&quot;</span> /&gt;<br>                &lt;/div&gt;<br>                &lt;h3&gt;&#123;<span class="hljs-built_in">this</span>.state.id&#125;&lt;/h3&gt;<br>                &lt;h3&gt;&#123;<span class="hljs-built_in">this</span>.state.name&#125;&lt;/h3&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Analysis;<br></code></pre></td></tr></table></figure><h3 id="state-传参"><a href="#state-传参" class="headerlink" title="state 传参"></a>state 传参</h3><p>与 <code>query</code> 传参类似：</p><ol><li><code>&lt;Route&gt;</code>定义方式同普通路由相同<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/post/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><code>&lt;Link&gt;</code>定义前需要声明一个对象，保存 url 地址和传递的参数 <code>key: value</code><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> name = &#123;<br>    pathname: <span class="hljs-string">&quot;/post/&quot;</span>,<br>    <span class="hljs-keyword">state</span>: &#123;<br>        xxx: yyy,<br>        aaa: bbb,<br>        ...<br>    &#125;<br>    // <span class="hljs-keyword">state</span>: value (string or obj)<br>&#125;<br><span class="hljs-variable">&lt;Link to=&#123;name&#125;&gt;</span>&lt;/Link&gt;<br></code></pre></td></tr></table></figure></li><li>子组件参数获取<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">this.props.location.<span class="hljs-keyword">state</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p><strong>重定向</strong> 和 <strong>跳转</strong> 有一个重要的<strong>区别</strong>，就是跳转式可以用浏览器的回退按钮返回上一级的，而重定向是不可以的。</p><h3 id="标签式重定向"><a href="#标签式重定向" class="headerlink" title="标签式重定向"></a>标签式重定向</h3><p>一般用在不是很复杂的业务逻辑中，比如我们进入Index组件，然后Index组件,直接重定向到Home组件。</p><ol><li>引入<code>&lt;Redirect&gt;</code>重定向标签<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123;Redirect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br></code></pre></td></tr></table></figure></li><li>在<code>render</code>函数里使用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span>(<br>        &lt;div&gt;<br>            ...<br>            &lt;Redirect to=<span class="hljs-string">&quot;...&quot;</span>&gt;<br>            ...<br>        &lt;/div&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>标签式重定向只能写在 <code>render</code> 函数中，因此无法绑定到一些业务逻辑上，例如一些业务逻辑绑定函数函数体是独立于<code>render</code>函数之外的，将<code>&lt;Redirect&gt;</code>标签定义在这类函数体中是不奏效的。因此，我们可以使用另一种编程式的重定向方法，它直接使用JS的语法实现重定向，一般用在业务逻辑比较发杂的场合或者需要多次判断的场合。</li></ol><h3 id="编程式重定向"><a href="#编程式重定向" class="headerlink" title="编程式重定向"></a>编程式重定向</h3><p>调用方法：直接在函数体中加入以下语句即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.props</span><span class="hljs-selector-class">.history</span><span class="hljs-selector-class">.push</span>(&quot;<span class="hljs-selector-tag">url</span>地址&quot;)<br></code></pre></td></tr></table></figure><p>例如在 <code>constructor</code> 构造函数中加入上述代码，即可在组件构造时就进行重定向。<br>在登陆界面中，我们可以将编程式重定向应用到点击事件判断中，例如当用户名密码与后端一致时，点击确认，重定向到目标路由。这也是标签式重定向无法做到的，具体过程在实战中继续领悟！</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>react-router-dom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React+Redux实现小书评论实战(一~三)</title>
    <link href="/2020/12/04/React+Redux%E5%AE%9E%E7%8E%B0%E5%B0%8F%E4%B9%A6%E8%AF%84%E8%AE%BA%E5%AE%9E%E6%88%98/"/>
    <url>/2020/12/04/React+Redux%E5%AE%9E%E7%8E%B0%E5%B0%8F%E4%B9%A6%E8%AF%84%E8%AE%BA%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Redux实现小书评论实战-一-三"><a href="#React-Redux实现小书评论实战-一-三" class="headerlink" title="React+Redux实现小书评论实战(一~三)"></a>React+Redux实现小书评论实战(一~三)</h1><p>个人github: <a href="https://github.com/jtwang7">个人github</a><br>github地址：<a href="https://github.com/jtwang7/reduxCommentApp.git">项目</a></p><hr><h2 id="项目结构树"><a href="#项目结构树" class="headerlink" title="项目结构树"></a>项目结构树</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">React</span>小书评论功能(一~三)<br>├─ <span class="hljs-selector-tag">README</span><span class="hljs-selector-class">.md</span><br>└─ <span class="hljs-selector-tag">src</span><br>   ├─ <span class="hljs-selector-tag">CommentApp</span><span class="hljs-selector-class">.js</span><br>   ├─ <span class="hljs-selector-tag">components</span><br>   │  ├─ <span class="hljs-selector-tag">comment</span><span class="hljs-selector-class">.css</span><br>   │  ├─ <span class="hljs-selector-tag">Comment</span><span class="hljs-selector-class">.js</span><br>   │  ├─ <span class="hljs-selector-tag">CommentInput</span><span class="hljs-selector-class">.js</span><br>   │  └─ <span class="hljs-selector-tag">CommentList</span><span class="hljs-selector-class">.js</span><br>   ├─ <span class="hljs-selector-tag">componentsUI</span><br>   │  └─ <span class="hljs-selector-tag">CommentInputUI</span><span class="hljs-selector-class">.js</span><br>   ├─ <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.js</span><br>   └─ <span class="hljs-selector-tag">store</span><br>      ├─ <span class="hljs-selector-tag">actionCreators</span><span class="hljs-selector-class">.js</span><br>      ├─ <span class="hljs-selector-tag">actionTypes</span><span class="hljs-selector-class">.js</span><br>      ├─ <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.js</span><br>      └─ <span class="hljs-selector-tag">reducer</span><span class="hljs-selector-class">.js</span><br></code></pre></td></tr></table></figure><p>用 Redux 状态管理实现了 React 小书的评论功能(一~三)，同时基于企业级项目开发要求进行了整体优化，包括 actionTypes 和 actionCreator ，以及 UI 界面与业务逻辑分离。项目结构如上述所示，项目整体样式未经过调整，主要采用了阿里开源的 Ant Design 作为主要样式。</p><h2 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h2><h3 id="src-CommentApp-js"><a href="#src-CommentApp-js" class="headerlink" title="src/CommentApp.js"></a>src/CommentApp.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> CommentInput <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/CommentInput&quot;</span><br><span class="hljs-keyword">import</span> CommentList <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/CommentList&#x27;</span>;<br><span class="hljs-comment">// 整体框架</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;&#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                <span class="hljs-comment">// 二级组件</span><br>                &lt;CommentInput /&gt;<br>                &lt;CommentList /&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> CommentApp;<br></code></pre></td></tr></table></figure><h3 id="CommentInput"><a href="#CommentInput" class="headerlink" title="CommentInput"></a>CommentInput</h3><h4 id="src-components-CommentInput-js"><a href="#src-components-CommentInput-js" class="headerlink" title="src/components/CommentInput.js"></a>src/components/CommentInput.js</h4><p>CommentInput 业务逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store/index&quot;</span><br><span class="hljs-keyword">import</span> &#123; inputChangeAction, textAreaChangeAction, commentSubmitAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store/actionCreators&quot;</span><br><span class="hljs-keyword">import</span> &#123; CommentInputUI &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../componentsUI/CommentInputUI&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = store.getState()<br>        <span class="hljs-comment">// store订阅</span><br>        <span class="hljs-built_in">this</span>.storeChange = <span class="hljs-built_in">this</span>.storeChange.bind(<span class="hljs-built_in">this</span>)<br>        store.subscribe(<span class="hljs-built_in">this</span>.storeChange)<br>        <span class="hljs-comment">// 事件方法绑定</span><br>        <span class="hljs-built_in">this</span>.inputChange = <span class="hljs-built_in">this</span>.inputChange.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.textAreaChange = <span class="hljs-built_in">this</span>.textAreaChange.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.commentSubmit = <span class="hljs-built_in">this</span>.commentSubmit.bind(<span class="hljs-built_in">this</span>)<br>    &#125;<br>    <span class="hljs-comment">// store仓库内容改变后，重新渲染组件，与subscribe一同使用</span><br>    <span class="hljs-function"><span class="hljs-title">storeChange</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(store.getState())<br>    &#125;<br>    <span class="hljs-comment">// 方法内声明action,并注入到store仓库</span><br>    <span class="hljs-function"><span class="hljs-title">inputChange</span>(<span class="hljs-params">e</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = inputChangeAction(e.target.value)<br>        store.dispatch(action)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">textAreaChange</span>(<span class="hljs-params">e</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = textAreaChangeAction(e.target.value)<br>        store.dispatch(action)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">commentSubmit</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = commentSubmitAction()<br>        store.dispatch(action)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;CommentInputUI<br>                    inputChange=&#123;<span class="hljs-built_in">this</span>.inputChange&#125;<br>                    textAreaChange=&#123;<span class="hljs-built_in">this</span>.textAreaChange&#125;<br>                    commentSubmit=&#123;<span class="hljs-built_in">this</span>.commentSubmit&#125;<br>                /&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> CommentInput;<br></code></pre></td></tr></table></figure><h4 id="src-componentsUI-CommentInputUI-js"><a href="#src-componentsUI-CommentInputUI-js" class="headerlink" title="src/componentsUI/CommentInputUI.js"></a>src/componentsUI/CommentInputUI.js</h4><p>CommentInput UI界面 + 无状态组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span><br><span class="hljs-keyword">import</span> &#123; Input, Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;../components/comment.css&quot;</span><br><br><span class="hljs-keyword">const</span> &#123; TextArea &#125; = Input;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> CommentInputUI = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            &lt;div className=<span class="hljs-string">&quot;inputRow&quot;</span>&gt;<br>                &lt;span&gt;用户名:&lt;/span&gt;<br>                &lt;Input<br>                    style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;300px&quot;</span>, <span class="hljs-attr">marginLeft</span>:<span class="hljs-string">&quot;20px&quot;</span> &#125;&#125;<br>                    placeholder=<span class="hljs-string">&quot;Please enter your name&quot;</span><br>                    onChange=&#123;props.inputChange&#125;<br>                /&gt;<br>            &lt;/div&gt;<br>            &lt;div className=<span class="hljs-string">&quot;inputRow secondRow&quot;</span>&gt;<br>                &lt;span&gt;评论内容:&lt;/span&gt;<br>                &lt;TextArea<br>                    rows=&#123;<span class="hljs-number">5</span>&#125;<br>                    style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;285px&quot;</span>, <span class="hljs-attr">marginLeft</span>:<span class="hljs-string">&quot;20px&quot;</span> &#125;&#125;<br>                    <span class="hljs-comment">// ref=&#123;(textArea) =&gt; (this.textArea = textArea)&#125;</span><br>                    onChange=&#123;props.textAreaChange&#125;<br>                /&gt;<br>            &lt;/div&gt;<br>            &lt;div&gt;<br>                &lt;Button<br>                    type=<span class="hljs-string">&quot;primary&quot;</span><br>                    onClick=&#123;props.commentSubmit&#125;<br>                &gt;发布&lt;/Button&gt;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CommentList"><a href="#CommentList" class="headerlink" title="CommentList"></a>CommentList</h3><h4 id="src-components-CommentList-js"><a href="#src-components-CommentList-js" class="headerlink" title="src/components/CommentList.js"></a>src/components/CommentList.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store/index&quot;</span><br><span class="hljs-keyword">import</span> Comment <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Comment&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = store.getState()<br>        <span class="hljs-comment">// CommentList要渲染到页面，所以要订阅storeChange方法</span><br>        <span class="hljs-built_in">this</span>.storeChange = <span class="hljs-built_in">this</span>.storeChange.bind(<span class="hljs-built_in">this</span>)<br>        store.subscribe(<span class="hljs-built_in">this</span>.storeChange)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">storeChange</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(store.getState())<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div&gt;<br>                    &#123;<span class="hljs-built_in">this</span>.state.list.map(<br>                        (item, index) =&gt; (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Comment</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&#123;item&#125;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> /&gt;</span></span>)<br>                    )&#125;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> CommentList;<br></code></pre></td></tr></table></figure><h4 id="src-components-Comment-js"><a href="#src-components-Comment-js" class="headerlink" title="src/components/Comment.js"></a>src/components/Comment.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span><br><span class="hljs-keyword">import</span> &#123; Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;antd&#x27;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; deleteCommentAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store/actionCreators&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.deleteComment = <span class="hljs-built_in">this</span>.deleteComment.bind(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">deleteComment</span>(<span class="hljs-params">index</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = deleteCommentAction(index)<br>        store.dispatch(action)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div&gt;<br>                    &#123;<span class="hljs-built_in">this</span>.props.content&#125;<br>                    &lt;Button<br>                        type=<span class="hljs-string">&quot;link&quot;</span><br>                        onClick=&#123;<span class="hljs-function">() =&gt;</span> (<span class="hljs-built_in">this</span>.deleteComment(<span class="hljs-built_in">this</span>.props.index))&#125;<br>                    &gt;删除&lt;/Button&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Comment;<br></code></pre></td></tr></table></figure><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><h4 id="src-store-actionTypes-js"><a href="#src-store-actionTypes-js" class="headerlink" title="src/store/actionTypes.js"></a>src/store/actionTypes.js</h4><p>action.type 常量单独分离</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> INPUT_CHANGE = <span class="hljs-string">&quot;input_change&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> TEXT_AREA_CHANGE = <span class="hljs-string">&quot;text_area_change&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> COMMENT_SUBMIT = <span class="hljs-string">&quot;comment_submit&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DELETE_COMMENT = <span class="hljs-string">&quot;delete_comment&quot;</span><br><br></code></pre></td></tr></table></figure><h4 id="src-store-actionCreators-js"><a href="#src-store-actionCreators-js" class="headerlink" title="src/store/actionCreators.js"></a>src/store/actionCreators.js</h4><p>action 对象单独分离管理，用函数方式调用</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> &#123; INPUT_CHANGE, TEXT_AREA_CHANGE, COMMENT_SUBMIT, DELETE_COMMENT &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./actionTypes&quot;</span><br><span class="hljs-keyword">export</span> const inputChangeAction = <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> (&#123;<br>    type: INPUT_CHANGE,<br>    value,<br>&#125;)<br><span class="hljs-keyword">export</span> const textAreaChangeAction = <span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> (&#123;<br>    type: TEXT_AREA_CHANGE,<br>    value,<br>&#125;)<br><span class="hljs-keyword">export</span> const commentSubmitAction = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;<br>    type: COMMENT_SUBMIT,<br>&#125;)<br><span class="hljs-keyword">export</span> const deleteCommentAction = <span class="hljs-function"><span class="hljs-params">(index)</span> =&gt;</span> (&#123;<br>    type: DELETE_COMMENT,<br>    index,<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="src-store-index-js"><a href="#src-store-index-js" class="headerlink" title="src/store/index.js"></a>src/store/index.js</h4><p>store仓库创建</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><br>import reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span><br><br>const store = createStore(reducer)<br><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>store<br></code></pre></td></tr></table></figure><h4 id="src-store-reducer-js"><a href="#src-store-reducer-js" class="headerlink" title="src/store/reducer.js"></a>src/store/reducer.js</h4><p>reducer 管理，定义 action 操作</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs pf">import &#123; act &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/test-utils&quot;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">default</span>State = &#123;<br>    inputValue: <span class="hljs-string">&quot;&quot;</span>,<br>    textAreaValue: <span class="hljs-string">&quot;&quot;</span>,<br>    list: [],<br>&#125;<br><br>export <span class="hljs-keyword">default</span> (<span class="hljs-keyword">state</span> = <span class="hljs-keyword">default</span>State, action) =&gt; &#123;<br>    if (action.type === <span class="hljs-string">&quot;input_change&quot;</span>) &#123;<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.inputValue = action.value<br>        return newState<br>    &#125;<br>    if (action.type === <span class="hljs-string">&quot;text_area_change&quot;</span>) &#123;<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.textAreaValue = action.value<br>        return newState<br>    &#125;<br>    if (action.type === <span class="hljs-string">&quot;comment_submit&quot;</span>) &#123;<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.list.push(`$&#123;newState.inputValue&#125;: $&#123;newState.textAreaValue&#125;`)<br>        return newState<br>    &#125;<br>    if (action.type === <span class="hljs-string">&quot;delete_comment&quot;</span>) &#123;<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.list.splice(action.index,<span class="hljs-number">1</span>)<br>        return newState<br>    &#125;<br>    return <span class="hljs-keyword">state</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux UI界面与业务逻辑分离</title>
    <link href="/2020/12/03/Redux%20UI%E7%95%8C%E9%9D%A2%E4%B8%8E%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB/"/>
    <url>/2020/12/03/Redux%20UI%E7%95%8C%E9%9D%A2%E4%B8%8E%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Redux-UI界面与业务逻辑分离"><a href="#Redux-UI界面与业务逻辑分离" class="headerlink" title="Redux UI界面与业务逻辑分离"></a>Redux UI界面与业务逻辑分离</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1w441137ss?p=1">技术胖 Redux 免费教程</a><br>参考链接：<a href="https://jspang.com/detailed?id=48#toc230">技术胖 Redux 教程笔记汇总</a><br><strong>本文搭配原文教程食用，风味更佳~!</strong></p><hr><p><strong>UI界面与业务逻辑分离的必要性</strong></p><ol><li>让项目更容易维护。</li><li>多人协作，实现超大型项目的开发和快速上线。比如两个人同时写一个模块，一个写UI部分，一个写业务逻辑部分，之后两个人在一起整合。</li></ol><h2 id="分离步骤"><a href="#分离步骤" class="headerlink" title="分离步骤"></a>分离步骤</h2><ol><li><code>src/</code> 文件夹下新建 <code>TodoListUI.js</code>，用于存储 UI 界面代码</li><li>将 JSX 代码迁移到 <code>TodoListUI.js</code></li><li>UI组件与业务逻辑组件整合</li><li>进阶：无状态组件编写UI界面</li></ol><h2 id="实战代码"><a href="#实战代码" class="headerlink" title="实战代码"></a>实战代码</h2><h3 id="TodoListUI-js"><a href="#TodoListUI-js" class="headerlink" title="TodoListUI.js"></a>TodoListUI.js</h3><ul><li>在src目录下新建一个文件<code>TodoListUI.js</code>, <code>imrc ccc</code>快速生成页面的基本结构.</li><li>去<code>TodoList.js</code>里把<code>JSX</code>拷贝过来，并在<code>TodoList.js</code>中引入<code>&lt;TodoListUI /&gt;</code>标签。此时<code>TodoListUI</code>中并没有组件所需要的<code>state</code>(状态信息)，接下来需要改造父组件进行值传递。</li><li>父组件通过属性传值的形式(props)，把需要的值传递给子组件，子组件接收这些值，进行相应的绑定就可以了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// 别忘了引入antd组件</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; Input, Button, List &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoListUI</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &#123;<span class="hljs-comment">/* 迁移UI界面JSX代码 */</span>&#125;<br>                &lt;div style=&#123;&#123; <span class="hljs-attr">margin</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;&gt;<br>                    &lt;Input<br>                        <span class="hljs-comment">// - placeholder=&#123;this.state.inputValue&#125; </span><br>                        <span class="hljs-comment">// + placeholder=&#123;this.props.inputValue&#125;</span><br>                        <span class="hljs-comment">// 属性值从TodoList组件通过 &lt;TodoListUI /&gt; 的props传入</span><br>                        placeholder=&#123;<span class="hljs-built_in">this</span>.props.inputValue&#125;<br>                        style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;250px&quot;</span>, <span class="hljs-attr">marginRight</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;<br>                        onChange=&#123;<span class="hljs-built_in">this</span>.props.inputChangeValue&#125;<br>                    /&gt;<br>                    &lt;Button<br>                        type=<span class="hljs-string">&quot;primary&quot;</span><br>                        onClick=&#123;<span class="hljs-built_in">this</span>.props.addItem&#125;<br>                    &gt;添加&lt;/Button&gt;<br>                &lt;/div&gt;<br>                &lt;div style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;325px&quot;</span>, <span class="hljs-attr">margin</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;&gt;<br>                    &lt;List<br>                        size=<span class="hljs-string">&quot;small&quot;</span><br>                        bordered<br>                        dataSource=&#123;<span class="hljs-built_in">this</span>.props.list&#125;<br>                        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                        不能写成(item, index) =&gt; (&lt;List.Item onClick=&#123;(index) =&gt; &#123; this.props.deleteItem(index) &#125;&#125;&gt;&#123;item&#125;&lt;/List.Item&gt;)</span><br><span class="hljs-comment">                        因为在onClick=&#123;&#125;代码块中，又重新声明了一个index，此时this.props.deleteItem(index)取的是代码块内的index</span><br><span class="hljs-comment">                        正确写法如下，将(index)=&gt;&#123;&#125;改为()=&gt;&#123;&#125;，让外层代码块的index传入进来。</span><br><span class="hljs-comment">                        */</span><br>                        <span class="hljs-comment">// this.props.deleteItem.bind(this,index) 在这里无法使用，因为无法绑定到TodoList组件的this</span><br>                        <span class="hljs-comment">// 所以推荐将 .bind(this) 写入原组件的 constructor</span><br>                        renderItem=&#123;<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123; this.props.deleteItem(index) &#125;&#125;&gt;&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">List.Item</span>&gt;</span></span>) &#125;&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoListUI;<br></code></pre></td></tr></table></figure><h3 id="TodoList-js"><a href="#TodoList-js" class="headerlink" title="TodoList.js"></a>TodoList.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/index&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; inputChangeValueAction, addItemAction, deleteItemAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store/actionCreators&quot;</span><br><span class="hljs-comment">// 引入 UI 界面代码</span><br><span class="hljs-keyword">import</span> TodoListUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./TodoListUI&#x27;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.inputChangeValue = <span class="hljs-built_in">this</span>.inputChangeValue.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.addItem = <span class="hljs-built_in">this</span>.addItem.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.deleteItem = <span class="hljs-built_in">this</span>.deleteItem.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.state = store.getState()<br><br>        <span class="hljs-built_in">this</span>.storeChange = <span class="hljs-built_in">this</span>.storeChange.bind(<span class="hljs-built_in">this</span>)<br>        store.subscribe(<span class="hljs-built_in">this</span>.storeChange)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">inputChangeValue</span>(<span class="hljs-params">e</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = inputChangeValueAction(e.target.value)<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">addItem</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = addItemAction()<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">deleteItem</span>(<span class="hljs-params">index</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = deleteItemAction(index)<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">storeChange</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(store.getState())<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &#123;<span class="hljs-comment">/* 用组件替代 */</span>&#125;<br>                &lt;TodoListUI<br>                    inputValue=&#123;<span class="hljs-built_in">this</span>.state.inputValue&#125;<br>                    inputChangeValue=&#123;<span class="hljs-built_in">this</span>.inputChangeValue&#125;<br>                    addItem=&#123;<span class="hljs-built_in">this</span>.addItem&#125;<br>                    list=&#123;<span class="hljs-built_in">this</span>.state.list&#125;<br>                    deleteItem=&#123;<span class="hljs-built_in">this</span>.deleteItem&#125;<br>                /&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoList;<br></code></pre></td></tr></table></figure><h2 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h2><p>无状态组件其实就是一个函数，它不用再继承任何的类（class），也不存在state（状态）。当我们需要的组件<strong>不需要其余业务逻辑</strong>的时候，即只是构造<strong>单纯的UI组件</strong>时，把其改成无状态组件可以提高程序性能。</p><ol><li>不在需要引入React中的{ Component }。</li><li>用一个TodoListUI函数代替组件继承, 里边只返回JSX的部分。</li><li>函数传递一个props参数，之后修改里边的所有props，去掉this (因为函数中已经没有 this 了，原 this 指向的是继承类)。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// - import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="hljs-comment">// Component 不需要，但是 React 在 React 项目中必须引入</span><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; Input, Button, List &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><br><span class="hljs-comment">// 无状态组件是个函数，返回 UI 界面的 JSX </span><br><span class="hljs-keyword">const</span> TodoListUI = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            &#123;<span class="hljs-comment">/* </span><br><span class="hljs-comment">            此处将props打印到控制台，发现props为obj对象</span><br><span class="hljs-comment">            即&lt;TodoListUI /&gt;组件在属性传递时，是将所有属性打包成了一个对象进行传递的。</span><br><span class="hljs-comment">            */</span>&#125;<br>            &#123;<span class="hljs-built_in">console</span>.log(props)&#125;<br>            &lt;div style=&#123;&#123; <span class="hljs-attr">margin</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;&gt;<br>                &lt;Input<br>                    <span class="hljs-comment">// - this.props.inputValue</span><br>                    <span class="hljs-comment">// + props.inputValue</span><br>                    placeholder=&#123;props.inputValue&#125;<br>                    style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;250px&quot;</span>, <span class="hljs-attr">marginRight</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;<br>                    onChange=&#123;props.inputChangeValue&#125;<br>                /&gt;<br>                &lt;Button<br>                    type=<span class="hljs-string">&quot;primary&quot;</span><br>                    onClick=&#123;props.addItem&#125;<br>                &gt;添加&lt;/Button&gt;<br>            &lt;/div&gt;<br>            &lt;div style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;325px&quot;</span>, <span class="hljs-attr">margin</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;&gt;<br>                &lt;List<br>                    size=<span class="hljs-string">&quot;small&quot;</span><br>                    bordered<br>                    dataSource=&#123;props.list&#125;<br>                    renderItem=&#123;<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123; props.deleteItem(index) &#125;&#125;&gt;&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">List.Item</span>&gt;</span></span>) &#125;&#125;<br>                /&gt;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>    );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoListUI;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux工程优化</title>
    <link href="/2020/12/02/Redux%E5%B7%A5%E7%A8%8B%E4%BC%98%E5%8C%96/"/>
    <url>/2020/12/02/Redux%E5%B7%A5%E7%A8%8B%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Redux工程优化"><a href="#Redux工程优化" class="headerlink" title="Redux工程优化"></a>Redux工程优化</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1w441137ss?p=1">技术胖 Redux 免费教程</a><br>参考链接：<a href="https://jspang.com/detailed?id=48#toc230">技术胖 Redux 教程笔记汇总</a><br><strong>本文搭配原文教程食用，风味更佳~!</strong></p><hr><h2 id="Action-Type-分离"><a href="#Action-Type-分离" class="headerlink" title="Action Type 分离"></a>Action Type 分离</h2><p>写Redux Action的时候，我们写了很多Action的派发，产生了很多Action Types。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs fortran">inputChangeValue(e) &#123;<br>    const <span class="hljs-keyword">action</span> = &#123;<br>        <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;input_change_value&quot;</span>,<br>        <span class="hljs-keyword">value</span>: e<span class="hljs-number">.</span><span class="hljs-keyword">target</span><span class="hljs-number">.</span><span class="hljs-keyword">value</span>,<br>    &#125;<br>    store<span class="hljs-number">.</span>dispatch(<span class="hljs-keyword">action</span>)<br>&#125;<br><br>addItem() &#123;<br>    const <span class="hljs-keyword">action</span> = &#123;<br>        <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;add_item&quot;</span>,<br>    &#125;<br>    store<span class="hljs-number">.</span>dispatch(<span class="hljs-keyword">action</span>)<br>&#125;<br><br>deleteItem(<span class="hljs-built_in">index</span>) &#123;<br>    const <span class="hljs-keyword">action</span> = &#123;<br>        <span class="hljs-keyword">type</span>: <span class="hljs-string">&quot;delete_item&quot;</span>,<br>        <span class="hljs-built_in">index</span>,<br>    &#125;<br>    store<span class="hljs-number">.</span>dispatch(<span class="hljs-keyword">action</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在项目管理中，不分离 action.type 会导致两个问题：</p><ol><li>Types不统一管理，不利于大型项目的复用，设置会长生冗余代码。</li><li>因为Action里的Type，一定要和Reducer里的type一一对应在，所以这部分代码或字母写错后，浏览器里并没有明确的报错，这给调试带来了极大的困难。</li></ol><h3 id="actionTypes-js"><a href="#actionTypes-js" class="headerlink" title="actionTypes.js"></a>actionTypes.js</h3><p>因此，我们需要将组件派发的 <code>action.type</code> 单独分离成一个 <code>actionTypes.js</code> 文件，<code>actionTypes.js</code> 文件放在 <code>src/store/</code> 目录下。</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs julia">/*<br>将 action.<span class="hljs-keyword">type</span> 分离成一个单独的文件 (actionTypes.js)<br><span class="hljs-number">1.</span>分离后能精确定位错误原因 (原书写方法不会报错，难debug)，避免名称写错难定位的问题<br><span class="hljs-number">2.</span>增强代码复用性：可以在多个组件引用 action.<span class="hljs-keyword">type</span> 的变量<br>*/<br>// 要 <span class="hljs-keyword">export</span> 抛出文件接口(此文件为常量)；常量要大写<br>// 其他组件使用时不要忘记 <span class="hljs-keyword">import</span> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> INPUT_CHANGE_VALUE = <span class="hljs-string">&quot;input_change_value&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ADD_ITEM = <span class="hljs-string">&quot;add_item&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DELETE_ITEM = <span class="hljs-string">&quot;delete_item&quot;</span><br></code></pre></td></tr></table></figure><p>同时，我们需要修改组件<code>TodoList.js</code>以及 Reducer <code>reducer.js</code>中的 <code>action.type</code> 引用。<strong>注意要在开头将 <code>actionTypes.js</code> 引入。</strong></p><p><strong><code>TodoList.js</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; Input, Button, List &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/index&#x27;</span>;<br><span class="hljs-comment">// 在使用其他文件内容时，不要忘记 import 接口</span><br><span class="hljs-keyword">import</span> &#123; INPUT_CHANGE_VALUE, ADD_ITEM, DELETE_ITEM &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/actionTypes&#x27;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.inputChangeValue = <span class="hljs-built_in">this</span>.inputChangeValue.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.addItem = <span class="hljs-built_in">this</span>.addItem.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.deleteItem = <span class="hljs-built_in">this</span>.deleteItem.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.state = store.getState()<br><br>        <span class="hljs-built_in">this</span>.storeChange = <span class="hljs-built_in">this</span>.storeChange.bind(<span class="hljs-built_in">this</span>)<br>        store.subscribe(<span class="hljs-built_in">this</span>.storeChange)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">inputChangeValue</span>(<span class="hljs-params">e</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = &#123;<br>            <span class="hljs-comment">// - type: &quot;input_change_value&quot;  + type: INPUT_CHANGE_VALUE</span><br>            type: INPUT_CHANGE_VALUE,<br>            value: e.target.value,<br>        &#125;<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">addItem</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = &#123;<br>            type: ADD_ITEM,<br>        &#125;<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">deleteItem</span>(<span class="hljs-params">index</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = &#123;<br>            type: DELETE_ITEM,<br>            index,<br>        &#125;<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">storeChange</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(store.getState())<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div style=&#123;&#123; <span class="hljs-attr">margin</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;&gt;<br>                    &lt;Input<br>                        placeholder=&#123;<span class="hljs-built_in">this</span>.state.inputValue&#125;<br>                        style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;250px&quot;</span>, <span class="hljs-attr">marginRight</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;<br>                        onChange=&#123;<span class="hljs-built_in">this</span>.inputChangeValue&#125;<br>                    /&gt;<br>                    &lt;Button<br>                        type=<span class="hljs-string">&quot;primary&quot;</span><br>                        onClick=&#123;<span class="hljs-built_in">this</span>.addItem&#125;<br>                    &gt;添加&lt;/Button&gt;<br>                &lt;/div&gt;<br>                &lt;div style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;325px&quot;</span>, <span class="hljs-attr">margin</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;&gt;<br>                    &lt;List<br>                        size=<span class="hljs-string">&quot;small&quot;</span><br>                        bordered<br>                        dataSource=&#123;<span class="hljs-built_in">this</span>.state.list&#125;<br>                        renderItem=&#123;<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123; this.deleteItem(index) &#125;&#125;&gt;&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">List.Item</span>&gt;</span></span>) &#125;&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoList;<br></code></pre></td></tr></table></figure><p><strong><code>reducer.js</code></strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pf">// reducer.js 中也不要忘记修改 action.type<br>import &#123; INPUT_CHANGE_VALUE, ADD_ITEM, DELETE_ITEM &#125; <span class="hljs-keyword">from</span> &#x27;./actionTypes&#x27;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">default</span>State = &#123;<br>    inputValue: <span class="hljs-string">&quot;Write Something&quot;</span>,<br>    list: [<br>        <span class="hljs-string">&quot;第一天&quot;</span>,<br>        <span class="hljs-string">&quot;第二天&quot;</span>,<br>        <span class="hljs-string">&quot;第三天&quot;</span>,<br>    ]<br>&#125;<br><br>export <span class="hljs-keyword">default</span> (<span class="hljs-keyword">state</span> = <span class="hljs-keyword">default</span>State, action) =&gt; &#123;<br>    if (action.type === INPUT_CHANGE_VALUE) &#123;<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.inputValue = action.value<br>        return newState<br>    &#125;<br><br>    if (action.type === ADD_ITEM) &#123;<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.list.push(<span class="hljs-keyword">state</span>.inputValue)<br>        return newState<br>    &#125;<br><br>    if (action.type === DELETE_ITEM) &#123;<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.list.splice(action.index,<span class="hljs-number">1</span>)<br>        return newState<br>    &#125;<br><br>    return <span class="hljs-keyword">state</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管理-Redux-Action"><a href="#管理-Redux-Action" class="headerlink" title="管理 Redux Action"></a>管理 Redux Action</h2><p>工程项目中各组件里有很多Action，并且分散才程序的各个地方，如果庞大的工程，这势必会造成严重的混乱。因此，在工程中通常将所有的Redux Action放到一个文件里进行管理。<br>我们通常通过以下步骤将 <code>action</code> 对象单独分离出来：</p><ol><li>在 <code>src/store/</code> 目录下新建 <code>actionCreators.js</code> 文件。(还记得吗？Redux 官方工作流程中管理 Action 的就是 actionCreators)</li><li>将 <code>action对象</code> 写入 <code>actionCreators.js</code> 中，并以方法的形式(普通函数或箭头函数)抛出。</li><li>引入方法，替换原组件内的 <code>action</code> 对象。</li></ol><blockquote><p>为什么不直接抛出 action 对象？<br>因为事件函数可能会传递参数给 action 对象，因此需要用函数来接受并传递参数。</p></blockquote><p><strong><code>actionCreators.js</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不要忘记引入，否则报错</span><br><span class="hljs-keyword">import</span> &#123; INPUT_CHANGE_VALUE, ADD_ITEM, DELETE_ITEM &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./actionTypes&#x27;</span><br><br><span class="hljs-comment">// 抛出方法，返回 action 对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> inputChangeValueAction = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> (&#123;<br>    type: INPUT_CHANGE_VALUE,<br>    value,<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addItemAction = <span class="hljs-function">() =&gt;</span> (&#123;<br>    type: ADD_ITEM,<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> deleteItemAction = <span class="hljs-function">(<span class="hljs-params">index</span>) =&gt;</span> (&#123;<br>    type: DELETE_ITEM,<br>    index,<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong><code>TodoList.js</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; Input, Button, List &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/index&#x27;</span>;<br><span class="hljs-comment">// - import &#123; INPUT_CHANGE_VALUE, ADD_ITEM, DELETE_ITEM &#125; from &#x27;./actionTypes&#x27;</span><br><span class="hljs-comment">// 引入 actionCreators.js，js 后缀可省略</span><br><span class="hljs-keyword">import</span> &#123; inputChangeValueAction, addItemAction, deleteItemAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store/actionCreators&quot;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.inputChangeValue = <span class="hljs-built_in">this</span>.inputChangeValue.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.addItem = <span class="hljs-built_in">this</span>.addItem.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.deleteItem = <span class="hljs-built_in">this</span>.deleteItem.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.state = store.getState()<br><br>        <span class="hljs-built_in">this</span>.storeChange = <span class="hljs-built_in">this</span>.storeChange.bind(<span class="hljs-built_in">this</span>)<br>        store.subscribe(<span class="hljs-built_in">this</span>.storeChange)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">inputChangeValue</span>(<span class="hljs-params">e</span>)</span> &#123;<br>        <span class="hljs-comment">// - &#123;type: INPUT_CHANGE_VALUE, value: e.target.value&#125;</span><br>        <span class="hljs-comment">// 用方法返回 action 对象来代替直接在组件内定义 action 对象，实现 action 代码分离</span><br>        <span class="hljs-comment">// 若事件函数存在参数传递，则同样需要在 actionCreators 方法中定义形参</span><br>        <span class="hljs-keyword">const</span> action = inputChangeValueAction(e.target.value)<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">addItem</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = addItemAction()<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">deleteItem</span>(<span class="hljs-params">index</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = deleteItemAction(index)<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">storeChange</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(store.getState())<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div style=&#123;&#123; <span class="hljs-attr">margin</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;&gt;<br>                    &lt;Input<br>                        placeholder=&#123;<span class="hljs-built_in">this</span>.state.inputValue&#125;<br>                        style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;250px&quot;</span>, <span class="hljs-attr">marginRight</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;<br>                        onChange=&#123;<span class="hljs-built_in">this</span>.inputChangeValue&#125;<br>                    /&gt;<br>                    &lt;Button<br>                        type=<span class="hljs-string">&quot;primary&quot;</span><br>                        onClick=&#123;<span class="hljs-built_in">this</span>.addItem&#125;<br>                    &gt;添加&lt;/Button&gt;<br>                &lt;/div&gt;<br>                &lt;div style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;325px&quot;</span>, <span class="hljs-attr">margin</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;&gt;<br>                    &lt;List<br>                        size=<span class="hljs-string">&quot;small&quot;</span><br>                        bordered<br>                        dataSource=&#123;<span class="hljs-built_in">this</span>.state.list&#125;<br>                        renderItem=&#123;<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123; this.deleteItem(index) &#125;&#125;&gt;&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">List.Item</span>&gt;</span></span>) &#125;&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoList;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux 基础及实战</title>
    <link href="/2020/12/01/Redux%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/12/01/Redux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1w441137ss?p=1">技术胖 Redux 免费教程</a><br>参考链接：<a href="https://jspang.com/detailed?id=48#toc230">技术胖 Redux 教程笔记汇总</a><br><strong>本文搭配原文教程食用，风味更佳~!</strong></p><hr><h2 id="Redux-简要介绍"><a href="#Redux-简要介绍" class="headerlink" title="Redux 简要介绍"></a>Redux 简要介绍</h2><ul><li><strong>什么是Redux？</strong><br>官方解释：Redux is a predictable state container for JavaScript apps.  === Redux是<strong>js</strong>应用的一种可预测的<strong>状态容器</strong>。<br>通俗理解：Redux是一个用来管理管理数据状态和UI状态的JavaScript应用工具。</li><li><strong>Redux作用？</strong><br>简化组件的状态传递。如下图是不使用Redux和使用Redux时，父子组件之间的通信方式。没有使用Redux的情况，如果两个组件(非父子关系)之间需要通信的话，可能需要多个中间组件为他们进行消息传递，这样既浪费了资源，代码也会比较复杂。Redux中提出了单一数据源 <strong>Store</strong> 用来<strong>存储状态数据</strong>，所有的组建都可以<strong>通过Action修改Store</strong>，也可以<strong>从Store中获取最新状态</strong>，从而实现统一状态管理，完美解决组建之间的通信问题。<br><img src="/img/posts_img/20201201191412481_5749.png"></li></ul><h2 id="Redux-工作流程-总体框架"><a href="#Redux-工作流程-总体框架" class="headerlink" title="Redux 工作流程(总体框架)"></a>Redux 工作流程(总体框架)</h2><p>我们将结合 Redux 官方给出的结构图去总体了解 Redux 的工作流程，对结构图的理解将直接反映使用者对 Redux 的掌握程度，十分重要！！！<br>后续实战代码编写中，我们需要按照该结构流程去实现，所以该章节需要重点关注，初学不理解没关系，不过要不断回顾和反复阅读，同时将理解结合到代码中去。<br>现在给出官方的 Redux 结构，如下：<br><img src="/img/posts_img/20201201192118706_7818.png"><br>直接看专业的 Redux 工作流程不是特别好理解，我们可以通过借书的例子来理解：<br><img src="/img/posts_img/20201201192506882_23071.png"><br>React 的各个子组件更新或者改变状态的过程，等同于读者向图书馆借书的过程。读者(Component)需要从图书馆(Store)借书(state)，就要通过图书管理员去取书，取书的过程就是action，但是图书馆(Store)只负责存放图书(state)，无法告诉图书管理员具体的图书在哪，所以又需要图书管理软件(Reducer)进行精确检索，给它传递书名(state)和取书指令(action)，它将返回该书的具体位置(newState)，即一个新的状态，最终读者将从图书馆借到这本书。<br>当然上述只是通俗的理解，一些步骤可能存在纰漏，我们后续将通过实战代码进行详细解读。</p><h2 id="代码实战：TodoLisT-实现"><a href="#代码实战：TodoLisT-实现" class="headerlink" title="代码实战：TodoLisT 实现"></a>代码实战：TodoLisT 实现</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>方法一：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">Win+</span>R<br><span class="hljs-string">cmd</span><br><span class="hljs-string">npm </span><span class="hljs-string">install </span>-g <span class="hljs-built_in">create-react</span> <span class="hljs-string">app </span>//安装脚手架工具，若以前安装过可跳过该步<br><br>进入相应目录<br><span class="hljs-string">mkdir </span><span class="hljs-string">xxx </span>//创建<span class="hljs-string">xxx文</span>件夹<br><span class="hljs-string">cd </span><span class="hljs-string">ReduxDemo </span>     //进入文件夹<br><span class="hljs-built_in">create-react-app</span> <span class="hljs-string">yyy </span> //用脚手架创建<span class="hljs-string">React项</span>目，名称自定义，此处为<span class="hljs-string">yyy</span><br><span class="hljs-string">cd </span><span class="hljs-string">yyy </span>  //等项目创建完成后，进入项目目录<br><span class="hljs-string">npm </span><span class="hljs-string">start </span> //预览项目<br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">进入<span class="hljs-string">vscode终</span>端：<span class="hljs-string">Ctrl+</span>`<br>进入目标目录<br><span class="hljs-string">npx </span><span class="hljs-built_in">create-react-app</span> <span class="hljs-string">yyy</span><br><span class="hljs-string">cd </span><span class="hljs-string">yyy</span><br><span class="hljs-string">npm </span><span class="hljs-string">start</span><br></code></pre></td></tr></table></figure><p>项目搭建完成后，删除一下没用的文件，让代码结构保持最小化。删除<code>src</code>里边的所有文件，只留一个<code>index.js</code>,并且<code>index.js</code>文件里一些无关内容也都清空，只保留两项引用及<code>ReactDOM.render()</code>中的内容。</p><h3 id="快速生成组件代码结构"><a href="#快速生成组件代码结构" class="headerlink" title="快速生成组件代码结构"></a>快速生成组件代码结构</h3><p>编写<code>index.js</code>基础文件，代码如下，主要包含了 React, ReactDOM，同时引入 TodoList 组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><br><span class="hljs-comment">// 引入组件，组件首字母大写</span><br><span class="hljs-keyword">import</span> TodoList <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./TodoList&#x27;</span> <br><br>ReactDOM.render(<br>  &lt;React.StrictMode&gt;<br>    &lt;TodoList /&gt; <br>  &lt;/React.StrictMode&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>可以利用 VSCode 中的 Simple React Snippets 插件快速生成 React Component 的代码结构，先输入<code>imrc</code>,再输入<code>ccc</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// imrc</span><br><span class="hljs-keyword">import</span> <span class="hljs-type">React</span>, &#123; <span class="hljs-type">Component</span> &#125; from <span class="hljs-symbol">&#x27;reac</span>t&#x27;;<br><br><span class="hljs-comment">// ccc</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    render() &#123; <br>        <span class="hljs-keyword">return</span> ( <br>            &lt;div&gt;<span class="hljs-type">Hello</span> <span class="hljs-type">World</span>&lt;/div&gt;<br>         );<br>    &#125;<br>&#125;<br>export <span class="hljs-keyword">default</span> <span class="hljs-type">TodoList</span>;<br></code></pre></td></tr></table></figure><h3 id="AntDesign-优化-UI-界面"><a href="#AntDesign-优化-UI-界面" class="headerlink" title="AntDesign 优化 UI 界面"></a>AntDesign 优化 UI 界面</h3><ol><li>安装 antd<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> antd <span class="hljs-comment">--save</span><br>或<br>yarn <span class="hljs-keyword">add</span> antd<br></code></pre></td></tr></table></figure></li><li>在使用Ant Design时，先引入CSS样式，有样式文件才可以让UI组件显示正常。具体可从Ant Design官方文档查看快速上手步骤。<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span><br></code></pre></td></tr></table></figure></li><li>antd组件使用参照<a href="https://ant.design/components/overview-cn/">AntDesign 组件库</a>文档，同时在使用组件前，需要从相应的文件引入：<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">import &#123;<span class="hljs-keyword">Input</span>, <span class="hljs-keyword">Button</span>, <span class="hljs-keyword">List</span>&#125; from <span class="hljs-string">&quot;antd&quot;</span> //引入了 <span class="hljs-keyword">Input</span> ,<span class="hljs-keyword">Button</span>, <span class="hljs-keyword">List</span> 组件<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>Input 等组件的 style 等属性设置及一些细节参考最后贴出的实战代码，此处不做细讲</p></blockquote><p><strong>TodoList 代码</strong> (此部分是第二遍实现，与首遍代码相比存在出入，功能相同，若要参考具体细节，请移步最后的首版代码)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; Input, Button, List &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><br><span class="hljs-keyword">const</span> data = [<br>    <span class="hljs-string">&quot;第一天&quot;</span>,<br>    <span class="hljs-string">&quot;第二天&quot;</span>,<br>    <span class="hljs-string">&quot;第三天&quot;</span>,<br>]<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;&#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div style=&#123;&#123;<span class="hljs-attr">margin</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125;&gt;<br>                    &lt;Input placeholder=<span class="hljs-string">&quot;Write Something&quot;</span> style=&#123;&#123;<span class="hljs-attr">width</span>:<span class="hljs-string">&quot;250px&quot;</span>,<span class="hljs-attr">marginRight</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125; /&gt;<br>                    &lt;Button type=<span class="hljs-string">&quot;primary&quot;</span> &gt;添加&lt;/Button&gt;<br>                &lt;/div&gt;<br>                &lt;div style=&#123;&#123;<span class="hljs-attr">width</span>:<span class="hljs-string">&quot;325px&quot;</span>,<span class="hljs-attr">margin</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125;&gt;<br>                    &lt;List <br>                        size = <span class="hljs-string">&quot;small&quot;</span><br>                        bordered<br>                        dataSource = &#123;data&#125;<br>                        renderItem = &#123;<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">List.Item</span>&gt;</span></span>) &#125;&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoList;<br></code></pre></td></tr></table></figure><h3 id="Redux-工作流程编写"><a href="#Redux-工作流程编写" class="headerlink" title="Redux 工作流程编写"></a>Redux 工作流程编写</h3><h4 id="创建-Store-仓库"><a href="#创建-Store-仓库" class="headerlink" title="创建 Store 仓库"></a>创建 Store 仓库</h4><ol><li>项目根目录安装 Redux <code>npm install redux --save</code></li><li><code>src</code>目录下新建<code>store</code>子文件夹，在<code>store</code>下创建<code>index.js</code>，<code>index.js</code>就是整个项目的<code>store</code>文件，打开文件，编写下面的代码。<strong>注意几点：</strong> 1. 整个项目只能存在一个 <code>store</code> (后续会讲到) 2. 要引入 <code>createStore()</code> 方法 3.要将 <code>store</code> 暴露出去<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>  <span class="hljs-comment">// 引入createStore方法</span><br><span class="hljs-keyword">const</span> store = createStore()          <span class="hljs-comment">// 创建数据存储仓库</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store                 <span class="hljs-comment">//暴露出去</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="“招募”管理者-Reducer"><a href="#“招募”管理者-Reducer" class="headerlink" title="“招募”管理者 Reducer"></a>“招募”管理者 Reducer</h4><ol><li>在<code>store</code>文件夹下，新建一个文件<code>reducer.js</code></li><li>在<code>reducer.js</code>中编写如下代码，<strong>注意几点：</strong> 1. Reducer 中要定义 <code>defaultState</code> 存储初始(默认)状态，变量名自定义，但常用 <code>defaultState</code> 2.抛出一个方法函数，函数返回<strong>新的状态(newState)**，常用箭头函数。 3.<code>state=defaultState, action</code>注意书写顺序，state 写在 action 前，否则出错，</strong>原因暂时不知**。<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> <span class="hljs-keyword">default</span>State = &#123;&#125;<br>export <span class="hljs-keyword">default</span> (<span class="hljs-keyword">state</span>=<span class="hljs-keyword">default</span>State, action) =&gt; &#123;<br>    return <span class="hljs-keyword">state</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>将 <code>reducer</code> 引入到 <code>Store</code> 中，创建<code>Store</code>时，以参数的形式传递给<code>Store</code>。可以理解为在创建仓库Store的时候就连带着招募一个管理员Reducer。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// - const store = createStore()</span><br><span class="hljs-comment">// + import reducer from &#x27;./reducer&#x27;</span><br><span class="hljs-comment">// + const store = createStore(reducer)</span><br><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span><br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span><br><span class="hljs-keyword">const</span> store = createStore(reducer)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure></li></ol><h4 id="向仓库“存放数据”"><a href="#向仓库“存放数据”" class="headerlink" title="向仓库“存放数据”"></a>向仓库“存放数据”</h4><p>我们创建的仓库是空的，我们可以向仓库中添加一些默认的数据，将其存放在 <code>defaultState</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> defaultState = &#123;<br>    inputValue: <span class="hljs-string">&quot;Write Something&quot;</span>,<br>    <span class="hljs-built_in">list</span>: [<br>        <span class="hljs-string">&quot;第一天&quot;</span>,<br>        <span class="hljs-string">&quot;第二天&quot;</span>,<br>        <span class="hljs-string">&quot;第三天&quot;</span>,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="组件从仓库获取数据"><a href="#组件从仓库获取数据" class="headerlink" title="组件从仓库获取数据"></a>组件从仓库获取数据</h4><p>我们仓库中已经存有数据了，我们需要在组件内通过<code>store.getState()</code>方法将其获取出来。<br>接下来，我们要通过store获取的方法，替换掉原有组件的一些值。<strong>注意：</strong> 要从<code>&quot;./store/index&quot;</code> 文件引入 <code>store</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; Input, Button, List &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-comment">// + import store from &#x27;./store/index&#x27;;</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/index&#x27;</span>;<br><br><span class="hljs-comment">// - const data = [...]</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-comment">// - this.state = &#123;&#125;</span><br>        <span class="hljs-built_in">this</span>.state = store.getState()<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div style=&#123;&#123;<span class="hljs-attr">margin</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125;&gt;<br>                    &#123;- <span class="hljs-comment">/* &lt;Input placeholder=&quot;Write Something&quot; style=&#123;&#123;width:&quot;250px&quot;,marginRight:&quot;10px&quot;&#125;&#125; /&gt; */</span>&#125;<br>                    &lt;Input placeholder=&#123;<span class="hljs-built_in">this</span>.state.inputValue&#125; style=&#123;&#123;<span class="hljs-attr">width</span>:<span class="hljs-string">&quot;250px&quot;</span>,<span class="hljs-attr">marginRight</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125; /&gt;<br>                    &lt;Button type=<span class="hljs-string">&quot;primary&quot;</span> &gt;添加&lt;/Button&gt;<br>                &lt;/div&gt;<br>                &lt;div style=&#123;&#123;<span class="hljs-attr">width</span>:<span class="hljs-string">&quot;325px&quot;</span>,<span class="hljs-attr">margin</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125;&gt;<br>                    &lt;List <br>                        size = <span class="hljs-string">&quot;small&quot;</span><br>                        bordered<br>                        <span class="hljs-comment">// - dataSource = &#123;data&#125;</span><br>                        dataSource = &#123;<span class="hljs-built_in">this</span>.state.list&#125;<br>                        renderItem = &#123;<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">List.Item</span>&gt;</span></span>) &#125;&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoList;<br></code></pre></td></tr></table></figure><h4 id="添加-lt-Input-gt-事件"><a href="#添加-lt-Input-gt-事件" class="headerlink" title="添加 &lt;Input /&gt;事件"></a>添加 <code>&lt;Input /&gt;</code>事件</h4><p>到目前为止，我们只构建了Redux最基本的结构，还没有真正体会到Redux在管理state时的工作过程，同时我们只在开头定义过<code>action</code>，并没有实际用到它，现在我们给<code>&lt;Input /&gt;</code>添加<code>onChange</code>事件，去看看Redux是怎么通过<code>action</code>改变仓库状态的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs javascript">TodoList.js<br><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; Input, Button, List &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/index&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-comment">//绑定函数，指向this</span><br>        <span class="hljs-built_in">this</span>.inputChangeValue = <span class="hljs-built_in">this</span>.inputChangeValue.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.state = store.getState()<br>    &#125;<br><br>    <span class="hljs-comment">//定义函数</span><br>    <span class="hljs-function"><span class="hljs-title">inputChangeValue</span>(<span class="hljs-params">e</span>)</span> &#123;<br>        <span class="hljs-comment">//定义action对象</span><br>        <span class="hljs-keyword">const</span> action = &#123;<br>            type: <span class="hljs-string">&quot;input_change_value&quot;</span>,<br>            value: e.target.value,<br>        &#125;<br>        <span class="hljs-comment">//将 action 对象 dispatch 到仓库上</span><br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div style=&#123;&#123;<span class="hljs-attr">margin</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125;&gt;<br>                    &lt;Input placeholder=&#123;<span class="hljs-built_in">this</span>.state.inputValue&#125; style=&#123;&#123;<span class="hljs-attr">width</span>:<span class="hljs-string">&quot;250px&quot;</span>,<span class="hljs-attr">marginRight</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125; <br>                        <span class="hljs-comment">//添加事件</span><br>                        onChange=&#123;<span class="hljs-built_in">this</span>.inputChangeValue&#125;<br>                    /&gt;<br>                    &lt;Button type=<span class="hljs-string">&quot;primary&quot;</span> &gt;添加&lt;/Button&gt;<br>                &lt;/div&gt;<br>                &lt;div style=&#123;&#123;<span class="hljs-attr">width</span>:<span class="hljs-string">&quot;325px&quot;</span>,<span class="hljs-attr">margin</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125;&gt;<br>                    &lt;List <br>                        size = <span class="hljs-string">&quot;small&quot;</span><br>                        bordered<br>                        dataSource = &#123;<span class="hljs-built_in">this</span>.state.list&#125;<br>                        renderItem = &#123;<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">List.Item</span>&gt;</span></span>) &#125;&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoList;<br><br>-------------------------<br>reducer.js<br><span class="hljs-keyword">const</span> defaultState = &#123;<br>    inputValue: <span class="hljs-string">&quot;Write Something&quot;</span>,<br>    list: [<br>        <span class="hljs-string">&quot;第一天&quot;</span>,<br>        <span class="hljs-string">&quot;第二天&quot;</span>,<br>        <span class="hljs-string">&quot;第三天&quot;</span>,<br>    ]<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (state = defaultState, action) =&gt; &#123;<br>    <span class="hljs-comment">//添加对应的action</span><br>    <span class="hljs-keyword">if</span> (action.type === <span class="hljs-string">&quot;input_change_value&quot;</span>) &#123;<br>        <span class="hljs-keyword">let</span> newState = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(state))<br>        newState.inputValue = action.value<br>        <span class="hljs-keyword">return</span> newState<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> state<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意以下几点：</strong></p><ol><li>函数要用<code>.bind(this)</code>绑定，箭头函数除外。函数绑定最好写在<code>constructor(props) &#123;&#125;</code>内，原因在代码分离的时候会提到。(也可以用<code>this.xxx.bind(this,param1,param2,...)</code>，但后续不好进行企业级代码分离)</li><li>绑定事件的函数内部创建 action 对象，<strong>注意 <code>action</code> 是对象!!!</strong></li><li><strong><code>action</code> 必须要有 <code>type</code> 属性</strong>，其属性值为自定义名称，用于标明当前声明 action 对象的名称。其余属性名称自定义。</li><li>拥有 action 对象后，需要传递给 store 仓库，<strong>首先要将 action <code>dispatch</code> 到 store 仓库上，注意此处是<code>store.dispatch(action)</code>，而不是<code>action.dispatch(store)</code>，dispatch是派遣的意思，可以理解为“仓库派遣一个动作”，而不是“动作派遣仓库”</strong>。</li><li>由于 store 的自动推送策略（store只是一个仓库，它并没有管理能力，它会把接收到的action自动转发给Reducer），我们将在 <code>reducer.js</code> 中对 <code>action</code> 进行处理</li><li><strong>!!!重点：</strong> reducer 中只能接收 state ，但不能直接改变 state。因此，我们需要换种方法：定义一个新的state变量，作为临时变量，将 state 通过 <code>JSON.parse(JSON.stringify(state))</code> 进行深度拷贝，通过重新赋值改变临时变量，再将新的状态抛出</li></ol><h4 id="用newState更新组件"><a href="#用newState更新组件" class="headerlink" title="用newState更新组件"></a>用newState更新组件</h4><p>经过上述操作后，<code>Reducer</code> 通过 <code>action</code> 修改了原始 state 并抛出了新的状态 newState, 但是 newState 还没有被我们的组件给利用，现在就将这最后一环补上，实现整个 Redux 的工作流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; Input, Button, List &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/index&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.inputChangeValue = <span class="hljs-built_in">this</span>.inputChangeValue.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-built_in">this</span>.state = store.getState()<br>        <span class="hljs-comment">//绑定storeChange函数指向this；仓库订阅storeChange函数</span><br>        <span class="hljs-built_in">this</span>.storeChange = <span class="hljs-built_in">this</span>.storeChange.bind(<span class="hljs-built_in">this</span>)<br>        store.subscribe(<span class="hljs-built_in">this</span>.storeChange)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">inputChangeValue</span>(<span class="hljs-params">e</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = &#123;<br>            type: <span class="hljs-string">&quot;input_change_value&quot;</span>,<br>            value: e.target.value,<br>        &#125;<br>        store.dispatch(action)<br>    &#125;<br>    <br>    <span class="hljs-comment">//从仓库中获取新的状态，重新渲染组件</span><br>    <span class="hljs-function"><span class="hljs-title">storeChange</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(store.getState())<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div style=&#123;&#123;<span class="hljs-attr">margin</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125;&gt;<br>                    &lt;Input placeholder=&#123;<span class="hljs-built_in">this</span>.state.inputValue&#125; style=&#123;&#123;<span class="hljs-attr">width</span>:<span class="hljs-string">&quot;250px&quot;</span>,<span class="hljs-attr">marginRight</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125; <br>                        onChange=&#123;<span class="hljs-built_in">this</span>.inputChangeValue&#125;<br>                    /&gt;<br>                    &lt;Button type=<span class="hljs-string">&quot;primary&quot;</span> &gt;添加&lt;/Button&gt;<br>                &lt;/div&gt;<br>                &lt;div style=&#123;&#123;<span class="hljs-attr">width</span>:<span class="hljs-string">&quot;325px&quot;</span>,<span class="hljs-attr">margin</span>:<span class="hljs-string">&quot;10px&quot;</span>&#125;&#125;&gt;<br>                    &lt;List <br>                        size = <span class="hljs-string">&quot;small&quot;</span><br>                        bordered<br>                        dataSource = &#123;<span class="hljs-built_in">this</span>.state.list&#125;<br>                        renderItem = &#123;<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">List.Item</span>&gt;</span></span>) &#125;&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoList;<br></code></pre></td></tr></table></figure><p><strong>注意以下几点：</strong></p><ol><li><code>this.setState()</code>接收的对象是<code>store.getState()</code>，即仓库中的状态而非 this.state。</li><li>仓库需要订阅<code>storeChange()</code>方法，不订阅程序仍能正常运行，但是在某些地方会出错，为了避免这种情况，请将订阅写在 constructor 中。</li></ol><hr><p>以上就是 Redux 基础的一些操作流程，后续的 Button onClick 事件，List onClick 事件不再详细讲解，感兴趣的同学可在下方整体的代码中找到详细的注释。以上就是我对Redux学习的一些体会，希望对各位有所启示。</p><h3 id="TodoList-Redux-实现及详细注释"><a href="#TodoList-Redux-实现及详细注释" class="headerlink" title="TodoList Redux 实现及详细注释"></a>TodoList Redux 实现及详细注释</h3><h4 id="“-src-index-js”"><a href="#“-src-index-js”" class="headerlink" title="“./src/index.js”"></a>“./src/index.js”</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><br><span class="hljs-comment">// 引入组件，组件首字母大写</span><br><span class="hljs-keyword">import</span> TodoList <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./TodoList&#x27;</span> <br><br>ReactDOM.render(<br>  &lt;React.StrictMode&gt;<br>    &lt;TodoList /&gt; <br>  &lt;/React.StrictMode&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><h4 id="“-src-TodoList-js”"><a href="#“-src-TodoList-js”" class="headerlink" title="“./src/TodoList.js”"></a>“./src/TodoList.js”</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// imrc</span><br><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// npm install antd --save ; import css file</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;antd/dist/antd.css&quot;</span><br><span class="hljs-comment">// 引入CSS样式后，还需引入用到的组件</span><br><span class="hljs-keyword">import</span> &#123; Input, Button, List &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;antd&quot;</span><br><span class="hljs-comment">// 引入 store，绑定 component 和 store</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store/index&quot;</span><br><br><span class="hljs-comment">// 将默认 state 存入 reducer -- defaultState 中</span><br><span class="hljs-comment">// const data = [</span><br><span class="hljs-comment">//     &quot;第一条数据&quot;,</span><br><span class="hljs-comment">//     &quot;第二条数据&quot;,</span><br><span class="hljs-comment">//     &quot;第三条数据&quot;,</span><br><span class="hljs-comment">// ]</span><br><br><span class="hljs-comment">// ccc</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-comment">// store.getState() 方法从 store 仓库获取 state，固定方法</span><br>        <span class="hljs-built_in">this</span>.state = store.getState()<br><br>        <span class="hljs-comment">// storeChange 函数绑定 this</span><br>        <span class="hljs-built_in">this</span>.storeChange = <span class="hljs-built_in">this</span>.storeChange.bind(<span class="hljs-built_in">this</span>)<br>        <span class="hljs-comment">// store 订阅 redux 状态，状态更新则重新渲染</span><br>        store.subscribe(<span class="hljs-built_in">this</span>.storeChange)<br>    &#125;<br><br>    <span class="hljs-comment">// 定义 onChange 函数 changeInputValue</span><br>    <span class="hljs-comment">// 将最新输入的状态通过 action 传递给 store</span><br>    <span class="hljs-comment">// action 是一个对象，需要声明。</span><br>    <span class="hljs-comment">// action: type 属性是必需的，type 属性值自定义，表示该 action 的名字; 其余属性自定义，例如 value</span><br>    <span class="hljs-comment">// e.target.value 获取事件 event 对象的值</span><br>    <span class="hljs-comment">// store.dispatch(action) 是必需的，将 action 绑定到 store 上，参考 redux 官方文档，这是默认的结构</span><br>    <span class="hljs-comment">// store 只是仓库，没有管理能力，根据 store 的自动推送策略，store 会将接收的 action 自动转发给 reducer</span><br>    <span class="hljs-function"><span class="hljs-title">changeInputValue</span>(<span class="hljs-params">e</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = &#123;<br>            type: <span class="hljs-string">&quot;change_input_value&quot;</span>,<br>            value: e.target.value,<br>        &#125;<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">valueSubmit</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = &#123;<br>            type: <span class="hljs-string">&quot;value_submit&quot;</span>,<br>        &#125;<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">deleteItem</span>(<span class="hljs-params">idx</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> action = &#123;<br>            type: <span class="hljs-string">&quot;delete_item&quot;</span>,<br>            index: idx,<br>        &#125;<br>        store.dispatch(action)<br>    &#125;<br><br>    <span class="hljs-comment">// reducer action 只更新了 store 状态，需要定义一个 storeChange 函数来更新组件</span><br>    <span class="hljs-comment">// 通过 store.getState() 获取仓库状态，后用 setState 方法重新渲染</span><br>    <span class="hljs-function"><span class="hljs-title">storeChange</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(store.getState())<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;div style=&#123;&#123; <span class="hljs-attr">margin</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;&gt;<br>                    &#123;<span class="hljs-comment">/* </span><br><span class="hljs-comment">                    1.React - style 接收css样式对象 </span><br><span class="hljs-comment">                    2.width 改变宽度；height 改变高度；margin 改变外边距；marginRight 设置右边距</span><br><span class="hljs-comment">                    3.</span><br><span class="hljs-comment">                    - placeholder=&quot;Please input something ...&quot;</span><br><span class="hljs-comment">                    + placeholder=&#123;this.state.inputValue&#125;</span><br><span class="hljs-comment">                    4.添加 onChange 事件，监听 input 文本框内容变化,不要忘记 .bind</span><br><span class="hljs-comment">                    + onChange=&#123;this.changeInputValue.bind(this)</span><br><span class="hljs-comment">                    */</span>&#125;<br>                    &lt;Input<br>                        placeholder=&#123;<span class="hljs-built_in">this</span>.state.inputValue&#125;<br>                        style=&#123;&#123; <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;250px&quot;</span>, <span class="hljs-attr">marginRight</span>: <span class="hljs-string">&quot;10px&quot;</span> &#125;&#125;<br>                        onChange=&#123;<span class="hljs-built_in">this</span>.changeInputValue.bind(<span class="hljs-built_in">this</span>)&#125;<br>                    /&gt;<br>                    &#123;<span class="hljs-comment">/* </span><br><span class="hljs-comment">                    1.开头要引入 antd 的 Button 组件</span><br><span class="hljs-comment">                    2.type 属性见 antd 的 Button 组件文档说明</span><br><span class="hljs-comment">                    3.</span><br><span class="hljs-comment">                    +onClick=&#123;this.valueSubmit.bind(this)&#125;</span><br><span class="hljs-comment">                    */</span>&#125;<br>                    &lt;Button<br>                        type=<span class="hljs-string">&quot;primary&quot;</span><br>                        onClick=&#123;<span class="hljs-built_in">this</span>.valueSubmit.bind(<span class="hljs-built_in">this</span>)&#125;<br>                    &gt;输入&lt;/Button&gt;<br>                &lt;/div&gt;<br>                &lt;div style=&#123;&#123; <span class="hljs-attr">margin</span>: <span class="hljs-string">&quot;10px&quot;</span>, <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;325px&quot;</span> &#125;&#125;&gt;<br>                    &#123;<span class="hljs-comment">/* </span><br><span class="hljs-comment">                    1.参照 antd 的 List 组件文档</span><br><span class="hljs-comment">                    2.dataSource 接收一个数组，数组包含List Item</span><br><span class="hljs-comment">                    3.renderItem 渲染 item，固定写法</span><br><span class="hljs-comment">                    4.(item)=&gt;(...)接收dataSource数组中的元素</span><br><span class="hljs-comment">                    5.&lt;List /&gt;理解为外框架，则&lt;List.Item&gt;&lt;/List.Item&gt;理解为框架内的一行，</span><br><span class="hljs-comment">                    &lt;List.Item&gt;&lt;/List.Item&gt;中可以添加其他JSX元素</span><br><span class="hljs-comment">                    6.标签内属性值间用空格或者换行分割</span><br><span class="hljs-comment">                    */</span>&#125;<br>                    &lt;List<br>                        size=<span class="hljs-string">&quot;small&quot;</span><br>                        bordered<br>                        <span class="hljs-comment">// 用 this.state.list 替换 const data</span><br>                        <span class="hljs-comment">// dataSource = &#123;data&#125;</span><br>                        dataSource=&#123;<span class="hljs-built_in">this</span>.state.list&#125;<br>                        <span class="hljs-comment">// -(item) =&gt; (&lt;List.Item&gt;&#123;item&#125;&lt;/List.Item&gt;)</span><br>                        <span class="hljs-comment">// +(item,idx) =&gt; (&lt;List.Item onClick=&#123;this.deleteItem.bind(this,idx)&#125;&gt;&#123;item&#125;&lt;/List.Item&gt;)</span><br>                        <span class="hljs-comment">// 此处箭头函数形式()=&gt;() ，也可写为()=&gt;&#123;return ()&#125;，用&#123;&#125;时要注意必须要用 return 将结果抛出，详情查看 ES6 箭头函数</span><br>                        renderItem=&#123;<span class="hljs-function">(<span class="hljs-params">item,idx</span>) =&gt;</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">List.Item</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.deleteItem.bind(this,idx)&#125;</span>&gt;</span>&#123;item&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">List.Item</span>&gt;</span></span>)&#125;<br>                    /&gt;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> TodoList;<br></code></pre></td></tr></table></figure><h4 id="“-src-store-index-js”"><a href="#“-src-store-index-js”" class="headerlink" title="“./src/store/index.js”"></a>“./src/store/index.js”</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">// npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save redux</span><br>// 创建 redux <span class="hljs-keyword">store</span> 仓库：创建 <span class="hljs-keyword">store</span> 文件夹；创建 index.js 文件<br><br>// 引入 createStore 方法，顾名思义<span class="hljs-comment">--创建仓库</span><br><span class="hljs-keyword">import</span> &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span><br>// 将 reducer 引入 <span class="hljs-keyword">store</span> 中，实现 reducer 到 <span class="hljs-keyword">store</span> 的绑定(见 redux 官方结构图)<br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span><br><br>// 调用 createStore 方法创建 <span class="hljs-keyword">store</span> 仓库<br>// reducer 以参数形式传递给 createStore()，可以理解为在搭建仓库的时候就招募了一个管理员<br>const <span class="hljs-keyword">store</span> = createStore(reducer)<br><br>// 将仓库暴露出去<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">store</span><br></code></pre></td></tr></table></figure><h4 id="“-src-store-reducer-js”"><a href="#“-src-store-reducer-js”" class="headerlink" title="“./src/store/reducer.js”"></a>“./src/store/reducer.js”</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs pf">//仓库需要一个管理员 reducer 进行管理<br><br>// 定义默认<span class="hljs-keyword">state</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">default</span>State = &#123;<br>    inputValue: <span class="hljs-string">&quot;Please input something ...&quot;</span>,<br>    list: [<br>            <span class="hljs-string">&quot;第一条数据&quot;</span>,<br>            <span class="hljs-string">&quot;第二条数据&quot;</span>,<br>            <span class="hljs-string">&quot;第三条数据&quot;</span>,<br>        ],<br>&#125;<br><br>// 暴露 reducer 的管理行为：接收 <span class="hljs-keyword">state</span>，根据 action 动作返回新的 <span class="hljs-keyword">state</span><br>// <span class="hljs-keyword">state</span>=<span class="hljs-keyword">default</span>State 写在 action 之前，否则传出的数据不正确，why?<br>// <span class="hljs-keyword">state</span> 参数：store 仓库内的原始状态<br>// action 参数：action 新传递的状态<br>// store 只是仓库，没有管理能力，根据 store 的自动推送策略，store 会将接收的 action 自动转发给 reducer<br>export <span class="hljs-keyword">default</span> (<span class="hljs-keyword">state</span>=<span class="hljs-keyword">default</span>State,action) =&gt; &#123;<br>    // 在 reducer 中，我们获得了原始状态 <span class="hljs-keyword">state</span> 和新传递的状态 action，下一步就是改变 store 内的 <span class="hljs-keyword">state</span><br>    //console.<span class="hljs-keyword">log</span>(<span class="hljs-keyword">state</span>,action)<br><br>    /*<br>    用 if 语句识别当前的 action 对象，<br>    因为每个事件都定义一个 action ，则需要通过 action.type 区分，<br>    这也就解释了为什么 type 属性在 action 中是必需的。<br>    */<br>    if(action.type === <span class="hljs-string">&quot;change_input_value&quot;</span>) &#123;<br>        /*<br>        !!!重点<br>        reducer 中只能接收 <span class="hljs-keyword">state</span> ，但不能直接改变 <span class="hljs-keyword">state</span><br>        因此，我们需要换种方法：<br>        定义一个新的<span class="hljs-keyword">state</span>变量，作为临时变量，将 <span class="hljs-keyword">state</span> 通过 JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>)) 进行深度拷贝<br>        通过重新赋值改变临时变量，再将新的状态抛出<br>        */<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.inputValue = action.value<br>        return newState<br>    &#125;<br><br>    if(action.type === <span class="hljs-string">&quot;value_submit&quot;</span>) &#123;<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.list.push(newState.inputValue)<br>        return newState<br>    &#125;<br><br>    if(action.type === <span class="hljs-string">&quot;delete_item&quot;</span>) &#123;<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.list.splice(action.index,<span class="hljs-number">1</span>)<br>        return newState<br>    &#125;<br><br>    return <span class="hljs-keyword">state</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="React-三个易错点"><a href="#React-三个易错点" class="headerlink" title="React 三个易错点"></a>React 三个易错点</h2><ol><li>store必须是<strong>唯一</strong>的，多个store是坚决不允许，只能有一个store空间</li><li>只有store能改变自己的内容，Reducer不能改变</li><li>Reducer必须是<strong>纯函数</strong></li></ol><h3 id="Store-仓库唯一"><a href="#Store-仓库唯一" class="headerlink" title="Store 仓库唯一"></a>Store 仓库唯一</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import &#123;createStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span><br>import reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span><br>const store = createStore(reducer)<br><span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>store;<br></code></pre></td></tr></table></figure><p>我们在 <code>/store/index.js</code> 文件中，用createStore()方法，声明了一个store。之后整个应用都在使用这个 store，并且只能创建和使用这一个 store ，否则会报错。</p><h3 id="改变-state-的是-Store-，而不是-Reducer"><a href="#改变-state-的是-Store-，而不是-Reducer" class="headerlink" title="改变 state 的是 Store ，而不是 Reducer"></a>改变 state 的是 Store ，而不是 Reducer</h3><p>我们在写 redux 时将业务逻辑代码都写在了 Reducer 中，但这并不意味着组建的 state 状态是在 Reducer 中改变的。事实上 Reducer 中只能接收 state ，而不允许改变 state。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">export <span class="hljs-keyword">default</span> (<span class="hljs-keyword">state</span> = <span class="hljs-keyword">default</span>State, action) =&gt; &#123;<br>    if (action.type === INPUT_CHANGE_VALUE) &#123;<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.inputValue = action.value<br>        return newState<br>    &#125;<br>    return <span class="hljs-keyword">state</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上述代码示例，在 Reducer 中我们声明了一个新的临时状态变量<code>newState</code>来深度拷贝当前状态，最终只是将新的状态作了一个返回，返回到了store中，并没有作任何改变。Reudcer 只是返回了更改的数据，但是并没有更改 store 中的数据，store 拿到了 Reducer 的数据，自己对自己进行了更新。</p><blockquote><p>关于 Store 和 Reducer 中的 state 关联，引用一个网友的评论：<br>redux内的reducer里面的state初始时是一个默认赋值，当store里有state数据时，每次传入当前的currentstate给reducer内的state，所以reducer每次拷贝的是当前的state状态，并不是defaultvalue，reducer 经过 action 后返回更改的 newState 状态到 Store 中，而 Store 会将这些状态改动更新到仓库的状态中。</p></blockquote><h3 id="Reducer-必须是纯函数"><a href="#Reducer-必须是纯函数" class="headerlink" title="Reducer 必须是纯函数"></a>Reducer 必须是纯函数</h3><p><strong>纯函数：</strong> 如果函数的调用参数相同，则永远返回相同的结果。<strong>返回结果</strong>不依赖于程序执行期间函数外部任何状态或数据的变化，必须<strong>只依赖于其输入参数</strong>。<br>简单理解，若1. 某一函数的返回结果是由传入的值(形参)决定的，而不是其它的东西决定的，2. 函数不产生副作用(不影响外部变量)，那么该函数就是纯函数。</p><ul><li><p>纯函数</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">const aaa = (<span class="hljs-symbol">x</span>, <span class="hljs-symbol">y</span>) =&gt; &#123;<br>    let m = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-symbol">x</span> + <span class="hljs-symbol">y</span> + m <span class="hljs-comment">//函数返回结果由函数参数决定</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>非纯函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xxx = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() <span class="hljs-comment">//或 ajax,axios 异步请求等</span><br>    <span class="hljs-keyword">return</span> x + y + m <span class="hljs-comment">//函数结果受外部影响，结果不能由参数决定</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>Reducer 中返回状态只由 state 和 action 决定。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">export <span class="hljs-keyword">default</span> (<span class="hljs-keyword">state</span> = <span class="hljs-keyword">default</span>State, action) =&gt; &#123;<br>    if (action.type === INPUT_CHANGE_VALUE) &#123;<br>        let newState = JSON.parse(JSON.stringify(<span class="hljs-keyword">state</span>))<br>        newState.inputValue = action.value<br>        return newState<br>    &#125;<br>    return <span class="hljs-keyword">state</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>Redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React小书学习笔记 —— 高阶组件（Higher-Order Components）</title>
    <link href="/2020/11/29/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%88Higher-Order%20Components%EF%BC%89/"/>
    <url>/2020/11/29/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%88Higher-Order%20Components%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习前端一小步，迈向成功一大步！本专栏主要记录学习前端React框架的一些个人心得，分享一些实战教学，如有不足，欢迎交流讨论。React框架的入门教学强推<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a>的<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a>，简单易懂还有代码实战。还等什么？让我们开始本篇的前端学习之旅，欢迎各位入坑前端！</p><a id="more"></a><h1 id="高阶组件（Higher-Order-Components）"><a href="#高阶组件（Higher-Order-Components）" class="headerlink" title="高阶组件（Higher-Order Components）"></a>高阶组件（Higher-Order Components）</h1><p>参考教程：React小书–第28节(高阶组件（Higher-Order Components））<br>教程作者：<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a><br>参考链接：<a href="http://huziketang.mangojuice.top/books/react/lesson28">React小书</a><br><strong>本文搭配原文教程食用，风味更佳~!</strong></p><hr><h2 id="什么是高阶组件？"><a href="#什么是高阶组件？" class="headerlink" title="什么是高阶组件？"></a>什么是高阶组件？</h2><p>高阶组件是一个函数（而不是组件），它接受一个组件作为参数，返回一个新的组件。例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> <span class="hljs-type">React</span>,&#123;<span class="hljs-type">Component</span>&#125; from <span class="hljs-symbol">&#x27;reac</span>t&#x27;<br><br>export <span class="hljs-keyword">default</span> (<span class="hljs-type">WrappedComponent</span>) =&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-comment">// 可以做很多自定义逻辑</span><br>    render () &#123;<br>      <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">WrappedComponent</span> /&gt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>接收 <code>WrappedComponent</code> 组件**(组件名首字母大写)** ，返回了 <code>NewComponent</code> 新组件，此处因为只有 <code>class ...</code> 一个整体语句，所以省略了 <code>&#123;&#125; 和 return</code>。</li><li><code>WrappedComponent</code> 代表子组件，是形参名可以更改，但是习惯上用 <code>WrappedComponent</code> 来表示。</li><li>高阶组件是一个函数</li></ul><h2 id="高阶组件作用"><a href="#高阶组件作用" class="headerlink" title="高阶组件作用"></a>高阶组件作用</h2><p>用于代码复用，可以把组件之间可复用的代码、逻辑抽离到高阶组件当中。高阶组件包装组件和被包装组件之间通过 props 传递数据。</p><h2 id="高阶组件使用示例"><a href="#高阶组件使用示例" class="headerlink" title="高阶组件使用示例"></a>高阶组件使用示例</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> <span class="hljs-type">React</span>, &#123; <span class="hljs-type">Component</span> &#125; from <span class="hljs-symbol">&#x27;reac</span>t&#x27;<br><br>export <span class="hljs-keyword">default</span> (<span class="hljs-type">WrappedComponent</span>, name) =&gt; &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    constructor () &#123;<br>      <span class="hljs-keyword">super</span>()<br>      <span class="hljs-keyword">this</span>.state = &#123; data: <span class="hljs-literal">null</span> &#125;<br>    &#125;<br><br>    componentWillMount () &#123;<br>      let data = localStorage.getItem(name)<br>      <span class="hljs-keyword">this</span>.setState(&#123; data &#125;)<br>    &#125;<br><br>    render () &#123;<br>      <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">WrappedComponent</span> data=&#123;<span class="hljs-keyword">this</span>.state.data&#125; /&gt;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">NewComponent</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们定义了一个高阶组件，除了传入子组件外，我们还传入了一个参数 name ，在高阶组件内我们实现了从 name 读取数据，并设置 data 参数向子组件传递该值。<br>子组件调用高阶组件的方法如下所示：</p><ol><li>import 高阶组件(上述未定义变量名，因此引入的变量自定义名称)</li><li>高阶组件是个函数，因此同函数调用类似，在子组件外部套上高阶组件，传入子组件名和参数</li><li>导出子组件</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> wrapWithLoadData from &#x27;./wrapWithLoadData&#x27;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputWithUserName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  render () &#123;<br>    <span class="hljs-keyword">return</span> &lt;input value=&#123;<span class="hljs-keyword">this</span>.props.data&#125; /&gt;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">InputWithUserName</span> = wrapWithLoadData(<span class="hljs-type">InputWithUserName</span>, <span class="hljs-symbol">&#x27;usernam</span>e&#x27;)<br>export <span class="hljs-keyword">default</span> <span class="hljs-type">InputWithUserName</span><br></code></pre></td></tr></table></figure><h2 id="编写高阶组件步骤"><a href="#编写高阶组件步骤" class="headerlink" title="编写高阶组件步骤"></a>编写高阶组件步骤</h2><ol><li>实现一个普通组件</li><li>将普通组件用函数包裹</li><li>在函数内用 <code>return</code> 将新的组件抛出</li></ol><p>编写的方式有两种：<br>第一种:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala">function funcName(<span class="hljs-type">OldComponent</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>        render () &#123;<br>            <span class="hljs-keyword">return</span> (<br>                &lt;div&gt;<br>                    &lt;<span class="hljs-type">WrappedComponent</span> /&gt;<br>                &lt;/div&gt;<br>            )<br>        &#125;<br>    &#125;<br>&#125;<br>export <span class="hljs-keyword">default</span> funcName;<br></code></pre></td></tr></table></figure><p>第二种:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (WrappedComponent) =&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewComponent</span> <span class="hljs-title">extentds</span> <span class="hljs-title">Component</span> </span>&#123;<br>    render () &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;WrappedComponent /&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React的img标签</title>
    <link href="/2020/11/29/React%E7%9A%84img%E6%A0%87%E7%AD%BE/"/>
    <url>/2020/11/29/React%E7%9A%84img%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="React的img标签"><a href="#React的img标签" class="headerlink" title="React的img标签"></a>React的img标签</h1><p>参考链接：<br><a href="https://www.cnblogs.com/tu-0718/p/12530654.html">react中img引入本地图片的2种方式</a><br><a href="https://www.cnblogs.com/chenbeibei520/p/10930281.html">react项目中关于img标签的src属性的使用</a></p><hr><h2 id="方法一：import"><a href="#方法一：import" class="headerlink" title="方法一：import"></a>方法一：import</h2><p>在 js 文件开头用 import 将本地图片从相对路径中引入为变量</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> homePage <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../static/images/home.png&#x27;</span><br></code></pre></td></tr></table></figure><p>例如此处将 <code>&quot;../static/images/&quot;</code> 路径下的 <code>home.png</code> 图片引入为 <code>homePage</code> 变量。<br>然后在 <code>&lt;img src=&#123;&#125;&gt;</code>中引用该变量名即可。(变量名随意，<code>&#123;&#125;</code>必须，因为 jsx 元素要用 <code>&#123;&#125;</code> 包裹表达式)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;homePage&#125;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="方法二：require方法"><a href="#方法二：require方法" class="headerlink" title="方法二：require方法"></a>方法二：require方法</h2><p>用 require 方法在代码内导入本地图片。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">const</span> <span class="hljs-variable">homePage</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;../static/images/home.png&#x27;</span>)</span><br>&lt;<span class="hljs-variable">img</span> <span class="hljs-variable">src</span>=&#123;<span class="hljs-variable">homePage</span>&#125;&gt;<br></code></pre></td></tr></table></figure><p>或者直接</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;require(</span>&#x27;<span class="hljs-attr">..</span>/<span class="hljs-attr">static</span>/<span class="hljs-attr">images</span>/<span class="hljs-attr">home.png</span>&#x27;)&#125;&gt;</span><br></code></pre></td></tr></table></figure><p>整体思想同 import 类似，即从相对路径引入本地图片并赋值到一个变量。因此，<strong>require中只能写字符串，不能写变量。（因为 require 接收的是一个路径字符串）</strong></p><blockquote><p>一般推荐使用 import 引入图片。<br>用 require 导入容易存在后续 webpack 打包时读取不到本地图片的情况。<br>但是 require 可以实现动态的加载。</p></blockquote><h2 id="import-和-require"><a href="#import-和-require" class="headerlink" title="import 和 require"></a>import 和 require</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>import 和 require 是 react 的两种导入方式。其可以导入图片 / 组件等。<br>其本质就是从路径地址读取目标，并赋值给一个变量。(js中的export即为导出的接口)</p><ol><li>import(常用)<br><code>import component from &#39;./component&#39;</code></li><li>require<br><code>const component = require(&#39;./component&#39;)</code></li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>提出的规范不同<br>import是ES6语法,reuqire是CommonJs提出的，import会通过babel转换成CommonJS规范。<br>因此，下面两行代码是等价的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> component <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./component&#x27;</span><br><span class="hljs-comment">// =&gt; </span><br><span class="hljs-keyword">const</span> component = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./component&#x27;</span>)<br></code></pre></td></tr></table></figure><p>推荐统一规范一种导入方式,防止混乱，当然,不同情况使用的方式也是不一样的。</p><blockquote><p>一般来说使用import就够了，但是要注意import需要放在定义组件的外部。这就导致一个问题: 如果我需要通过动态路径动态加载组件，那么我们就要用到 require 的导入方法。<br>当需要实现动态加载图片时，我们往往会在require中引入一个变量，但require中不能直接赋值一个变量，正确做法应该是将<code>require(path)</code>拆分成三个部分(即文件路径+名称+后缀)，如下：</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">let homePage</span> = <span class="hljs-string">&quot;home&quot;</span>;<br><span class="hljs-attribute">const data</span> = require(<span class="hljs-string">&#x27;../static/images/&#x27;</span> + homePage + <span class="hljs-string">&#x27;.png&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-router-dom 路由</title>
    <link href="/2020/11/29/react-router-dom%E8%BF%90%E7%94%A8/"/>
    <url>/2020/11/29/react-router-dom%E8%BF%90%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="react-router-dom运用"><a href="#react-router-dom运用" class="headerlink" title="react-router-dom运用"></a>react-router-dom运用</h1><p>参考链接：<a href="https://www.cnblogs.com/lovels/p/11574700.html">React：react-router-dom 详解</a></p><hr><h2 id="第一步：安装-react-router-dom-第三方库"><a href="#第一步：安装-react-router-dom-第三方库" class="headerlink" title="第一步：安装 react-router-dom 第三方库"></a>第一步：安装 react-router-dom 第三方库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> <span class="hljs-comment">--save react-router-dom</span><br></code></pre></td></tr></table></figure><p>在 React 框架 <code>/src</code> 文件夹下新建 <code>router.js</code>，存放路由设置代码。</p><h2 id="第二步：导入"><a href="#第二步：导入" class="headerlink" title="第二步：导入"></a>第二步：导入</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123;BrowserRouter, Route, <span class="hljs-keyword">Switch</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span><br></code></pre></td></tr></table></figure><p>在 <code>router.js</code> 文件开头导入 <strong>BrowserRouter, Route, Switch</strong>。</p><h2 id="第三步：设置并导出路由"><a href="#第三步：设置并导出路由" class="headerlink" title="第三步：设置并导出路由"></a>第三步：设置并导出路由</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./pages/home&#x27;</span><br><span class="hljs-keyword">import</span> Car <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./pages/car&#x27;</span><br><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./pages/user&#x27;</span><br>...<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;(<br>    &lt;BrowserRouter&gt;<br>        &lt;Switch&gt;<br>            &lt;Route path=&#123;<span class="hljs-string">&#x27;/home&#x27;</span>&#125; component=&#123;Home&#125;&gt;&lt;/Route&gt;<br>            &lt;Route path=&#123;<span class="hljs-string">&#x27;/car&#x27;</span>&#125; component=&#123;Car&#125;&gt;&lt;/Route&gt;<br>            &lt;Route path=&#123;<span class="hljs-string">&#x27;/user&#x27;</span>&#125; component=&#123;User&#125;&gt;&lt;/Route&gt;<br>            ...<br>        &lt;/Switch&gt;<br>    &lt;/BrowserRouter&gt;<br>)<br></code></pre></td></tr></table></figure><blockquote><p><code>&lt;Route path=&#123;&#125; component=&#123;&#125;&gt;&lt;/Route&gt;</code> 可以理解为将相应组件绑定到了对应的路由上。</p></blockquote><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><strong>书写顺序：</strong> <code>&lt;BrowserRouter&gt; -&gt; &lt;Switch&gt; -&gt; &lt;Route&gt;</code>，其中 <code>&lt;Route&gt;</code> 可以存在多条，每条<code>&lt;Route&gt;</code>指向一条跳转路径。</li><li><strong><code>&lt;Route&gt;</code>参数：</strong> path 参数对应跳转页面的相对路径，component 参数对应相应页面的组件。注意将组件从相应位置导入，否则路由不知道 component 设置的变量是什么意思。</li><li><strong>关于箭头函数()=&gt;()：</strong> 在ES6中规定，如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。此处的 JSX 元素需要用<code>()</code>包裹，从而可以视为一个条语句，省略 <code>&#123;&#125;</code> 和 <code>return</code> 。使用<code>()</code>包裹jsx，而不要用<code>&#123;&#125;</code>包裹，准备杨可以避免js中换行自动插入<code>;</code>的问题。</li></ol><hr><h1 id="Link-标签实现路由跳转"><a href="#Link-标签实现路由跳转" class="headerlink" title="Link 标签实现路由跳转"></a>Link 标签实现路由跳转</h1><h2 id="第一步：从-react-router-dom-引入-Link"><a href="#第一步：从-react-router-dom-引入-Link" class="headerlink" title="第一步：从 react-router-dom 引入 Link"></a>第一步：从 react-router-dom 引入 Link</h2><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">import</span> &#123;Link&#125; <span class="hljs-keyword">from</span> <span class="hljs-keyword">react</span>-router-dom<br></code></pre></td></tr></table></figure><h2 id="第二步：使用-Link-标签"><a href="#第二步：使用-Link-标签" class="headerlink" title="第二步：使用 Link 标签"></a>第二步：使用 Link 标签</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;<span class="hljs-keyword">Link</span> <span class="hljs-keyword">to</span>=<span class="hljs-string">&#x27;/more&#x27;</span>&gt;&lt;/ <span class="hljs-keyword">Link</span>&gt;<br></code></pre></td></tr></table></figure><p>实现效果：点击后跳转到 <code>&#39;./more&#39;</code> 界面。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>react-router-dom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>attention 机制详解</title>
    <link href="/2020/11/26/attention/"/>
    <url>/2020/11/26/attention/</url>
    
    <content type="html"><![CDATA[<h1 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h1><p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/69111029">Self-Attention和Transformer</a><br><a href="https://www.bilibili.com/read/cv4902832/">拆 Transformer 系列二：Multi- Head Attention 机制详解</a><br><a href="https://www.zhihu.com/question/68482809">目前主流的attention方法都有哪些？</a></p><hr><h2 id="Attention-实现机制-本质"><a href="#Attention-实现机制-本质" class="headerlink" title="Attention 实现机制(本质)"></a>Attention 实现机制(本质)</h2><p>Attention 机制实质上就是一个寻址过程：<br>通过给定一个任务相关的查询 Query 向量 Q，通过计算与 Key 的注意力分布并附加在 Value 上，从而计算 Attention Value。<br>其中涉及到了<strong>注意力打分机制</strong>和<strong>注意力概率分布作用过程</strong>。</p><h2 id="What-is-Q-K-V"><a href="#What-is-Q-K-V" class="headerlink" title="What is Q, K, V ?"></a>What is Q, K, V ?</h2><h3 id="字面理解"><a href="#字面理解" class="headerlink" title="字面理解"></a>字面理解</h3><p>Q: Question，问题<br>K：Key，关键字<br>V：Value，值<br>模型抛出一个问题（被查询的对象），根据辅助的关键字信息，得到两者间的<strong>相似度关系</strong>，经过归一化（softmax）后。作用在目标值上，即实现了根据前者相似度来影响目标的权重分布。<br>前一句体现了注意力的打分机制，后一句则体现了利用概率影响 Value 的作用机制。</p><blockquote><p>本质：根据注意力的打分机制，计算两个对象内部的相似关系，并将其作用于目标中。</p></blockquote><p>关于注意力的整个过程，形象理解如下(转自<a href="https://zhuanlan.zhihu.com/p/69111029">Self-Attention和Transformer</a>)：<br><img src="/img/posts_img/20201126104032318_9538.png"><br><img src="/img/posts_img/20201126104103806_13047.png"></p><h2 id="注意力打分机制"><a href="#注意力打分机制" class="headerlink" title="注意力打分机制"></a>注意力打分机制</h2><p>$\alpha_i=softmax(s(x_i,q))$，其中$\alpha$为注意力概率分布，$s(x_i,q)$为注意力打分机制。</p><p>常用的注意力打分机制有以下几种：</p><ol><li>加性模型：$s(x_i,q)=v^Ttanh(Wx_i+Uq)$</li><li>点积模型：$s(x_i,q)=x_i^Tq$</li><li>缩放点积模型：$s(x_i,q)=(x_i^Tq)/\sqrt{d_k}$</li><li>双线性模型：$s(x_i,q)=x_i^TWq$</li></ol><p>$attention(V)=\sum_{i=1}^N\alpha_iV_i=\alpha V$</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>缩放点积模型能防止点积结果过大导致 softmax 梯度过小，反向传播困难的情况。缩放点积模型相较于点积模型更好。</li><li>点积模型及缩放点积模型需要保证矩阵的点积规则，及$(N\times H)\cdot(H\times V)$，在 self-attention 中，由于 Q 和 K 矩阵行数相同，因此仅需要注意最后得到结果的矩阵大小。假设 Q 长度为4，embed_dim 为6的序列($6\times 4$)，K 大小为$6\times 3$，那么就不能硬套上述点积公式，因为我们目标是获得 Q 和 K 的相似关系，即最后矩阵大小为 $3\times 4$，所以我们注意力打分的点积模型为 $s(x,q)=K^TQ$。</li><li>若 Q，K 的矩阵点积无法满足点积规则，则可以用双线性模型或者加性模型，其中 W，U 的作用就是将两者拉到同一维度上进行矩阵运算。</li></ol><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>阅读了<a href="https://www.zhihu.com/question/68482809">目前主流的attention方法都有哪些？</a>，特来对注意力打分机制的公式做一个补充。</p><blockquote><p>注意力机制可以分为三步：一是信息输入；二是计算注意力分布α；三是根据注意力分布α 来计算输入信息的加权平均。</p></blockquote><ol><li>信息输入：$X=[x_0,…,x_N]$表示N 个输入信息。注意思考此处$x_i$的编码向量为：<strong>列向量</strong> (对于后续公式的理解很重要!!!)</li><li>注意力分布计算：令<strong>Key=Value=X</strong>，则可以给出注意力分布，$\alpha_i=softmax(s(k_i,q))=softmax(s(x_i,q))$。</li><li>根据打分机制计算注意力得分系数：<br>加性模型：$s(x_i,q)=v^Ttanh(Wx_i+Uq)$<br>点积模型：$s(x_i,q)=x_i^Tq$<br>缩放点积模型：$s(x_i,q)=(x_i^Tq)/\sqrt{d_k}$<br>双线性模型：$s(x_i,q)=x_i^TWq$</li><li>信息加权：注意力分布 $\alpha_i$ 可以解释为在上下文查询q时，<strong>第i个信息受关注的程度</strong>，采用一种“软性”的信息选择机制对输入信息X进行编码为，$attention(q,X)=\sum_{i=1}^N\alpha_iX_i$，用矩阵乘法表示为 $V(K^TQ)$，注意列向量是右乘的形式，若以行向量计算则为左乘形式$(QK^T)V$。</li></ol><h2 id="软性注意力机制（soft-Attention）"><a href="#软性注意力机制（soft-Attention）" class="headerlink" title="软性注意力机制（soft Attention）"></a>软性注意力机制（soft Attention）</h2><p>软性注意力机制有两种：普通模式（<strong>Key=Value=X</strong>）和键值对模式（<strong>Key！=Value</strong>）:<br><img src="/img/posts_img/20201126143000592_26756.png"></p><h2 id="疑点"><a href="#疑点" class="headerlink" title="疑点"></a>疑点</h2><p>在学习 transformer 过程中一直有个疑问，在点积模型中，$s(x_i,q)=x_i^Tq$，可知，$q$对应的是Q，而$x$对应的是K，可是在transformer中，公式是$QK^T$，按理来说两者表达的是同一个意思，但是矩阵左乘和右乘还是有一定区别的，故对此做了相应的思考，最终得出一个解释：<br>在$s(x_i,q)=x_i^Tq$中，$x_i$是以列向量形式表示的！即假设$x_i$是一个embed_dim=4的单词，那么实际上它的向量形式表示为$(4\times 1)$。<br>所以：<br><strong>向量尽量以列向量表示！！！</strong><br><strong>向量尽量以列向量表示！！！</strong><br><strong>向量尽量以列向量表示！！！</strong><br>完毕！</p><hr><h1 id="补充2"><a href="#补充2" class="headerlink" title="补充2"></a>补充2</h1><p>之前一直没有弄明白 Query, Key, Value 是怎么区分的，上述补充我们已知 Key = Value 和 Key != Value 的情况，即 Key 和 Value 在某种情况下是互通的，但是 Query 又怎么区分呢？什么可以作为 Query ？<br>参考<a href="https://blog.csdn.net/hahajinbu/article/details/81940355">自然语言处理中的Attention机制总结</a></p><h2 id="attention-通用定义"><a href="#attention-通用定义" class="headerlink" title="attention 通用定义"></a>attention 通用定义</h2><p>按照Stanford大学课件上的描述，<strong>attention的通用定义</strong>如下：</p><ol><li>给定一组<strong>向量集合</strong>values，以及<strong>一个向量</strong>query，attention机制是一种根据该query计算values的加权求和的机制。</li><li>attention的重点就是这个集合values中的每个value的“权值”的计算方法。</li></ol><h2 id="Query-目标向量"><a href="#Query-目标向量" class="headerlink" title="Query: 目标向量"></a>Query: 目标向量</h2><p>参考链接：<a href="https://www.jianshu.com/p/6b2e586f9256">attention机制</a><br>在自然语言处理中，我们通常<strong>将目标作为 Query ，辅助信息作为 Key 和 Value</strong>。<br>例如在英译汉中，我们已知英语，需要对汉语做权值重新分配，则将汉语词向量作为 Query = “老师早上好”，将英语作为 (Key / Value) = “Goodmorning teacher”，设 embedding dim 大小为 3，Query 向量大小为 $3\times 5$，(Key / Value) 向量大小为 $3\times 2$，计算相似度 $K^TQ = (2\times 5)$，将相似度作用于 Value 上，得到 $V(K^TQ)=(3\times 5)$。可以看到最终输出的向量大小与 Query 保持一致，这也是为什么将 Query 作为自然语言处理目标向量的原因，因为其根据 Key 调整的是 Query 的权重分布。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>attention</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transformer的位置编码</title>
    <link href="/2020/11/23/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82Transformer%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/11/23/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82Transformer%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一文读懂Transformer模型的位置编码——学习笔记"><a href="#一文读懂Transformer模型的位置编码——学习笔记" class="headerlink" title="一文读懂Transformer模型的位置编码——学习笔记"></a>一文读懂Transformer模型的位置编码——学习笔记</h1><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/106644634">一文读懂Transformer模型的位置编码</a></p><hr><h2 id="Transformer-为什么需要位置编码？"><a href="#Transformer-为什么需要位置编码？" class="headerlink" title="Transformer 为什么需要位置编码？"></a>Transformer 为什么需要位置编码？</h2><ol><li>单词在文本中的位置以及排列顺序对于文本语义的表达十分重要。整个文本的段落含义很可能随着一个单词在句子的位置或排列顺序不同而产生偏差。</li><li>RNN 本身就是个顺序结构，包含了词在序列中的位置信息，因此不需要单独对序列进行位置编码。而 transformer 用 attention 完全取代 RNN 结构后，词序信息就会丢失，模型没有办法知道每个词在文本中的相对和绝对的位置信息。因此，有必要把词序信号加到词向量上帮助模型学习这些信息，所采用的方法即称为位置编码。</li></ol><h2 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>位置编码（Positional Encoding）是一种用词的位置信息对序列中的每个词进行二次表示的方法。Transformer模型本身不具备像RNN那样的学习词序信息的能力，需要主动将词序信息喂给模型。那么，模型原先的输入是不含词序信息的词向量，位置编码需要将词序信息和词向量结合起来形成一种新的表示输入给模型，这样模型就具备了学习词序信息的能力。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>一种好的位置编码方案需要满足以下几条要求：</p><ul><li>它能为每个时间步输出一个独一无二的编码；</li><li>不同长度的句子之间，任何两个时间步之间的距离应该保持一致；</li><li>模型应该能毫不费力地泛化到更长的句子。它的值应该是有界的；</li><li>它必须是确定性的。</li></ul><p><strong>方法一</strong>：分配一个0到1之间的数值给每个时间步，其中，0表示第一个词，1表示最后一个词。<br>存在的问题：无法知道在一个特定区间范围内到底存在多少个单词。换句话说，不同句子之间的时间步差值没有任何的意义。如图，<br><img src="/img/posts_img/20201123103224198_2462.png"><br>将 0 和 1 分别分配给第一个词和最后一个词，但关于内部数值的分配我们不得而知，0.5对应的时间步(词位置)可能在句子一半靠前的位置，也可能在一半靠后的位置，即不会完全对应于句子中心，因此，你无法确定在某个区间范围内包含了多少个单词。</p><p><strong>方法二</strong>：为了解决上述方法任意两个时间步空间距离相等的情况，线性分配一个数值给每个时间步。也就是，1分配给第一个词，2分配给第二个词，以此类推，这样各个词间的距离就均保证为1且相等。<br>存在的问题：随着文本长度增加，这些数值会变得非常大，此外，模型也会遇到一些比训练中的所有句子都要长的句子。数据集中不一定在所有数值上都会包含相对应长度的句子，也就是模型很有可能没有看到过任何一个这样的长度的样本句子，这会严重影响模型的泛化能力。如图，<br><img src="/img/posts_img/20201123105313573_11133.png"></p><p>上述方法均存在一定的问题，没有满足位置编码方案的要求。Transformer 则提出了一种基于三角函数的位置编码方式，很好的解决了上述问题，我们将具体分析它是如何解决这些问题的。</p><hr><h2 id="Position-Encoding"><a href="#Position-Encoding" class="headerlink" title="Position Encoding"></a>Position Encoding</h2><ul><li>Position Encoding 编码不是单一的一个数值，而是包含句子中特定位置信息的 d 维向量 (一个位置对应一个 d 维向量)。</li><li>Position Encoding 编码没有整合进模型，而是用这个向量让每个词具有它在句子中的位置的信息。换句话说，通过注入词的顺序信息来增强模型输入 (Position Encoding + Input Embedding)。</li></ul><h3 id="t位置信息-gt-d维向量"><a href="#t位置信息-gt-d维向量" class="headerlink" title="t位置信息 -&gt; d维向量"></a>t位置信息 -&gt; d维向量</h3><p>假设文本输入为一个长度为 n 的序列，我们用 t 来表示第 t 个词在文本中的位置。根据上述信息，我们可以将文本中一个特定位置信息表示为一个 d 维向量，因此，我们将 t 所对应的 d 维向量记为 $p_t\in R^d$，其对应的函数映射我们记为$f:N\rightarrow R^d$，即有 $p_t=f(t)$，其中 $f()$函数映射计算第 i 个维度的 $p_t^i$ 的具体公式如下，<br><img src="/img/posts_img/20201123111244476_2311.png"><br>其中，$k\in [0,(d_{model} - 1)/2]$，频率$w_k=1/(10000^{2k/d})$，$i\in [1,d_{model}]$表示向量的第 i 维。<strong>频率沿向量维度减小，且 d 可被 2 整除。</strong><br>因此，遍历 k 计算各个维度，每个 t 对应的位置编码 $p_t$可以表示为如下所示，向量长度为 d，<br><img src="/img/posts_img/20201123112135158_31524.png"></p><p>其中，将所有输入序列的编码向量(n个d维向量)进行排列，可得到如下图像，其表示了长度为200、维度为150的序列转置后的位置矩阵PE，红线指输入序列的第 i 个维度。<br><img src="/img/posts_img/20201123112608523_18448.png"></p><h3 id="Position-Encoding-Input-Embedding"><a href="#Position-Encoding-Input-Embedding" class="headerlink" title="Position Encoding + Input Embedding"></a>Position Encoding + Input Embedding</h3><p>位置编码方法已经有了，那如何让每个词具有它们的位置信息？原始论文将位置编码加到模型输入之上。也就是，对于句子里的每个词，计算其对应的词嵌入，然后按照下面的方法喂给模型：<br><img src="/img/posts_img/20201123113620325_27960.png"></p><blockquote><p>为了保证这种相加操作正确，需要让位置向量（PE）的维度等于词向量（WE）的维度，即 $d_{PE}=d_{WE}$。假设某位置 t 的词被 embedding 编码为了 4 维向量，那么执行相加操作的时候，必须也要保证位置编码后的 p 向量维度也为 4，这也就解释了为什么上述 $p_t\in R^{d_{model}}$的原因。</p></blockquote><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="/img/posts_img/20201123114050252_14574.png"></p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>社矫项目：jQuery事件绑定失效原因总结</title>
    <link href="/2020/11/22/JQuery%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/22/JQuery%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery事件绑定失效问题"><a href="#jQuery事件绑定失效问题" class="headerlink" title="jQuery事件绑定失效问题"></a>jQuery事件绑定失效问题</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>社矫项目中部分 js 代码及 html 代码如下：<br><strong>监听汉字输入的 js 代码：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入汉字监听</span><br>$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>    $(<span class="hljs-string">&#x27;#nameSearch&#x27;</span>).on(<span class="hljs-string">&#x27;compositionend&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span>=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">let</span> val = $(<span class="hljs-string">&#x27;#nameSearch&#x27;</span>).val();<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">Number</span>(val))</span>)</span>&#123;<br>            debounce(tooltips, <span class="hljs-number">2000</span>)();<br>        &#125;<br>    &#125;);<br>&#125;)<br><span class="hljs-comment">// $(&#x27;#nameSearch&#x27;).on(&#x27;compositionend&#x27;, event=&gt;&#123;</span><br><span class="hljs-comment">//     console.log(1);</span><br><span class="hljs-comment">//     let val = $(&#x27;#nameSearch&#x27;).val();</span><br><span class="hljs-comment">//     if(isNaN(Number(val)))&#123;</span><br><span class="hljs-comment">//         debounce(tooltips, 2000)();</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;)</span><br></code></pre></td></tr></table></figure><p><strong>搜索框的 html 代码：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;position: absolute; width: 300px; height: auto; left:25px&quot;</span>&gt;<br>&lt;form <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;navbar-form1 input-group&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;search1&quot;</span> onsubmit=<span class="hljs-string">&quot;return false&quot;</span> style=<span class="hljs-string">&quot;position:absolute;&quot;</span>&gt;<br>&lt;input type=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;nameSearch&quot;</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;nameSearch&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> onkeydown=<span class="hljs-string">&quot;search();&quot;</span> <span class="hljs-built_in">list</span>=<span class="hljs-string">&quot;nameList&quot;</span> autocomplete=<span class="hljs-string">&quot;on&quot;</span><br>placeholder=<span class="hljs-string">&quot;请输入姓名...&quot;</span>&gt;<br>&lt;datalist <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;nameList&quot;</span>&gt;<br>&lt;option&gt;&lt;/option&gt;<br>&lt;/datalist&gt;<br>&lt;/form&gt;<br>&lt;button <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;btn btn_form_search&quot;</span> data-toggle=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;bottom_search&quot;</span> <br>style=<span class="hljs-string">&quot;position:absolute; right:48px; z-index:10;outline: none;border-radius: 0 4px 4px 0;background-color: yellowgreen;&quot;</span> <br>onclick=<span class="hljs-string">&quot;buttonClick()&quot;</span>&gt;确定&lt;/button&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="搜索框样式"><a href="#搜索框样式" class="headerlink" title="搜索框样式"></a>搜索框样式</h2><p><img src="/img/posts_img/20201122193701509_16268.png"></p><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><p>监听汉字输入，当输入中文时，在输入阶段(即输入法拼音部分)不执行函数，在完成中文拼写并输入到 input 框中后执行绑定函数。<br>未完成输入时状态如下：<br><img src="/img/posts_img/20201122193911660_25674.png"><br>完成输入状态如下：<br><img src="/img/posts_img/20201122193934278_3961.png"></p><h2 id="jQuery-事件绑定失效原因"><a href="#jQuery-事件绑定失效原因" class="headerlink" title="jQuery 事件绑定失效原因"></a>jQuery 事件绑定失效原因</h2><p>JQuery事件绑定不生效，大概分两种情况。</p><ol><li><strong>绑定事件在未加载完成之前：</strong> DOM 元素在未加载完成之前，通过<code>$(&quot;...&quot;).on()</code>方法进行事件绑定，由于此时未加载完成(页面加载的异步性)，实际上<code>$(&quot;...&quot;)</code>是一个空数组，所以最终的结果是未对任何元素进行事件绑定。</li><li><strong>绑定事件后移除了元素重新加入：</strong> DOM 元素首先通过JQuery 的方法被创建出来，然后被加入到 body 中，然后绑定事件，之后从 body 中移除，然后在加入 body 中，此时点击也不会生效，这是因为，在从文档中移除的时候，JQuery 会自动把绑定的事件移除掉了，然后在加入的时候，事件绑定已经不存在了。</li></ol><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>针对<strong>在DOM元素未加载完成之前绑定事件导致绑定失效的问题</strong>，通常把事件绑定放在 DOM 元素加载完成之后即可，jQuery的做法是用<code>$(function()&#123;&#125;)</code>包裹事件绑定操作，例如上例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>    $(<span class="hljs-string">&#x27;#nameSearch&#x27;</span>).on(<span class="hljs-string">&#x27;compositionend&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span>=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">let</span> val = $(<span class="hljs-string">&#x27;#nameSearch&#x27;</span>).val();<br>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">Number</span>(val))</span>)</span>&#123;<br>            debounce(tooltips, <span class="hljs-number">2000</span>)();<br>        &#125;<br>    &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><p>针对<strong>绑定事件后移除元素后重新加入导致绑定失效的问题</strong>，一般来说考虑 delegate 的方式，这通常针对某些元素存在频繁的添加、移除、再添加的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-built_in">document</span>.body).delegate(<span class="hljs-string">&#x27;#button2&#x27;</span>,<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    alert(<span class="hljs-string">&quot;button2 clicked&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="关于-jQuery-的-function"><a href="#关于-jQuery-的-function" class="headerlink" title="关于 jQuery 的 $(function() {})"></a>关于 jQuery 的 $(function() {})</h2><p><code>$(function() &#123;&#125;)</code> 是<code>$(document).ready(function()&#123;&#125;)</code>的简写。<br>该函数在 DOM 元素加载完毕之后执行。</p><p><strong>什么是 DOM ？</strong><br>DOM 就是一个 html 页面的标签树:<br><img src="/img/posts_img/20201122195517212_4963.png"><br>当页面所有的 html 标签（包括图片等）都加载完了，即浏览器已经响应完了，DOM 即完成了加载操作。DOM 在第一次页面加载完毕后，就在内存里了，无论后面怎么局部修改 html 页面，都只是对内存中的 DOM 树进行修改，而 DOM在第一次页面加载后就已经加载完毕了。所以后面 js文件（动态加载或者 head 中加载）再使用到 <code>$(function() &#123;&#125;)</code> 函数肯定会执行的。</p>]]></content>
    
    
    <categories>
      
      <category>jQuery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Resnet 详解</title>
    <link href="/2020/11/20/ResNet/"/>
    <url>/2020/11/20/ResNet/</url>
    
    <content type="html"><![CDATA[<h1 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h1><p>参考链接：<br><a href="https://zhuanlan.zhihu.com/p/31852747">你必须要知道CNN模型：ResNet</a><br><a href="https://zhuanlan.zhihu.com/p/72589432">梯度消失和梯度爆炸及解决方法</a></p><hr><h2 id="深层网络的退化问题"><a href="#深层网络的退化问题" class="headerlink" title="深层网络的退化问题"></a>深层网络的退化问题</h2><ul><li><p>深层网络结构为什么会导致模型退化？<br>网络的深度对于模型特征提取至关重要，按理来说，不断堆叠网络层数，模型可以进行更加复杂的特征模式提取，因此模型深度越深，就能取得更好的结果。但事实上，当网络深度增加到一定程度后，网络准确度出现了饱和，甚至出现下降，即网络退化(Degradation problem)，网络退化的原因主要是由<strong>梯度消失</strong>或者<strong>梯度爆炸</strong>造成的。</p></li><li><p>什么是梯度消失？什么是梯度爆炸？<br>目前优化神经网络的方法都是根据损失函数计算的误差通过梯度反向传播的方式(即BP)，指导深度网络权值的更新优化。其中将误差从末层往前传递的过程需要<strong>链式法则</strong>（Chain Rule)， 而链式法则是一个<strong>连乘</strong>的形式，梯度将以指数形式传播。随着网络深度不断增加，在根据损失函数计算的误差通过梯度反向传播的方式对深度网络权值进行更新时，容易导致得到的梯度值接近0或特别大，也就是梯度消失或爆炸。反向传播即链式法则如下图所示，梯度值为学习率右侧的偏导求值，当导数部分小于1时，经过链式法则连乘不断放大，最终梯度值会接近于0，模型几乎不再更新，即梯度消失，若导数部分大于1，经过链式法则连乘，最终梯度值会越来越大，发生梯度爆炸。<br><img src="/img/posts_img/20201117113531949_7119.png">    <img src="/img/posts_img/20201117113716099_20642.png"></p></li><li><p>梯度消失/梯度爆炸解决方法<br>梯度消失和梯度爆炸问题都是因为网络太深，网络权值更新不稳定造成的，本质上是因为梯度反向传播中的连乘效应。解决梯度消失、爆炸主要有以下几种方法：</p></li></ul><ol><li>梯度剪切：主要是针对梯度爆炸，其思想是设置一个梯度剪切阈值，然后更新梯度的时候，如果梯度超过这个阈值，那么就将其强制限制在这个范围之内。这可以防止梯度爆炸。</li><li>权重正则化：通过对网络权重做正则来限制过拟合。如果发生梯度爆炸，那么权值就会变的非常大，反过来，通过正则化项来限制权重的大小，也可以在一定程度上防止梯度爆炸的发生。</li><li>选择ReLU代替Sigmoid作为激活函数：使用sigmoid作为损失函数，其梯度是不可能超过0.25的，这样经过链式求导之后，很容易发生梯度消失(即越乘越小)，同理，tanh作为损失函数，它的倒数仍然是小于1。relu函数的导数在正数部分是恒等于1的，因此在深层网络中使用relu激活函数就不会导致梯度消失和爆炸的问题。</li><li>batch normalization：通过对每一层的输出规范为均值和方差一致的方法，消除了权重参数放大缩小带来的影响，进而解决梯度消失和爆炸的问题，或者可以理解为BN将输出从饱和区拉倒了非饱和区。</li><li><strong>残差网络(ResNet)</strong></li><li>LSTM门结构</li></ol><h2 id="ResNet-1"><a href="#ResNet-1" class="headerlink" title="ResNet"></a>ResNet</h2><h3 id="恒等映射"><a href="#恒等映射" class="headerlink" title="恒等映射"></a>恒等映射</h3><p>假设现在存在一个浅层网络，为了获得更好地学习能力，你想通过向上堆积新层的方式来建立深层网络，一个极端情况是这些增加的层什么也不学习，仅仅复制浅层网络的特征，即这样新层是<strong>恒等映射（Identity mapping）</strong>。在这种情况下，深层网络应该至少和浅层网络性能一样，不应该出现退化现象，但是显然事实如刚才所说，存在梯度爆炸或梯度消失的现象，那么残差网络单元是如何解决这一问题的呢？</p><h3 id="残差单元"><a href="#残差单元" class="headerlink" title="残差单元"></a>残差单元</h3><p><img src="/img/posts_img/20201117115531507_1447.png"><br>如图为残差网络ResNet的一个残差学习单元<br>原先当输入为$x$时，其对应输出的特征为$H(x)$，而残差学习单元将学习的目标转化为了对残差$F(x)=H(x)-x$的学习，最终输出的仍是$H(x)$，只是输出从原有的$x$变为了$x+F(x)$。<br>为什么要这样做？之所以这样是因为<strong>残差学习相比原始特征直接学习更容易</strong>。当残差为0时，此时堆积层仅仅做了恒等映射(即$H(x)=x+0$)，至少网络性能不会下降，实际上残差不会为0，这也会使得堆积层在输入特征基础上学习到新的特征，从而拥有更好的性能。</p><h3 id="ResNet采用的两种残差单元"><a href="#ResNet采用的两种残差单元" class="headerlink" title="ResNet采用的两种残差单元"></a>ResNet采用的两种残差单元</h3><h4 id="浅层残差单元"><a href="#浅层残差单元" class="headerlink" title="浅层残差单元"></a>浅层残差单元</h4><p>对于短路连接，当输入和输出维度一致时，可以直接将输入加到输出上。但是当维度不一致时（对应的是维度增加一倍），这就不能直接相加。有两种策略：（1）采用zero-padding增加维度，此时一般要先做一个downsamp，可以采用strde=2的pooling，这样不会增加参数；（2）采用新的映射（projection shortcut），一般采用1x1的卷积，这样会增加参数，也会增加计算量。短路连接除了直接使用恒等映射，当然都可以采用projection shortcut。<br><img src="/img/posts_img/20201117120420866_906.png"><br>如图，输入维度为64维，内部经过2个3*3，深度为64的卷积核对残差进行学习，用relu激活函数(原因参照上面陈述)进行非线性激活。(可以理解为将外部$x$的学习转化为内部残差$F(x)$的学习)。</p><h4 id="深层残差单元"><a href="#深层残差单元" class="headerlink" title="深层残差单元"></a>深层残差单元</h4><p><img src="/img/posts_img/20201117120752930_11450.png"><br>如图，输入维度为256维，用 $1\times1$ 卷积核下采样，将深度降为64维，经过 $3\times3$ 卷积核对残差进行内部学习，再通过 $1\times1$ 卷积将维度还原到与输入维度一致，做相加操作。</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>最近看到一篇关于 ResNet 的知乎讲解很有意思，讲得非常透彻，特此安利一下：<a href="https://www.zhihu.com/question/64494691">Resnet到底在解决一个什么问题呢？</a><br>关于里面一些有趣的点，做一下总结：</p><ol><li>什么造成了模型退化？<br>模型<strong>退化现象</strong>：当神经网络的层数堆叠到一定程度时，模型的效果不升反降。<br>起初人们认为是模型过拟合导致的 (模型性能不佳，存在高偏差，导致欠拟合；模型复杂度过高，存在高方差，导致过拟合)，但是很明显当前CNN面临的效果退化不是因为过拟合，因为过拟合的现象是”高方差，低偏差”，即测试误差大而训练误差小。但实际上，深层CNN的训练误差和测试误差都很大。<br>那么是否与模型梯度爆炸/梯度消失有关？作者首先介绍了一些反向传播的知识，很通俗易懂，可以仔细研读一下(<a href="https://www.zhihu.com/question/64494691">Resnet到底在解决一个什么问题呢？</a>)。在反向传播中，其输出值的大小除了与求导式子有关外，很大程度上还取决于输入值的大小，当输入值大于1时，经过反向传播多层的回传，梯度将以几何倍数增长 (涉及了链式求导的知识)，这就造成了深度神经网络梯度爆炸的现象，同理当输入值小于1时，会造成梯度消失的现象。<br>好像是梯度爆炸/消失造成的，可事实真的如此吗？我们知道在 Resnet 前，人们处理梯度爆炸/消失时，通常用的是 Batch Normalization，理论上梯度爆炸/消失很早就被人们解决一大半了，为什么还是会导致模型退化呢？</li><li>模型退化不符合常理？<br>按理说，当我们堆叠一个模型时，理所当然的会认为效果会越堆越好。因为，假设一个比较浅的网络已经可以达到不错的效果，那么即使之后堆上去的网络什么也不做，模型的效果也不会变差。然而事实上，这却是问题所在。“什么都不做”恰好是当前神经网络最难做到的东西之一。不断堆叠神经网络层数，会导致神经网络在具有无限可能的“非线性”道路上越走越远，以至于模型走了很远后，忘记了它为什么要出发，拟合的目标是什么 (“不忘初心，牢记使命”诚不欺我)。因此，后续就有了 Resnet 的提出，其初衷就是让模型的内部结构至少有恒等映射的能力。以保证在堆叠网络的过程中，网络至少不会因为继续堆叠而产生退化！</li><li>Resnet 的恒等映射<br>让深层神经网络模型具备恒等映射 $H(x)=x$是一件看似简单，但难以解决的事，此处$x$表示输入，$H(x)$对应模型学习后的输出，在上述说到，模型总会尝试着输出一点新的东西，这就导致$H(x)$和$x$不会相等。但如果把网络设计为$H(x) = F(x) + x$，即直接把恒等映射作为网络的一部分，就可以把问题转化为学习一个残差函数$F(x) = H(x) - x$。因为只要$F(x)=0$，就构成了一个恒等映射$H(x) = x$。 而且，拟合残差至少比拟合恒等映射容易得多，该结构被称为 Residual Block。<br><img src="/img/posts_img/20201120154958055_11900.png"><br>图中右侧的曲线叫做跳接（shortcut connection），通过跳接在激活函数前，将上一层（或几层）之前的输出与本层计算的输出相加，将求和的结果输入到激活函数中做为本层的输出。数学公式表达如图所示：<br><img src="/img/posts_img/20201120155050630_28876.png"><br>其中 $F(x,{W_i})$ 是我们学习的目标，即输出输入的残差。以上图为例，残差部分是中间有一个Relu激活的双层权重，为什么一个 Block 中要用两层的权重来表示呢？因为只用一层权重，通过公式计算就会得到以下情况，结果就是加与不加残差块没有差别。<br><img src="/img/posts_img/20201120155336431_27734.png"></li><li>Resnet 在 VGG 上的变化，即网络结构和一些细节<br>图结构可见<a href="https://www.zhihu.com/question/64494691">Resnet到底在解决一个什么问题呢？</a><br>这里主要对空间维度不一致和深度不一致做一个解释。<br>空间维度不一致的解决方法：在跳接的部分给输入x加上一个线性映射，具体如图。<br><img src="/img/posts_img/20201120155659614_2741.png"><br>深度维度不一致的解决方法：一种是在跳接过程中加一个 $1\times1$ 的卷积层进行升维，另一种则是直接简单粗暴地补零。事实证明两种方法都行得通。通过 $1\times1$ 卷积升维的方式如图。该结构也被称为是 bottleneck，它通过使用1x1 conv来巧妙地缩减或扩张feature map维度从而使得我们的3x3 conv的filters数目不受外界即上一层输入的影响，除了改变深度维度外，它还节省了计算时间进而缩小整个模型训练所需的时间。<br><img src="/img/posts_img/20201120155831799_13135.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React小书学习笔记 —— 实战分析：评论功能(四)</title>
    <link href="/2020/11/18/%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%EF%BC%9A%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD(%E5%9B%9B)/"/>
    <url>/2020/11/18/%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%EF%BC%9A%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习前端一小步，迈向成功一大步！本专栏主要记录学习前端React框架的一些个人心得，分享一些实战教学，如有不足，欢迎交流讨论。React框架的入门教学强推<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a>的<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a>，简单易懂还有代码实战。还等什么？让我们开始本篇的前端学习之旅，欢迎各位入坑前端！</p><a id="more"></a><h1 id="实战分析：评论功能-四"><a href="#实战分析：评论功能-四" class="headerlink" title="实战分析：评论功能(四)"></a>实战分析：评论功能(四)</h1><p>参考教程：React小书–第25节(实战分析：评论功能(四)）<br>教程作者：<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a><br>参考链接：<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a><br><strong>本文搭配原文教程食用，风味更佳~!</strong></p><hr><h2 id="本篇重点"><a href="#本篇重点" class="headerlink" title="本篇重点"></a>本篇重点</h2><p>本篇是对 React 小书内代码实战过程中遇到的一些疑难点做的解释性帖子。因此不注重于代码的连贯性，代码按照 React 小书介绍排布，将针对具体细节做深入阐述。</p><h2 id="自动聚焦到评论框"><a href="#自动聚焦到评论框" class="headerlink" title="自动聚焦到评论框"></a>自动聚焦到评论框</h2><h3 id="React-小书代码"><a href="#React-小书代码" class="headerlink" title="React 小书代码"></a>React 小书代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>...<br>    &lt;textarea<br>      ref=&#123;<span class="hljs-function">(<span class="hljs-params">textarea</span>) =&gt;</span> &#123;<span class="hljs-built_in">this</span>.textarea = textarea&#125;&#125;<br>      value=&#123;<span class="hljs-built_in">this</span>.state.content&#125;<br>      onChange=&#123;<span class="hljs-built_in">this</span>.handleContentChange.bind(<span class="hljs-built_in">this</span>)&#125; /&gt;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  static propTypes = &#123;<br>    onSubmit: <span class="hljs-type">PropTypes</span>.func<br>  &#125;<br><br>  constructor () &#123;<br>    <span class="hljs-keyword">super</span>()<br>    <span class="hljs-keyword">this</span>.state = &#123;<br>      username: &#x27;&#x27;,<br>      content: &#x27;&#x27;<br>    &#125;<br>  &#125;<br><br>  componentDidMount () &#123;<br>    <span class="hljs-keyword">this</span>.textarea.focus()<br>  &#125;<br>...<br></code></pre></td></tr></table></figure><h3 id="侧重点"><a href="#侧重点" class="headerlink" title="侧重点"></a>侧重点</h3><ul><li>学会用 ref 属性调用 DOM 元素的 API</li><li>componentDidMount() 生命周期使用</li><li>PropTypes 限制输入参数类型</li><li><code>.focus()</code></li></ul><h3 id="代码编写思路"><a href="#代码编写思路" class="headerlink" title="代码编写思路"></a>代码编写思路</h3><ol><li>给标签添加 <code>ref</code> 属性值</li><li>在 <code>componentDidMount()</code> 中调用 <code>.focus()</code>，确保组件挂载完成后聚焦光标到组件。</li></ol><h3 id="实战填坑"><a href="#实战填坑" class="headerlink" title="实战填坑"></a>实战填坑</h3><ol><li>在 <code>&lt;textarea ref=&#123;(textarea)=&gt;&#123;this.textarea=textarea&#125;&#125; value=&#123;this.state.content&#125; onChange=&#123;this.handleContentChange.bind(this)&#125; /&gt;</code> 中，<code>this</code>指的是什么？<code>ref</code>传的形参是什么？<code>(textarea)</code>可以变为其他值吗，比如<code>(aaa)=&gt;&#123;this.textarea=aaa&#125;</code>？<code>onChange</code>监听函数是什么？</li></ol><ul><li><strong><code>this</code>指的是什么？</strong> 请参考<a href="https://www.zhihu.com/question/353757734/answer/964557747">JavaScript 的 this 原理是什么？</a>仔细研读，此处不知道理解的对不对，暂且记录一下：首先<code>this</code>是在箭头函数里的，箭头函数的this取决于它的上级调用对象，其上级为<code>render()</code>的函数调用，而<code>render()</code>调用的主体是 <code>class CommentInput</code> 类，因此，<code>this</code> 指向的是该类，即 <code>CommentInput</code> 组件，因此<code>this.state; this.textarea</code>就都很好解释了，其实就是组件类下的一些属性。</li><li><strong><code>ref</code>传的形参是什么？</strong> <code>ref</code>传入的是该属性所对应标签对象的 DOM 元素，这里指的是 textarea 输入框。</li><li><strong><code>(textarea)</code>可以变为其他值吗，比如<code>(aaa)=&gt;&#123;this.textarea=aaa&#125;</code>？</strong> 可以，<code>()</code>内的 textarea 只是一个形参名称，其实际值为 textarea 的 DOM 节点。</li><li><strong><code>onChange</code>监听函数是什么？</strong> 简要了解可参考<a href="https://zhuanlan.zhihu.com/p/149353182">JavaScript 中常见HTML事件</a>，<code>onChange</code>事件监听一个域的内容是否发生改变，在改变时触发绑定的函数，即触发<code>handleContentChange()</code>。在此重点讲一下 <code>event</code>对象和事件监听的关系，参考<a href="https://www.w3school.com.cn/jsref/dom_obj_event.asp">HTML DOM Event 对象</a>，以下是我当前的理解：event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。但是我们如何去用这些状态呢？这就要靠 <code>onClick</code>,<code>onChange</code>等事件句柄监听 event 对象状态，在状态发生相应变化是触发绑定的函数，那么显而易见，所触发的函数必然接收了该事件的状态，即 event 对象，每个事件监听函数都会有一个形参 event (例如<code>handleClick(event)</code>)，注意我们提及 event 它是一个对象，对象则必然有它对应的属性，结合<a href="https://www.w3school.com.cn/jsref/dom_obj_event.asp">HTML DOM Event 对象</a>，可查到 event 对象对应的属性值，其中 <code>event.target</code>,<code>event.currentTarget</code>目前我用的比较多。</li></ul><ol start="2"><li><code>propTypes</code>的使用。<br>大小写很容易搞混，这里要重点关注一下，按照规范来写。</li></ol><ul><li>首先是<code>prop-types</code>的引入，代码为<code>import PropTypes from &#39;prop-types&#39;</code></li><li>其次是静态对象声明，因为是一个变量，所以用驼峰命名法，代码为<code>static propTypes = &#123;&#125;</code></li><li>内部是对参数的类型限制，调用<code>PropTypes</code>，因为<code>PropTypes</code>是<code>&#39;prop-types&#39;</code>中的一个类，所以开头是大写的，后面跟类型属性。</li></ul><ol start="3"><li><code>.foucus()</code>作用<br>focus() 方法用于为 checkbox 赋予焦点。语法<code>checkboxObject.focus()</code>。<br>拓展：移开 checkbox 的焦点用 blur() 方法，语法<code>checkboxObject.blur()</code></li></ol><h2 id="持久化用户名"><a href="#持久化用户名" class="headerlink" title="持久化用户名"></a>持久化用户名</h2><h3 id="React-小书代码-1"><a href="#React-小书代码-1" class="headerlink" title="React 小书代码"></a>React 小书代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">...<br>    &lt;input<br>      value=&#123;<span class="hljs-keyword">this</span>.state.username&#125;<br>      onBlur=&#123;<span class="hljs-keyword">this</span>.handleUsernameBlur.bind(<span class="hljs-keyword">this</span>)&#125;<br>      onChange=&#123;<span class="hljs-keyword">this</span>.handleUsernameChange.bind(<span class="hljs-keyword">this</span>)&#125; /&gt;<br>...<br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  constructor () &#123;<br>    <span class="hljs-keyword">super</span>()<br>    <span class="hljs-keyword">this</span>.state = &#123;<br>      username: &#x27;&#x27;,<br>      content: &#x27;&#x27;<br>    &#125;<br>  &#125;<br><br>  componentDidMount () &#123;<br>    <span class="hljs-keyword">this</span>.textarea.focus()<br>  &#125;<br><br>  _saveUsername (username) &#123;<br>    localStorage.setItem(<span class="hljs-symbol">&#x27;usernam</span>e&#x27;, username)<br>  &#125;<br><br>  handleUsernameBlur (event) &#123;<br>    <span class="hljs-keyword">this</span>._saveUsername(event.target.value)<br>  &#125;<br>...<br></code></pre></td></tr></table></figure><h3 id="侧重点-1"><a href="#侧重点-1" class="headerlink" title="侧重点"></a>侧重点</h3><ul><li>LocalStorage浏览器本地存储的使用</li><li>onBlur() 事件监听句柄</li><li>handlexxx 事件监听函数</li><li>componentWillMount() 生命周期</li></ul><h3 id="代码编写思路-1"><a href="#代码编写思路-1" class="headerlink" title="代码编写思路"></a>代码编写思路</h3><ol><li>通过<code>onBlur()</code>事件句柄绑定一个监听函数<code>handleUsernameChange</code>，当event事件状态失焦时，触发监听函数。</li><li>编写监听函数<code>handleUsernameChange</code>，接收事件状态 (即 event 对象)，通过对象属性获取触发事件的目标节点，这里应该指向了<code>&lt;textarea /&gt;</code>，因此通过<code>.value</code>将文本框内值取出，传给私有函数。</li><li>编写私有函数，通过<code>localStorage.setItem(&#39;key&#39;,value)</code>将值存入浏览器本地空间。</li></ol><h3 id="实战填坑-1"><a href="#实战填坑-1" class="headerlink" title="实战填坑"></a>实战填坑</h3><ol><li><p><code>onBlur()</code>是什么？<code>event</code>是什么？<br>参照“自动聚焦到评论框”实战填坑的第一问。</p></li><li><p><code>localStorage</code>的作用和使用方法。<br>参照<a href="https://blog.csdn.net/weixin_41997724/article/details/84560612">localStorage使用</a>。<br>localStorage 作用：<strong>前提-在HTML5中实现。</strong> 主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。</p><blockquote><p>localStorage 优势：<br>拓展了cookie的4K限制；<br>可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的；<br>localStorage与sessionStorage的唯一一点区别就是localStorage属于永久性存储，而sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空；</p></blockquote></li></ol><p><strong>localStorage 两种使用：</strong></p><ul><li><code>localStorage.getItem(&#39;key&#39;)</code>:获取指定<strong>key字段</strong>本地存储的值。 注意，我这里特别强调了字段，即接收的 key 参数是个字符，需要<code>&#39; &#39;</code>包裹。</li><li><code>localStorage.setItem(&#39;key&#39;,value)</code>：将value存储到key字段。 同理，这里key也是字符，value是数据。</li></ul><p><code>.getItem()</code>方法主要是从浏览器本地存储中获取相应 key 的值 value。<br><code>.setItem()</code>方法主要是将值存储到本地存储中的指定 key 字段中，若没有 key 则由本地存储创建一个空的 key。</p><p>localStorage 使用实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">在A页面中先存储：<br><span class="hljs-keyword">var</span> imgs = obj_mainform.archivesId  <span class="hljs-comment">//声明个变量存储下数据</span><br><span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;key&#x27;</span>,imgs);  <span class="hljs-comment">//将变量imgs存储到name字段</span><br><br>在B页面中使用：<br><span class="hljs-keyword">var</span> naid = <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&quot;key&quot;</span>); <span class="hljs-comment">//获取指定key本地存储的值</span><br></code></pre></td></tr></table></figure><ol start="3"><li><code>handleUsernameBlur (event) &#123;this._saveUsername(event.target.value)&#125;</code>中，为什么要用<code>this</code>调用类中的私有方法？<br>首先，我们需要知道的一点是，对于这个函数来说，我将 <code>this.</code> 去掉对整个过程没有任何的影响。那我们为什么还要去“多此一举”加入<code>this</code>呢？这就涉及到了 JS 的编程思想，原先 JS 语言提出的过程中，主要是面向函数的，即函数内调用函数，内部函数是通过向上查找发现的，随着 ES6 的提出，JS 的编程思想逐渐从面向函数向<strong>面向对象</strong>转变，此处的<code>this</code>即指向了类这个对象(JS 类的概念是在ES6中提出的)。所以我们在理解的时候可以认为：<strong>类内部函数的调用需要用<code>this</code>是目前一个通用的写法。</strong><br>我们理解了上述的思想后，再回过头来看这段代码：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;input<br>      value=&#123;<span class="hljs-keyword">this</span>.state.username&#125;<br>      onBlur=&#123;<span class="hljs-keyword">this</span>.handleUsernameBlur.bind(<span class="hljs-keyword">this</span>)&#125;/&gt;<br></code></pre></td></tr></table></figure>第二行，<code>this.handleUsernameBlur</code>是类内函数调用的一个通用写法，所以 <code>this</code> 指的就是类(准确来说是类的实例)，那有人就问，既然都指向类了，为什么还要<code>.bind(this)</code>呢？前面提到的<code>this.xxx</code>是类内调用函数的通用写法，虽然函数写在了类内，但它并没有与类进行一个绑定，当触发该事件监听函数时，是在全局环境下运行<code>handleUsernameBlur()</code>，即 windows 对象调用的该函数，this 就指向了 windows，为了让类内函数在触发时指向类，就需要对它做一个绑定。<br>都谈到这了，那么就说一下第一行的<code>this</code>的指向，<code>this</code> 永远指向<strong>调用</strong>包含自身（this本身）的<strong>函数</strong>对应的<strong>对象</strong>。那么是什么函数调用了<code>this.state.username</code>呢？答案是<code>render()</code>，或者可以理解为是<code>CommentInput.render()</code>，那么显而易见这个对象，也就是this所指向的是 CommentInput。</li></ol>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React小书学习笔记 —— PropTypes 和组件参数验证</title>
    <link href="/2020/11/17/PropTypes%20%E5%92%8C%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81/"/>
    <url>/2020/11/17/PropTypes%20%E5%92%8C%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习前端一小步，迈向成功一大步！本专栏主要记录学习前端React框架的一些个人心得，分享一些实战教学，如有不足，欢迎交流讨论。React框架的入门教学强推<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a>的<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a>，简单易懂还有代码实战。还等什么？让我们开始本篇的前端学习之旅，欢迎各位入坑前端！</p><a id="more"></a><h1 id="PropTypes-和组件参数验证"><a href="#PropTypes-和组件参数验证" class="headerlink" title="PropTypes 和组件参数验证"></a>PropTypes 和组件参数验证</h1><p>参考教程：React小书–第24节(PropTypes 和组件参数验证）<br>教程作者：<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a><br>参考链接：<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a><br><strong>本文搭配原文教程食用，风味更佳~!</strong></p><hr><h2 id="为什么需要-React-第三方库-prop-types"><a href="#为什么需要-React-第三方库-prop-types" class="headerlink" title="为什么需要 React 第三方库: prop-types"></a>为什么需要 React 第三方库: prop-types</h2><p>JavaScript 的灵活性体现在弱类型、高阶函数等语言特性上。而语言的弱类型一般来说确实让我们写代码很爽，但是也很容易出 bug。<br>JS 语言在声明变量的时候统一用的是 <strong>let（先前是 var）</strong>，这就意味着<strong>变量是没有固定类型且可以随意赋值的</strong>，假如我起初声明了一个变量<code>let a=&#123;&#125;</code>，显然 a 是一个对象，但是在工程项目的某处对该共享的对象变量做了改变，如<code>a=4</code>，那么 <code>a</code> 变量就变成了一个 Number 类型(此处可以看到，共享变量可以通过赋值改变其类型，即应证了上述变量没有固定类型且随意赋值这句话)，此时再使用 <code>a.xxx</code> 就会报错，但 debug 的时候不会明确告诉你是这里出错了。</p><h2 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h2><p>React.js 提供了一种机制，实现<strong>给组件的配置参数加上类型验证</strong>。<br><strong>步骤：</strong></p><ol><li>安装第三方库 <strong>prop-types</strong>:  <code>npm install --save prop-types</code></li><li>头文件引入 <strong>PropTypes</strong>: <code>import PropTypes from &#39;prop-types&#39;</code></li><li>在组件中添加类属性 <strong>propTypes</strong>, 属性值接收一个对象：<code>statics propTypes = &#123;xx: yyy&#125;</code></li><li>对象键值对写为：<code>xxx:PropTypes.yyy</code> ，其中 yyy 为变量类型(object, number,…)</li><li>通过 isRequired 关键字强制组件某个参数传值，如<code>xxx:PropTypes.object.isRequired</code></li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> propTypes = &#123;<br>    comment: PropTypes.object<br>    num: PropTypes.number.isRequired<br>  &#125;<br><br>  render () &#123;<br>    <span class="hljs-keyword">const</span> &#123; comment &#125; = <span class="hljs-built_in">this</span>.props<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div className=<span class="hljs-string">&#x27;comment&#x27;</span>&gt;<br>        &lt;div className=<span class="hljs-string">&#x27;comment-user&#x27;</span>&gt;<br>          &lt;span&gt;&#123;comment.username&#125; &lt;/span&gt;：<br>        &lt;/div&gt;<br>        &lt;p&gt;&#123;comment.content&#125;&lt;/p&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>组件参数验证在构建大型的组件库的时候相当有用。</p><ol><li>可以帮助我们迅速定位这种类型错误，让我们组件开发更加规范。</li><li>起到了一个说明文档的作用，在使用组件的时候，只要看到组件的 propTypes 就清晰地知道这个组件到底能够接受什么参数，什么参数是可选的，什么参数是必选的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React小书学习笔记 —— style 属性</title>
    <link href="/2020/11/17/style%E5%B1%9E%E6%80%A7/"/>
    <url>/2020/11/17/style%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习前端一小步，迈向成功一大步！本专栏主要记录学习前端React框架的一些个人心得，分享一些实战教学，如有不足，欢迎交流讨论。React框架的入门教学强推<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a>的<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a>，简单易懂还有代码实战。还等什么？让我们开始本篇的前端学习之旅，欢迎各位入坑前端！</p><a id="more"></a><h1 id="style-属性"><a href="#style-属性" class="headerlink" title="style 属性"></a>style 属性</h1><p>参考教程：React小书–第23节(dangerouslySetHTML 和 style 属性）<br>教程作者：<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a><br>参考链接：<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a><br><strong>本文搭配原文教程食用，风味更佳~!</strong></p><hr><p>dangerouslySetHTML 主要是防止跨站脚本攻击(XSS)，这个属性不必要的情况就不要使用。所以此处不再赘述，有需要可以在小书中学习。</p><ul><li><p>HTML 中的 style 属性<br><code>&lt;h1 style=&#39;font-size: 12px; color: red;&#39;&gt;React.js 小书&lt;/h1&gt;</code></p></li><li><p>React.js 中的 style 属性<br><code>&lt;h1 style=&#123;&#123;fontSize: '12px', color: 'red'&#125;&#125;&gt;React.js 小书&lt;/h1&gt;</code></p></li></ul><p>对比可看到，React.js 中需要把 CSS 属性变成一个对象，再传给标签元素。此外，<code>font-size</code>等 HTML 中 <code>-</code> 的表示需要替换为驼峰命名法 <code>fontSize</code>。</p><p><strong>总结：</strong></p><ol><li>style 属性接收一个对象，对象为原 CSS 属性的样式</li><li>样式名采用驼峰命名法</li></ol><hr><p>为什么要采用对象的方法传递样式参数？<br>答：用对象作为 style 方<strong>便动态设置元素的样式</strong>。我们可以用 <code>props</code> 或者 <code>state</code> 中的数据生成样式对象再传给元素，然后用 <code>setState</code> 就可以修改样式，非常灵活，例如 <code>&lt;h1 style=&#123;&#123;fontSize: '12px', color: this.state.color&#125;&#125;&gt;React.js 小书&lt;/h1&gt;</code>，此处我只需修改 <code>setState(&#123;color:blue&#125;)</code> 即可更改样式颜色为蓝色。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React小书学习笔记 —— props.children 和容器类组件</title>
    <link href="/2020/11/17/props.children%20%E5%92%8C%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/11/17/props.children%20%E5%92%8C%E5%AE%B9%E5%99%A8%E7%B1%BB%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习前端一小步，迈向成功一大步！本专栏主要记录学习前端React框架的一些个人心得，分享一些实战教学，如有不足，欢迎交流讨论。React框架的入门教学强推<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a>的<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a>，简单易懂还有代码实战。还等什么？让我们开始本篇的前端学习之旅，欢迎各位入坑前端！</p><a id="more"></a><h1 id="props-children-和容器类组件"><a href="#props-children-和容器类组件" class="headerlink" title="props.children 和容器类组件"></a>props.children 和容器类组件</h1><p>参考教程：React小书–第22节(props.children 和容器类组件）<br>教程作者：<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a><br>参考链接：<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a><br><strong>本文搭配原文教程食用，风味更佳~!</strong></p><hr><h2 id="容器类组件"><a href="#容器类组件" class="headerlink" title="容器类组件"></a>容器类组件</h2><p>容器类组件是一种功能性组件，其充当了容器的作用，它定义了一种外层结构形式，允许开发者往容器里添加任意的内容。<br>首先，我们介绍未使用 <code>props.children</code> 的容器组件，通过代码了解它存在什么问题以及 <code>props.children</code> 的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  render () &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div className=<span class="hljs-string">&#x27;card&#x27;</span>&gt;<br>        &lt;div className=<span class="hljs-string">&#x27;card-content&#x27;</span>&gt;<br>          &#123;<span class="hljs-built_in">this</span>.props.content&#125;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<br>  &lt;Card content=&#123;<br>    &lt;div&gt;<br>      &lt;h2&gt;React.js 小书&lt;/h2&gt;<br>       &lt;div&gt;开源、免费、专业、简单&lt;/div&gt;<br>      订阅：&lt;input /&gt;<br>    &lt;/div&gt;<br>  &#125; /&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><p>Card 是我们定义的容器类组件，其内部结构为<code>&lt;div ...&gt;&lt;div className=&#39;card-content&#39;&gt;...&lt;/ div&gt;&lt;/ div&gt;</code>，即用块状元素定义了一个容器，卡片内容通过 <code>this.props</code> 从外部接收，即实现让开发者自定义添加容器内容的效果。<br>在<code>ReactDOM.render()</code>渲染过程中，我们传入 props 参数，其为一个 JSX 元素(<code>&#123;&lt;div&gt;...&lt;/ div&gt;&#125;</code>)(是否还记得，之前提及 JSX 元素内部用<code>&#123;&#125;</code>包裹可以接收另一个 JSX 元素)，然后 Card 内部会通过 <code>this.props.content</code> 将内容渲染到页面上。</p><ul><li> <strong>存在的问题：</strong> 如果 Card 除了 content 以外还能传入其他属性的话，那么这些 JSX 和其他属性就会混在一起，很不好维护，如下，不仔细看我都不知道还有个<code>onClick</code>属性：<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim">&lt;<span class="hljs-type">Card</span> content=&#123;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<br>        ...<br>    &lt;/ <span class="hljs-keyword">div</span>&gt;<br>&#125;, onClick=<span class="hljs-meta">&#123;...&#125;</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><hr><p>我们希望改变这种写法，让组件接收的 JSX 元素独立作为一部分，但又与当前组件相关联，于是乎 React.js 提供了 <code>props.children</code> 写法</p><h2 id="props-children"><a href="#props-children" class="headerlink" title="props.children"></a>props.children</h2><p><code>props.children</code>使得组件标签也能像普通的 HTML 标签那样编写内嵌的结构，具体使用方法如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  render () &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div className=<span class="hljs-string">&#x27;card&#x27;</span>&gt;<br>        &lt;div className=<span class="hljs-string">&#x27;card-content&#x27;</span>&gt;<br>          &#123;<span class="hljs-built_in">this</span>.props.children&#125;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<br>  &lt;Card&gt;<br>    &lt;h2&gt;React.js 小书&lt;/h2&gt;<br>    &lt;div&gt;开源、免费、专业、简单&lt;/div&gt;<br>    订阅：&lt;input /&gt;<br>  &lt;/Card&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><p>先看 <code>ReactDOM.render()</code> 实现了什么：<br>可以看到，相比于原先将容器类组件的内容通过 <code>props</code> 参数传入 JSX 元素的方法，该种方法<strong>直接将内容作为一个HTML内嵌结构编写，将组件参数与内嵌结构分开写</strong>，而<code>&lt;card&gt;&lt;/ card&gt;</code>容器组件标签则起到了和<code>&lt;div&gt;&lt;/ div&gt;</code>类似的作用。<br>所有容器类组件内部嵌套的 JSX 结构都通过组件内的 <code>props.children</code> 来获取，即上例中的<code>this.props.children</code>。</p><h3 id="内部实现原理"><a href="#内部实现原理" class="headerlink" title="内部实现原理"></a>内部实现原理</h3><p>我们将 <code>props.children</code> 打印出来，可以发现，其包含的其实是个数组，<strong>React.js 就是把我们嵌套的 JSX 元素一个个都放到数组当中，然后通过 props.children 传给了 Card。</strong><br><img src="/img/posts_img/20201117195904513_10716.png"><br><strong>由于 JSX 会把插入表达式里面数组中的 JSX 一个个罗列下来显示。</strong> 所以其实就相当于在 Card 中嵌套了 JSX 结构，都会显示在 Card 的类名为 card-content 的 div 元素当中。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>按照这种HTML内嵌式的编写方法：</p><ol><li>结构清晰，将内嵌 JSX 结构与组件标签参数分离。</li><li><code>props.children</code> 将内嵌 JSX 结构变成数组的机制，使得我们在编写组件时十分灵活，我们可以选择数组中某些 JSX 元素(而非全部选择，例如<code>this.props.children[1]</code>)，然后将其安置在不同的位置。使我们能够选择内套元素，并进行高度复用。</li><li>大型 React.js 项目在编写容器型组件时非常常用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React小书学习笔记 —— ref 和 React.js 中的 DOM 操作</title>
    <link href="/2020/11/16/ref%20%E5%92%8C%20React.js%20%E4%B8%AD%E7%9A%84%20DOM%20%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/11/16/ref%20%E5%92%8C%20React.js%20%E4%B8%AD%E7%9A%84%20DOM%20%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习前端一小步，迈向成功一大步！本专栏主要记录学习前端React框架的一些个人心得，分享一些实战教学，如有不足，欢迎交流讨论。React框架的入门教学强推<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a>的<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a>，简单易懂还有代码实战。还等什么？让我们开始本篇的前端学习之旅，欢迎各位入坑前端！</p><a id="more"></a><h1 id="ref-和-React-js-中的-DOM-操作"><a href="#ref-和-React-js-中的-DOM-操作" class="headerlink" title="ref 和 React.js 中的 DOM 操作"></a>ref 和 React.js 中的 DOM 操作</h1><p>参考教程：React小书–第21节(ref 和 React.js 中的 DOM 操作）<br>教程作者：<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a><br>参考链接：<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a><br><strong>本文搭配原文教程食用，风味更佳~!</strong></p><hr><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>React.js 提供了一系列的 on* 方法 (例如<code>onClick()</code>等) 帮助我们进行事件监听，所以 React.js 当中不需要直接调用 <code>addEventListener</code> 的 DOM API，因此避免了大量与DOM元素交互的操作。但是，React.js 仍然提供了调用 DOM API 的一些方法，以方便人们对 DOM 元素进行一些自定义的操作。<br>React.js 提供了<strong>ref 属性</strong>来帮助我们<strong>获取已挂载元素的 DOM 节点</strong>，你可以给某个 <strong>JSX 元素加上 ref属性</strong>。</p><blockquote><p>JSX元素：在JavaScript语言内部编写的HTML标签结构，本质上是JS对象。JSX内部(即形如HTML标签结构内部)可以插入任何JS语法(这是成立的，因为JSX就是个JS对象，接受JS语法)，包括变量，表达式计算，函数以及 JSX 元素等，前提是要用<code>&#123;&#125;</code>包裹。JSX元素经过编译和构造，在React中转为JavaScript对象(为什么需要先转为JS对象？因为获得JS对象后可以进行更多的操作，例如react-canvas等，不一定要转为DOM元素)，再经过ReactDOM.render()即可转为真正的DOM元素。</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoFocusInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  componentDidMount () &#123;<br>    <span class="hljs-keyword">this</span>.input.focus()<br>  &#125;<br><br>  render () &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;input ref=&#123;(input) =&gt; <span class="hljs-keyword">this</span>.input = input&#125; /&gt;<br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-type">ReactDOM</span>.render(<br>  &lt;<span class="hljs-type">AutoFocusInput</span> /&gt;,<br>  document.getElementById(<span class="hljs-symbol">&#x27;roo</span>t&#x27;)<br>)<br></code></pre></td></tr></table></figure><p>ref <strong>属性</strong><br>作用：获取<strong>已挂载</strong>元素的 DOM 节点<br>添加位置：同JSX元素属性设置，即<code>&lt;input ref=&#123;...&#125;&gt;</code><br>属性值：ref 属性<strong>接收一个函数</strong>，当 JSX 元素在页面上挂载完成以后，React.js 就会调用 JSX元素内部 ref 属性定义的函数，并且把这个挂载以后的 DOM 节点传给这个函数(在实例中为<code>(input)中的input</code>，input 可以换成任意名称，因为这仅仅代表一个形参)。</p><p>在上述实例中，DOM 节点在 JSX元素挂载完成后被传给了<code>this.input</code>，这样我们就可以通过 this.input 获取到这个 DOM 元素。然后我们就可以在 componentDidMount 中使用这个 DOM 元素，并且调用 this.input.focus() 的 DOM API。整体就达到了页面加载完成就自动 focus 到输入框的功能。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>React.js 支持给任意代表 <strong>HTML 元素标签以及组件标签</strong>加上 ref 从而<strong>获取到它 DOM 元素然后调用 DOM API</strong>。但是记住一个原则：<strong>能不用 ref 就不用</strong>。特别是要避免用 ref 来做 React.js 本来就可以帮助你做到的页面自动更新的操作和事件监听。多余的 DOM 操作其实是代码里面的“噪音”，不利于我们理解和维护。</li><li>组件标签中添加 ref 属性，属性值函数获取的形参值为组件标签在 React.js 内部初始化的实例(即通过 constructor 定义的最初始组件渲染后的实例)，这并不是什么常用的做法，而且也并不建议这么做。</li></ol>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React小书学习笔记 —— 挂载阶段的组件生命周期（二）</title>
    <link href="/2020/11/10/%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5%E7%9A%84%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/11/10/%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5%E7%9A%84%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习前端一小步，迈向成功一大步！本专栏主要记录学习前端React框架的一些个人心得，分享一些实战教学，如有不足，欢迎交流讨论。React框架的入门教学强推<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a>的<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a>，简单易懂还有代码实战。还等什么？让我们开始本篇的前端学习之旅，欢迎各位入坑前端！</p><a id="more"></a><h1 id="挂载阶段的组件生命周期（二）"><a href="#挂载阶段的组件生命周期（二）" class="headerlink" title="挂载阶段的组件生命周期（二）"></a>挂载阶段的组件生命周期（二）</h1><p>参考教程：React小书–第18节(挂载阶段的组件生命周期(二)）<br>教程作者：<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a><br>参考链接：<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a><br><strong>本文搭配原文教程食用，风味更佳~!</strong></p><hr><p>经过上一节的讲述，你大概已经知道挂载阶段组件各生命周期有哪些，包括其排布的方式，调用的顺序等等，这节我们将接下来将讨论对于一个组件来说，其挂载阶段生命周期的几个方法(constructor ; componentWillMount; componentDidMount; componentWillUnmount)在一个组件的出生到死亡的过程里面起了什么样的作用。</p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a>constructor()</h2><p>一般来说， constructor 里主要做一些<strong>关于组件自身状态的初始化工作</strong>。即所有组件的 state 的初始化工作都是放在 constructor 里面的，具体代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxx</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    constructor() &#123;<br>        <span class="hljs-keyword">super</span>()<br>        <span class="hljs-keyword">this</span>.state = &#123;<br>            xx:yy,<br>            xx:yy,<br>            ...<br>        &#125;<br>    &#125;<br>    <br>    ...<br><br>    render() &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h2><p>小书中提到，componentWillMount 生命周期主要用于一些组件启动的动作，比如Ajax 数据的拉取操作、一些定时器的启动等，此外，书中还举了一个Ajax的例子：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">...<br>  componentWillMount () &#123;<br>    ajax.get(<span class="hljs-string">&#x27;http://json-api.com/user&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(userData)</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.setState(&#123; userData &#125;)<br>    &#125;)<br>  &#125;<br>...<br></code></pre></td></tr></table></figure><p><strong>但是！问题来了：</strong> 上一节我们不是说componentWillMount是在render前执行，无法触发setState的二次渲染吗？那这例子又是什么例子呢？对此，这里引出另一篇参考文献(<a href="https://segmentfault.com/a/1190000018082225">React componentwillmount和componentdidmount请求数据</a>)来深入了解一下。<br>首先要明确一点，<strong>在componentWillMount中执行this.setState是不会触发二次渲染的。</strong> 它也只会在挂载过程中被调用一次，它的作用和constructor没有太大差异。<br>在componentWillMount中请求后台数据是无法保证更早得到数据的，因为componentWillMout是在render函数执行前执行的，虽然请求是在第一次render之前发送的，但是返回并不能保证在render之前完成(即按照js异步的特点，在请求数据时，render已经开始异步工作了)，render不会等你慢慢请求.所以在渲染的时候没有办法等到数据到来再去setState触发二次渲染。<br>那为什么小书中说可以用 componentWillMount 进行 Ajax 数据拉取的操作呢？这是因为在服务端渲染的场景中componentDidMount是不会被执行的，因此可以在componnetWillMount中发送AJAX请求，注意这里是发送请求，而非发送并接收到请求，举个例子：你尝试过自己给自己送信吗？如果你要自己给自己送信会怎么办？方法很简单，你写一封信从浙江寄到武汉，寄完马上乘动车从浙江出发，到达武汉后等着这封信送到你手中就可以了，当然这封信可能会比你早到，那么你去邮局取件完事。componentWillMount 和 render 的关系也是如此，componentWillMount 先发送请求，然后程序就开始执行 render，至于请求怎么处理的和 render 执行不存在冲突，render 完成后等待请求结果或者获取结果即可。<br>顺便说一句在es6中,使用extend component的方式里的constructor函数和componentWillMount是通用的作用,所以你在构造函数里初始化了组件的状态就不必在WillMount做重复的事情了.React中不推荐在componentWillMount中发送异步请求。</p><p>以下是对该片引文的重点提取。</p><ol><li>componentWillMount 是一个同步操作，即你只有进行了 componentWillMount 才能进行后续的 render 等一系列操作。</li><li>componentWillMount 在 render 前执行，所以 componentWillMount 中执行 this.setState 无法触发二次渲染(此时组件自身都没被渲染)。</li><li>componentWillMount 可以执行一些不依赖于组件渲染的操作，比如定时器启动，请求发送等。</li></ol><p>引文还将 componentWillMount 和 componentDidMount 做了对比，相比于 componentWillMount ，componentDidMount 这个生命周期函数在是在render之后调用一次,component已经初始化完成了。在生产时,componentDidMount生命周期函数是最好的时间去请求数据,其中最重要原因:使用componentDidMount第一个好处就是这个一定是在组件初始化完成之后,再会请求数据,因此不会报什么警告或者错误,我们正常请教数据完成之后一般都会setState。</p><h2 id="componentWillUnmout"><a href="#componentWillUnmout" class="headerlink" title="componentWillUnmout()"></a>componentWillUnmout()</h2><p>componentWillUnmount 生命周期主要在组件销毁前(注意是销毁前，可以看前一篇，是先执行 componentWillUnmout，后在页面删除组件)，执行一些清场工作，比如清楚定时器等。在 React 中，组件生命周期是 js 自己控制的，父组件不要子组件了，那么子组件就可以卸载了，就这么简单。React 管理 DOM 的过程，可以理解为每个组件 render() 返回的虚拟 DOM 会被 React 整理到一个树里面，按照它们之间相互依赖的关系，把相应的组件 mount 起来。然后可能父组件状态变化之后， render() 不返回某个子组件了，那么这个子组件就会被 React unmount 掉。</p><h2 id="动态时钟实战"><a href="#动态时钟实战" class="headerlink" title="动态时钟实战"></a>动态时钟实战</h2><p>下面记录了不堪入目的代码实战过程：</p><h3 id="step1：创建React"><a href="#step1：创建React" class="headerlink" title="step1：创建React"></a>step1：创建React</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">npx </span><span class="hljs-built_in">create-react-app</span> <span class="hljs-string">clock</span><br><span class="hljs-string">cd </span><span class="hljs-string">clock</span><br></code></pre></td></tr></table></figure><h3 id="step2：定义时钟组件"><a href="#step2：定义时钟组件" class="headerlink" title="step2：定义时钟组件"></a>step2：定义时钟组件</h3><p>创建 Clock.js <strong>(注意大写，语法规范：导出类名的文件开头首字母大写)</strong><br>编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Clock.js代码：<br><span class="hljs-keyword">import</span> React,&#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>()<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        &lt;div&gt;<br>            &lt;h1&gt;<br>                &lt;p&gt;现在时间是&lt;/p&gt;<br>                &#123;<span class="hljs-built_in">this</span>.state.date.toLocaleTimeString()&#125;<br>            &lt;/h1&gt;<br>        &lt;/div&gt;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Clock;<br>--------------------------------------------------------------<br>index.js代码：<br><span class="hljs-keyword">import</span> reportWebVitals <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reportWebVitals&#x27;</span>;<br><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> Clock <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Clock&#x27;</span>;<br><br>ReactDOM.render(<br>  &lt;React.StrictMode&gt;<br>    &lt;Clock /&gt;<br>  &lt;/React.StrictMode&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br><br><span class="hljs-comment">// If you want to start measuring performance in your app, pass a function</span><br><span class="hljs-comment">// to log results (for example: reportWebVitals(console.log))</span><br><span class="hljs-comment">// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals</span><br>reportWebVitals();<br></code></pre></td></tr></table></figure><p>稍作解释：<br>Clock.js 中首先要引入<code>import React,&#123;Component&#125; from &#39;react&#39;;</code>(基本每个React组件都要引用)，创建组件，在组件构造函数生命周期中初始化 state 状态(初始化一个对象)，<code>new Date()</code>定义了一个 Date 对象，在 render 中调用 Date 对象的<code>.toLocaleTimeString()</code>方法，根据本地时间格式，把 Date 对象的时间部分转换为字符串。可结合“Date 对象”一起学习。最后 <code>export default xxx</code>导出组件类<br>index.js 主要包含了 <code>ReactDOM.render()</code> 方法，需要 <code>import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import Clock from &#39;./Clock&#39;;</code>，然后导入组件进行渲染。</p><p>ok! <code>npm start</code>运行~<br><img src="/img/posts_img/20201110103616469_23459.png"><br>what!!!出错了，好像render()没有return，大意了。加上return后再运行(注意return后加 <strong><code>()</code></strong> )。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Clock.js代码：<br><span class="hljs-keyword">import</span> React,&#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>()<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;h1&gt;<br>                    &lt;p&gt;现在时间是&lt;/p&gt;<br>                    &#123;<span class="hljs-built_in">this</span>.state.date.toLocaleTimeString()&#125;<br>                &lt;/h1&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Clock;<br></code></pre></td></tr></table></figure><p><img src="/img/posts_img/20201110103942355_23640.png"></p><h3 id="step3：实现时间动态："><a href="#step3：实现时间动态：" class="headerlink" title="step3：实现时间动态："></a>step3：实现时间动态：</h3><p>完美！但是现在时间是静态的，我们需要加上一个定时器，放在 componentWillMount() 生命周期中，每隔多少秒就重新更新一次state状态（实际操作过程中，发现vscode竟然没有自动提示componentWillMount()，果然是被淘汰了呀，不过幸好还能用）。<br><img src="/2020/11/10/%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5%E7%9A%84%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E4%BA%8C%EF%BC%89/_posts/img/20201110104750052_1966.png"><br>上述意思大致是：componentWillMount 被重命名为了 UNSAFE_componentWillMount，React 建议少用 componentWillMount，因为初始化状态可以在 constructor 中进行，其余的可以在 componentDidMount 中进行，所以没 componentWillMount 啥事了。</p><p>扯远了，继续撸代码，上步我们加了一个 componentWillMount，里面装了个定时器setInterval()，每个1000ms重新更新一下状态并渲染(this.setState)，这里由于每秒都会渲染一次，所以不用担心componentWillMount 无法二次渲染的问题。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">...<br>componentWillMount() &#123;<br>    <span class="hljs-built_in">this</span>.timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">this</span>.setState(&#123;date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;)<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;<br>...<br></code></pre></td></tr></table></figure><h3 id="step4：时间隐藏与显示"><a href="#step4：时间隐藏与显示" class="headerlink" title="step4：时间隐藏与显示"></a>step4：时间隐藏与显示</h3><p>至此我们实现了时钟的动态展示，下一步我们实现时间的隐藏：<br>在 index.js 中新建一个 Index 类，用来包裹 Clock 组件，并设置一些隐藏的功能。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript">index.js：<br><span class="hljs-keyword">import</span> reportWebVitals <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reportWebVitals&#x27;</span>;<br><br><span class="hljs-keyword">import</span> React,&#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;  <span class="hljs-comment">//加上了&#123;Component&#125;</span><br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> Clock <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Clock&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Index</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>()<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>      isShowClock: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">handleShowOrHide</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      isShowClock: !<span class="hljs-built_in">this</span>.state.isShowClock<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &#123;<span class="hljs-built_in">this</span>.state.isShowClock?<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span></span>:<span class="hljs-literal">null</span>&#125;<br>        &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.handleShowOrHide.bind(<span class="hljs-built_in">this</span>)&#125;&gt;显示/隐藏&lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<br>  &lt;React.StrictMode&gt;<br>    &lt;Index /&gt;<br>  &lt;/React.StrictMode&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br><br><span class="hljs-comment">// If you want to start measuring performance in your app, pass a function</span><br><span class="hljs-comment">// to log results (for example: reportWebVitals(console.log))</span><br><span class="hljs-comment">// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals</span><br>reportWebVitals();<br></code></pre></td></tr></table></figure><p>需要注意的几点：</p><ol><li>this.setState()是一个方法，传入一个state对象，即用新的state更新上一时间的state状态(注意是更新而非替换，若新的状态不在原来的状态内，则是添加操作)。</li><li>组件中调用状态值都要用 <code>this.state.属性名</code> 的形式。</li><li>关注<code>&lt;div&gt;&#123;...&#125;&lt;/div&gt;</code>的形式，这是典型的JSX书写，即HTML中嵌入JS代码。任何函数及表达式在JSX中都要写入 <strong><code>&#123;&#125;</code></strong> 内，例如<code>onClick=&#123;...函数...&#125;</code></li><li>注意 <code>.bind(this)</code>，组件内部函数没有绑定 this 对象，所以需要人为绑定。箭头函数例外，箭头函数会自动指向 this。</li></ol><p>更新完之后，我们运行代码：<br><img src="/img/posts_img/20201110114320822_23996.png"><br><img src="/img/posts_img/20201110114332942_23846.png"></p><h3 id="step5：添加componentWillUnmout，清除定时器"><a href="#step5：添加componentWillUnmout，清除定时器" class="headerlink" title="step5：添加componentWillUnmout，清除定时器"></a>step5：添加componentWillUnmout，清除定时器</h3><p>隐藏和显示的功能我们已经实现了，但是F12调试发现居然报错了！<br><img src="/img/posts_img/20201110114426671_5798.png"><br>报错原因大致是：没有 unmount 的组件，容易造成内存泄露。结合小书学习我们可知，定时器在每次组件移除时并没有被清除，下一次组件生成时又创建了一个新的定时器，时钟隐藏的时候，定时器的回调函数还在不停地尝试 setState，由于 setState 只能在已经挂载或者正在挂载的组件上调用，所以 React.js 开始疯狂报错。这时候componentWillUnmount 就可以派上用场了，它的作用就是在组件销毁的时候，做这种清场的工作。例如清除该组件的定时器和其他的数据清理工作。我们给 Clock 添加 componentWillUnmount，在组件销毁的时候清除该组件的定时器：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Clock</span>.</span></span>js:<br>...<br>component<span class="hljs-constructor">WillUnmount()</span> &#123;<br>    clear<span class="hljs-constructor">Interval(<span class="hljs-params">this</span>.<span class="hljs-params">timer</span>)</span><br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>注意：这行代码是写在 Clock.js 下的。<br>至此，我们完成了实战，时间能动态走动，且能隐藏或显示，并且不会报错。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们一般会把组件的 state 的初始化工作放在 constructor 里面去做；<br>在 componentWillMount 进行组件的启动工作，例如 Ajax 数据拉取、定时器的启动；<br>组件从页面上销毁的时候，有时候需要一些数据的清理，例如定时器的清理，就会放在 componentWillUnmount 里面去做。</p><p>没有提到的 componentDidMount 将在后续讲解。一般来说，有些组件的启动工作是依赖 DOM 的，例如动画的启动，而 componentWillMount 的时候组件还没挂载完成，所以没法进行这些启动工作，这时候就可以把这些操作放在 componentDidMount 当中。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React小书学习笔记 —— 挂载阶段的组件生命周期（一）</title>
    <link href="/2020/11/09/%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5%E7%9A%84%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/11/09/%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5%E7%9A%84%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习前端一小步，迈向成功一大步！本专栏主要记录学习前端React框架的一些个人心得，分享一些实战教学，如有不足，欢迎交流讨论。React框架的入门教学强推<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a>的<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a>，简单易懂还有代码实战。还等什么？让我们开始本篇的前端学习之旅，欢迎各位入坑前端！</p><a id="more"></a><h1 id="挂载阶段的组件生命周期（一）"><a href="#挂载阶段的组件生命周期（一）" class="headerlink" title="挂载阶段的组件生命周期（一）"></a>挂载阶段的组件生命周期（一）</h1><p>参考教程：React小书–第18节(挂载阶段的组件生命周期(一)）<br>教程作者：<a href="https://www.zhihu.com/people/hu-zi-da-ha">胡子大哈</a><br>参考链接：<a href="http://huziketang.mangojuice.top/books/react/lesson18">React小书</a><br><strong>本文搭配原文教程食用，风味更佳~!</strong></p><hr><h2 id="组件挂载"><a href="#组件挂载" class="headerlink" title="组件挂载"></a>组件挂载</h2><p>定义：React.js 将<strong>组件渲染</strong>，并且<strong>构造 DOM 元素然后塞入页面</strong>的过程。<br>回顾前文可知，在每个组件内部<code>render()</code>方法能够实现虚拟DOM元素的构造，而组件真实DOM元素的构造实际上是在<code>ReactDOM.render()</code>方法中实现的。<br>了解上述知识后对定义做更深入的解释：</p><ol><li>组件渲染：==<code>render()</code>，包括了虚拟DOM元素的构造<code>constructor()</code>和渲染<code>render()</code>。</li><li>构造DOM元素并渲染到页面：==<code>ReactDOM.render()</code>，包括了真正DOM元素的渲染。</li></ol><p>React.js 内部对待每个组件都有这么一个组件挂载的过程，也就是<strong>初始化组件 -&gt; 挂载到页面</strong>的过程。具体挂载过程如下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">-&gt; <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span> #组件内部的构造函数</span><br><span class="hljs-function">-&gt; <span class="hljs-title">render</span><span class="hljs-params">()</span> #虚拟<span class="hljs-title">DOM</span>渲染</span><br><span class="hljs-function"><span class="hljs-comment">//构造真实 DOM 元素插入页面</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">render</span><span class="hljs-params">()</span> #构造真正<span class="hljs-title">DOM</span>元素渲染到页面</span><br></code></pre></td></tr></table></figure><blockquote><p>更新：ReactDOM.render() 返回 render() 的 Component 实例，即虚拟DOM的实例，其实就是真实DOM元素。<a href="http://react-china.org/t/reactdom-render/5631">参考</a></p></blockquote><h2 id="React组件挂载的生命周期"><a href="#React组件挂载的生命周期" class="headerlink" title="React组件挂载的生命周期"></a>React组件挂载的生命周期</h2><p>组件挂载时有关的生命周期有以下几个：</p><ol><li>constructor()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount()</li></ol><p>此处为什么单独罗列出来呢？因为 <code>constructor()</code>,<code>render()</code>也是组件挂载的生命周期，此处没有理解说明对<a href="https://www.jianshu.com/p/e3d1ecfb6312">React生命周期</a>的概念没有理解透彻，不过不着急，可以先进行后面的学习，回头再结合React组件生命周期的总体框架图，你将会恍然大悟，总体框架图后续补充~</p><h2 id="componentWillMount-amp-componentDidMount-amp-componentWillUnmount"><a href="#componentWillMount-amp-componentDidMount-amp-componentWillUnmount" class="headerlink" title="componentWillMount &amp; componentDidMount &amp; componentWillUnmount"></a>componentWillMount &amp; componentDidMount &amp; componentWillUnmount</h2><p>我们已经知道了 componentWillMount 和 componentDidMount 是<strong>组件挂载</strong>时的生命周期(还有组件更新的生命周期，此处要区分)，他们的作用主要是为了让我们更好的掌握组件的挂载过程，加入了 componentWillMount 和 componentDidMount 后，我们的组件挂载过程就可以表示如下：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi">-&gt; <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">componentWillMount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//构造真实 DOM 元素插入页面</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>componentWillMount 和 componentDidMount 都是像 render 方法一样自定义在组件内部的，即如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xxx</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>()<br>        ...<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">componentWillMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//每个组件必须实现一个render()方法，render方法必须返回一各JSX元素，return必须带()，必须要用一个外层的 JSX 元素把所有内容包裹起来,返回并列多个 JSX 元素是不合法的。</span><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                JSX<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>更新：<a href="https://www.jianshu.com/p/00226a584eff">react 组件的 render 方法</a>，对应上述代码中关于 render 方法注意事项的解释。</p></blockquote><p>挂载的时候，React.js 会在组件的<code>render()</code>之前调用 componentWillMount，在 DOM 元素塞入页面(即<code>ReactDOM.render()</code>)以后调用 componentDidMount。</p><p>此外，我们既然能控制组件插入页面时的生命周期，那么我们应该也能控制其在页面中删除的生命周期，React.js 实际上也控制了这个组件的删除过程。在组件删除之前 React.js 会调用组件定义的 componentWillUnmount。那么我们的组件挂载生命周期可以写成：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs delphi">-&gt; <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">componentWillMount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//构造真实 DOM 元素插入页面</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">ReactDOM</span>.<span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">...</span><br><span class="hljs-function"><span class="hljs-comment">// 即将从页面中删除</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">componentWillUnmount</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">// 从页面中删除</span></span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们已经简单了解了<strong>组件挂载过程的生命周期</strong>，本节主要有以下几个重点：</p><ol><li>组件挂载的定义 </li><li>什么是组件的生命周期</li><li>componentWillMount()：组件挂载开始之前，也就是在组件调用 render 方法之前调用。</li><li>componentDidMount()：组件挂载完成以后，也就是 DOM 元素已经插入页面后调用。</li><li>componentWillUnmount()：组件对应的 DOM 元素从页面中删除之前调用。</li></ol><p>我们需要重点理解的是，<strong>组件生命周期调用是有次序的</strong>，自上而下分别是 <strong><code>constructor -&gt; componentWillMount -&gt; render -&gt; ReactDOM.render -&gt; componentDidMount -&gt; componentWillUnmount</code></strong> 。</p><p><a href="https://zhidao.baidu.com/question/1798845195476676427.html">参考</a><br>也就是当说如果你要<strong>获取外部数据并加载到组件上，只能在组件”已经”挂载到真实的网页上才能作这事情，其它情况你是加载不到组件的</strong>。componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。<br>constructor被调用是在组件准备要挂载的最一开始，所以此时组件尚未挂载到网页上。componentWillMount方法的调用在constructor之后，在render之前，在这方法里的代码调用setState方法不会触发重渲染，所以它一般不会用来作加载数据之用，它也很少被使用到**(componentWillMount无法触发setState重渲染)**。一般的从后台(服务器)获取的数据，都会与组件上要用的数据加载有关，所以都在componentDidMount方法里面作。虽然与组件上的数据无关的加载，也可以在constructor里作，但constructor是作组件state初绐化工作，并不是设计来作加载数据这工作的，所以所有有副作用的代码都会集中在componentDidMount方法里。</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的博客</title>
    <link href="/2020/11/08/%E8%A7%A3%E5%86%B3hexo%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0md%E4%B8%AD%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/08/%E8%A7%A3%E5%86%B3hexo%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0md%E4%B8%AD%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>编辑完 .md 文件后，发现 .md 文件中的图片 markdown 书写方法引用的是相对路径，推送到博客上导致无法显示图片，故在网上寻找相应的解决方法，并将其记录下来。</p><a id="more"></a><h1 id="解决hexo无法上传md中本地图片的问题"><a href="#解决hexo无法上传md中本地图片的问题" class="headerlink" title="解决hexo无法上传md中本地图片的问题"></a>解决hexo无法上传md中本地图片的问题</h1><p><strong><em>努力的意义就是以后的日子，放眼望去全部都是自己喜欢的人和事。</em></strong></p><hr><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>编辑完 .md 文件后，发现 .md 文件中的图片 markdown 书写方法引用的是相对路径，推送到博客上导致无法显示图片，故在网上寻找相应的解决方法。<br><strong>参考链接：(大佬写的很详细，可详读)</strong><br><a href="https://blog.csdn.net/xjm850552586/article/details/84101345">hexo引用本地图片无法显示</a></p><h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><ol><li>本地图片没有有效上传至github仓库中，导致引用无效<br>解决方案：安装插件(见下文解决方案)</li><li>本地图片没有存放在同名文件夹中<br>解决方案：将需要引用的本地图片存放在与文章名相同的文件夹中</li><li>图片路径出错<br>解决方案：打开 <code>_config.yml</code> 修改 url 配置参数，将 url 改为 github 仓库地址或者域名 (如 <code>jtwang7.github.io</code> 或 <code>wangjintian.com</code>)</li><li>.md 文件中图片引用相对路径没有更换<br>解决方法：通常我们将 .md 文件的图片存于与该文件同名的文件夹中，然后一同放到 <code>myBlog/source/_posts/</code> 中( _posts 文件夹用于存储文章及文章所包含的图片)，因此，原本 .md 文件中的图片相对路径会发生改变，需要对相应路径进行调整，同时，VNote 引用的图片不要做大小调整(即不可用=…px)！！！否则会导致加载不出来。</li></ol><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="第一步：安装hexo-asset-image插件"><a href="#第一步：安装hexo-asset-image插件" class="headerlink" title="第一步：安装hexo-asset-image插件"></a>第一步：安装hexo-asset-image插件</h3><p>具体方法：<br>首先需要安装一个图片路径转换的插件，插件名为<strong>hexo-asset-image</strong>。<br>进入 myBlog 文件夹(即你的博客根目录)，右击 Git Bush Here，输入命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><h3 id="第二步：替换hexo-asset-image插件的index-js文件内容"><a href="#第二步：替换hexo-asset-image插件的index-js文件内容" class="headerlink" title="第二步：替换hexo-asset-image插件的index.js文件内容"></a>第二步：替换hexo-asset-image插件的index.js文件内容</h3><p>打开<code>myBlog/node_modules/hexo-asset-image/index.js</code>，将内容更换为下面的代码(不更改会出Bug):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cheerio&#x27;</span>);<br><br><span class="hljs-comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPosition</span>(<span class="hljs-params">str, m, i</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str.split(m, i).join(m).length;<br>&#125;<br><br><span class="hljs-keyword">var</span> version = <span class="hljs-built_in">String</span>(hexo.version).split(<span class="hljs-string">&#x27;.&#x27;</span>);<br>hexo.extend.filter.register(<span class="hljs-string">&#x27;after_post_render&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> config = hexo.config;<br>  <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">config.post_asset_folder</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> link = data.permalink;<br><span class="hljs-keyword">if</span>(version.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">Number</span>(version[<span class="hljs-number">0</span>]) == <span class="hljs-number">3</span>)<br>   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>   <span class="hljs-keyword">var</span> beginPos = getPosition(link, <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span><br><span class="hljs-keyword">var</span> endPos = link.lastIndexOf(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>;<br>    link = link.substring(beginPos, endPos);<br><br>    <span class="hljs-keyword">var</span> toprocess = [<span class="hljs-string">&#x27;excerpt&#x27;</span>, <span class="hljs-string">&#x27;more&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>];<br>    <span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; toprocess.length; i++</span>)</span>&#123;<br>      <span class="hljs-keyword">var</span> key = toprocess[i];<br> <br>      <span class="hljs-keyword">var</span> $ = cheerio.load(data[key], &#123;<br>        ignoreWhitespace: <span class="hljs-literal">false</span>,<br>        xmlMode: <span class="hljs-literal">false</span>,<br>        lowerCaseTags: <span class="hljs-literal">false</span>,<br>        decodeEntities: <span class="hljs-literal">false</span><br>      &#125;);<br><br>      $(<span class="hljs-string">&#x27;img&#x27;</span>).each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span> ($(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>))&#123;<br><span class="hljs-comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span><br><span class="hljs-keyword">var</span> src = $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>).replace(<span class="hljs-string">&#x27;\\&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br><span class="hljs-keyword">if</span>(!<span class="hljs-regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;<br>   !<span class="hljs-regexp">/^\s*\//</span>.test(src)) &#123;<br>  <span class="hljs-comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span><br>  <span class="hljs-comment">// In addition, to support multi-level local directory.</span><br>  <span class="hljs-keyword">var</span> linkArray = link.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br><span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;);<br>  <span class="hljs-keyword">var</span> srcArray = src.split(<span class="hljs-string">&#x27;/&#x27;</span>).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>)</span>&#123;<br><span class="hljs-keyword">return</span> elem != <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="hljs-string">&#x27;.&#x27;</span>;<br>  &#125;);<br>  <span class="hljs-keyword">if</span>(srcArray.length &gt; <span class="hljs-number">1</span>)<br>srcArray.shift();<br>  src = srcArray.join(<span class="hljs-string">&#x27;/&#x27;</span>);<br>  $(<span class="hljs-built_in">this</span>).attr(<span class="hljs-string">&#x27;src&#x27;</span>, config.root + link + src);<br>  <span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);<br>&#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;no src attr, skipped...&quot;</span>);<br><span class="hljs-built_in">console</span>.info&amp;&amp;<span class="hljs-built_in">console</span>.info($(<span class="hljs-built_in">this</span>));<br>&#125;<br>      &#125;);<br>      data[key] = $.html();<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="第三步：修改-config-yml文件配置"><a href="#第三步：修改-config-yml文件配置" class="headerlink" title="第三步：修改_config.yml文件配置"></a>第三步：修改_config.yml文件配置</h3><p>打开_config.yml文件，修改下述内容(可<code>Ctrl+F</code>调出查找，搜索 post_asset_folder)：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的博客(一)</title>
    <link href="/2020/11/08/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA(%E4%B8%80)%E2%80%94%E2%80%94Github+Hexo/"/>
    <url>/2020/11/08/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA(%E4%B8%80)%E2%80%94%E2%80%94Github+Hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>创建博客的初衷是为了记录和总结自己的学习心得，也希望将自己的一些经历分享给同样在努力奋斗的你。本篇将带着你一步步搭建专属于你的博客网站。在学习之前，你需要具备以下前提：1. 拥有一个专属于你的GitHub 2. 电脑上需安装有Git 3. 需要安装node.js并完成相应的环境配置</p><a id="more"></a><h1 id="从零开始的博客搭建-一-——GitHub-Hexo"><a href="#从零开始的博客搭建-一-——GitHub-Hexo" class="headerlink" title="从零开始的博客搭建(一)——GitHub+Hexo"></a>从零开始的博客搭建(一)——GitHub+Hexo</h1><p><strong><em>努力的意义就是以后的日子，放眼望去全部都是自己喜欢的人和事。</em></strong></p><hr><p>创建博客的初衷是为了记录和总结自己的学习心得，也希望将自己的一些经历分享给同样在努力奋斗的你。本篇将带着你一步步搭建专属于你的博客网站。<br><strong>在学习之前，你需要具备以下前提：</strong></p><p><strong>1. 拥有一个专属于你的GitHub</strong><br><strong>2. 电脑上需安装有Git</strong><br><strong>3. 需要安装node.js并完成相应的环境配置</strong></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>Hexo 是目前比较常用的静态博客搭建框架，除 Hexo 外，比较常用的还有 jekyll, hugo 等，可以酌情选择，本篇则以 GitHub + Hexo 搭建博客。</p><h3 id="第一步：在GitHub上创建仓库"><a href="#第一步：在GitHub上创建仓库" class="headerlink" title="第一步：在GitHub上创建仓库"></a>第一步：在GitHub上创建仓库</h3><p>登录你的 GitHub 账号，进入该页面：</p><p><img src="/img/posts_img/20201108195954111_21042.png"></p><p>进入 Repository 仓库，点击 New 创建新的仓库，转入下图页面。</p><p><img src="/img/posts_img/20201108200309207_10161.png"></p><p>你需要填写仓库名称**(你的用户名+<code>.github.io</code>)**，然后点击创建 Create repository 即可。</p><h3 id="第二步：安装Hexo"><a href="#第二步：安装Hexo" class="headerlink" title="第二步：安装Hexo"></a>第二步：安装Hexo</h3><p>首先在你想要存放博客文件的位置创建一个文件夹，例如我的博客在本机中的路径为 <code>G:\myBlog</code>，打开 myBlog 文件夹，鼠标右键打开 Git Bush Here (前提是你要成功安装Git)，输入 npm 命令安装 Hexo：<code>npm install -g hexo-cli</code>。<br>安装完成后，输入 <code>hexo init</code> 初始化博客。<br>其次，输入 <code>hexo g</code> 静态部署。<br>至此，网页已经部署完成了，我们可以输入 <code>hexo s</code> 命令查看，此时浏览器输入 <code>http://localhost:4000</code> 就可以查看到 Hexo 的初始页面啦。</p><p><strong>小结：</strong></p><ol><li>新建文件夹，在该文件夹下右击打开 Git Bush Here</li><li><code>npm install -g hexo-cli</code></li><li><code>hexo init</code></li><li><code>hexo g</code></li><li><code>hexo s</code> (可跳过)</li></ol><blockquote><p>啥？你问我 <code>hexo g</code> 和 <code>hexo s</code> 的具体作用？转载一下这篇博客，讲的很清楚啦，后续出现的一些命令这里也有说明：<a href="https://blog.csdn.net/dxxzst/article/details/76135935">Hexo 常用命令</a></p></blockquote><h3 id="第三步：将Hexo部署到GitHub"><a href="#第三步：将Hexo部署到GitHub" class="headerlink" title="第三步：将Hexo部署到GitHub"></a>第三步：将Hexo部署到GitHub</h3><p>我们已经在 myBlog 中安装了 Hexo 框架，但这些仍是在本机上的一些操作，我们需要把它部署到之前创建的 GitHub 仓库上。<br>同样是在 myBlog 文件夹中，用笔记本的方式打开 <code>_config.yml</code> 文件。</p><blockquote><p>该文件配置了你博客的相关的内容，关于 <code>_config.yml</code> 文件中的配置参数解释，可以参考：<a href="https://blog.csdn.net/zemprogram/article/details/104288872">hexo根目录下的_config.yml配置解释</a><br><strong>所有参数中，冒号 <code>:</code> 后面都要带上空格。</strong></p></blockquote><p>将 <code>_config.yml</code> 文件下拉至底部，修改 deploy (部署)配置参数，如图：</p><p><img src="/img/posts_img/20201108202628168_13089.png"></p><p>其中 type 为部署的方法，repository 为部署的仓库名称(即我们此前创建的仓库clone地址)，branch 为分支(默认主支 master)<br>repository 仓库地址直接从 clone 复制，首先进入你创建的仓库，然后按下步操作进行：</p><p><img src="/img/posts_img/20201108203039449_16182.png"></p><p>回到 myBlog 文件夹中，右击 Git Bush Here，安装 Git 部署插件，输入命令 <code>npm install hexo-deployer-git --save</code>。<br>然后分别输入 <code>hexo clean</code>, <code>hexo g</code>, <code>hexo d</code>。<br>完成上述步骤后，打开浏览器，我们就可以用 <code>https://your_user_name.github.io</code> (此处为 <code>jtwang7.github.io</code>) 代替 <code>http://localhost:4000</code> 打开博客了。</p><p><strong>小结：</strong></p><ol><li>打开 myBlog 目录中的 <code>_config.yml</code> 配置参数文件，修改 deploy 参数。</li><li>在 myBlog 路径下，<code>npm install hexo-deployer-git --save</code></li><li><code>hexo clean</code> #清除缓存文件 db.json 和已生成的静态文件 public</li><li><code>hexo g</code> #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</li><li><code>hexo d</code> #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</li></ol><h3 id="第四步：购买-解析域名，制作个性化的访问地址"><a href="#第四步：购买-解析域名，制作个性化的访问地址" class="headerlink" title="第四步：购买/解析域名，制作个性化的访问地址"></a>第四步：购买/解析域名，制作个性化的访问地址</h3><p>走到上一步，我们已经可以用 <code>https://jtwang7.github.io</code> 访问博客了，但是本着对 .com 的执着，在<a href="https://cloud.tencent.com/?fromSource=gwzcw.2212127.2212127.2212127&utm_medium=cpd&utm_id=gwzcw.2212127.2212127.2212127">腾讯云</a>上购买了一个 .com 的域名，具体购买过程就不细说了，按照网站提示操作就行，除了腾讯云外，也可以在<a href="https://wanwang.aliyun.com/">万网</a>，<a href="https://sg.godaddy.com/zh/offers/domains/godaddycom?isc=gennbacn07&countryview=1&currencyType=CNY&utm_source=baidu&utm_medium=cpc&utm_term=Title&utm_campaign=zh-cn_corp_sem_x_b_x_bz_001&utm_content=Brandzone%20PC&gclid=CIXh9LjPmecCFdOavAoddDkHcw&gclsrc=ds">Godaddy</a>上购买。<br>主要讲一下域名解析的一些过程，以腾讯云为例。<br>首先进入腾讯云控制台，点击域名注册进入域名控制台管理。</p><p><img src="/img/posts_img/20201108204915553_22845.png"></p><p>第二步点击解析。</p><p><img src="/img/posts_img/20201108204944145_13319.png"></p><p>第三步添加以下两条解析记录，其中 IPV4 地址可以通过ping得到，具体方法是：打开cmd输入下面命令：<code>ping jtwang7.github.io</code> #ping + 你的 GitHub 仓库地址</p><p><img src="/img/posts_img/20201108205233329_15863.png"></p><p>至此，在腾讯云上的域名解析已经完成了，我们看到在记录里，有一个记录类型为 CNAME，接下来我们要打开 myBlog 文件夹的 source 文件夹，添加 CNAME 文件，可以先创建一个CNAME.txt文件，打开后写上你的域名，即你购买时申请的域名，(不要加www否则每次访问都必须加www，但如果不带有www，以后访问的时候带不带www都可以访问)，保存后记得要重命名，将.txt删除。</p><p><img src="/img/posts_img/20201108205644657_21100.png"><br><img src="/img/posts_img/20201108205702960_15023.png"></p><p>最后，回到 myBlog 文件夹下，依次输入 <code>hexo clean</code>, <code>hexo g</code>, <code>hexo d</code>。<br>打开 GitHub，查看 CNAME 文件是否在项目中，如图：</p><p><img src="/img/posts_img/20201108210014793_7086.png"></p><p>若没有该文件，则点击 <code>Settings</code>，在 GitHub Pages 中查看域名是否保存，若域名没有自动填写，则手动将其填上并保存，则项目中会出现 CNAME 文件，若还没有 CNAME 文件，则点击 <code>Add file</code>，自行添加即可。</p><p>![]/img/posts_img/20201108210255514_19277.png)<br>![]/img/posts_img/20201108210359154_32401.png)<br>![]/img/posts_img/20201108210335057_9425.png)</p><p>现在，你可以用你自己的域名来访问博客了~</p><p><strong>小结：</strong></p><ol><li>购买域名</li><li>解析域名</li><li>在 myBlog/source/ 中添加 CNAME 文件</li><li>回到 myBlog 文件夹，Git Bush Here</li><li><code>hexo clean</code></li><li><code>hexo g</code></li><li><code>hexo d</code></li><li>检查 GitHub 是否有 CNAME 文件，若无，则在 GitHub 中添加域名</li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
